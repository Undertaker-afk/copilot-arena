prefix,suffix,model_a,model_b,acceptedIndex,completion_a,completion_b
"import * as vscode from 'vscode';
import { StatisticsViewProvider } from './statisticsView';

// Interface for storing code snippets
interface CodeSnippet {
    id: string;
    content: string;
    isLLMGenerated: boolean;
    timestamp: Date;
    filePath: string;
}

// Global state to store code snippets
let codeSnippets: CodeSnippet[] = [];

function generateUniqueId(): string {
    return Math.random().toString(36).substring(2, 15) + Math.random().toString(36).substring(2, 15);
}

function saveData(context: vscode.ExtensionContext) {
    context.globalState.update('llmCodeSnippets', codeSnippets);
}

function loadData(context: vscode.ExtensionContext) {
    const savedSnippets = context.globalState.get('llmCodeSnippets') as CodeSnippet[] | undefined;
    if (savedSnippets) {
        codeSnippets = savedSnippets;
    }
}

export function activate(context: vscode.ExtensionContext) {
    console.log('LLM Code Usage Tracker is now active');

	loadData(context);

    // Register a command to toggle LLM-generated code
	let toggleLLMCode = vscode.commands.registerCommand('llm-tracker.toggleLLMCode', () => {
		const editor = vscode.window.activeTextEditor;
		if (editor) {
			const selection = editor.selection;
			const text = editor.document.getText(selection);
			
			const isLLMGenerated = !editor.document.getText(selection).includes('// LLM-generated');
			editor.edit(editBuilder => {
				editBuilder.replace(selection, text + (isLLMGenerated ? ' // LLM-generated' : ''));
			});
		}
	});

	let removeLLMCode = vscode.commands.registerCommand('llm-tracker.removeLLMCode', () => {
		const editor = vscode.window.activeTextEditor;
		if (editor) {
			const selection = editor.selection;
			const text = editor.document.getText(selection);
			const cleanedText = text.replace('// LLM-generated', '');
			editor.edit(editBuilder => {
				editBuilder.replace(selection, cleanedText);
			});
		}
	});

	let addLLMCode = vscode.commands.registerCommand('llm-tracker.addLLMCode', () => {
		const editor = vscode.window.activeTextEditor;
		if (editor) {
			const selection = editor.selection;
			const text = editor.document.getText(selection);
				const snippet: CodeSnippet = {
					id: generateUniqueId(),
					content: text,
					isLLMGenerated: true,
					timestamp: new Date(),
					filePath: editor.document.uri.fsPath
				};
				codeSnippets.push(snippet);
				vscode.window.showInformationMessage('Code marked as LLM-generated');
				
				// Highlight the LLM-generated code
				const decoration = vscode.window.createTextEditorDecorationType({
					backgroundColor: 'rgba(65, 105, 225, 0.3)' // Light blue background
				});
				editor.setDecorations(decoration, [selection]);
			

	let addLLMCode = vscode.commands.registerCommand('llm-tracker.addLLMCode', () => {
		const editor = vscode.window.activeTextEditor;
		if (editor) {
			const selection = editor.selection;
			const text = editor.document.getText(selection);
				const snippet: CodeSnippet = {
					id: generateUniqueId(),
					content: text,
					isLLMGenerated: true,
					timestamp: new Date(),
					filePath: editor.document.uri.fsPath
				};
				codeSnippets.push(snippet);
				vscode.window.showInformationMessage('Code marked as LLM-generated');
				
				// Highlight the LLM-generated code
				const decoration = vscode.window.createTextEditorDecorationType({
					backgroundColor: 'rgba(65, 105, 225, 0.3)' // Light blue background
				});
				editor.setDecorations(decoration, [selection]);
			}
		}
	});

	const provider = new StatisticsViewProvider(context.extensionUri);
    context.subscriptions.push(
        vscode.window.registerWebviewViewProvider(StatisticsViewProvider.viewType, provider)
    );

   	// Update the showStats command to use the new view
   	let showStats = vscode.commands.registerCommand('llm-tracker.showStats', () => {
		const totalLines = codeSnippets.reduce((acc, snippet) => acc + snippet.content.split('\n').length, 0);
		const llmLines = codeSnippets
			.filter(snippet => snippet.isLLMGenerated)
			.reduce((acc, snippet) => acc + snippet.content.split('\n').length, 0);
		
		const llmPercentage = (llmLines / totalLines * 100).toFixed(2);
		
		provider.updateStats({
			totalLines,
			llmLines,
			llmPercentage
		});
	});

    context.subscriptions.push(toggleLLMCode, showStats);
}

export function deactivate(context: vscode.ExtensionContext) {
	saveData(context);
}

export function activate(context: vscode.ExtensionContext) {
	ac","
",claude-3-5-sonnet-20241022,llama-3.1-70b-instruct,0.0,"tivate(context);

	loadData(context);","	// Update the showStats command to use the new view
   	let showStats = vscode.commands.registerCommand('llm-tracker.showStats', () => {
		const totalLines = codeSnippets.reduce((acc, snippet) => acc + snippet.content.split('
').length, 0);
		const llmLines = codeSnippets
			.filter(snippet => snippet.isLLMGenerated)
			.reduce((acc, snippet) => acc + snippet.content.split('
').length, 0);
		
		const llmPercentage = (llmLines / totalLines * 100).toFixed(2);
		
		provider.updateStats({
			totalLines,
			llmLines,
			llmPercentage
		});
	});

    context.subscriptions.push(toggleLLMCode, showStats);
}

export function deactivate(context: vscode.ExtensionContext) {
	saveData(context);"
"#include <iostream>

struct Node {
    Node* l;
    Node* r;
    int value;
};

Node* insert(Node* node, int value) {
    if (node == nullptr) {
        node = new Node;
        node->l = nullptr;
        node->r = nullptr;
        node->value = value;
    } else {
        if (value < node->value) {
            node->l = insert(node->l, value);
        } else {
            node->r = insert(node->r, value);
        }
    }
    return node;
}
std::string createTree(Node* root) {
    Node* lastn = nullptr;
    int level = 1;
    std::string res;
    while (lastn!=nullptr){","


    }
    return res;
}
int main() {
    int n;
    std::cout<<""count of:\n""; 
    std::cin >> n;
    std::cout<<""type values for ""<<n<<"" nodes:\n""; 
    Node* root = nullptr;
    for (int i = 0; i < n; ++i) {
        int value;
        std::cin >> value;
        root = insert(root, value);
    }
    std::cout <<createTree(root);
    return 0;
    
}
",qwen-2.5-coder-32b-instruct,gpt-4o-mini-2024-07-18,0.0,"
    Node* n = root;
    for (int i = 0; i < level; i++) {
        if (n->l != nullptr) {
            res += std::to_string(n->l->value) + "" "";
            lastn = n->l;
        }
        if (n->r != nullptr) {
            res += std::to_string(n->r->value) + "" "";
            lastn = n->r;
        }
        n = n->r;
    }
    level++;","    lastn = nullptr;
    int level = 1;
    std::string res;
    while (lastn!=nullptr){"
"import plotly.graph_objects as go
from src.data.Building import Building
from config.config import BASE_DIR

colors = {
    'yellow': '#f9ca24',
    'orange': '#f0932b',
    'red': '#eb4d4b',
    'grey': '#535c68',
    'blue': '#4834d4',
    'blue_bell': '#3B3B98',
    'blue_chill': '#1B9CFC',
    'blue_discoball': '#25CCF7',
    'black_ships_officer': '#2C3A47',
    'green_sweet_garden': '#55E6C1', 
    'green_keppel': '#58B19F',
    'lavender': '#82589F',
    'magenta_purple': '#6D214F',
}


class DataPlotter:
    def __init__(self, building, colors=colors, base_dir=BASE_DIR):
        self.colors = colors
        self.fig = go.Figure()
        self.base_dir = base_dir
        self.building = building

    def add_meter_bar_traces(self, meter_tags, data_resampler):
        """"""
        Add bar traces to the figure based on tag IDs and colors.
        """"""
        BARMODE = ""stack""
        for tag_id, colorname, visible in meter_tags:
            tag = self.building.tags[tag_id]
            data = tag.get_data()
            daily = data_resampler.make_daily_meter(data)
            
            daily['bar_color'] = [
                self.colors['red'] if score > 10 else self.colors['orange'] if score > 1 else self.colors['yellow'] if score > 0 else self.colors['grey'] if day in [5, 6] else self.colors[colorname]
                for score, day in zip(daily['warning_score'], daily.index.dayofweek)
            ]
            
            _ = self.fig.add_trace(go.Bar(
                x=daily.index,
                y=daily['daily_consumption'],
                name=tag_id,
                marker=dict(
                    color=daily.bar_color,
                    opacity=[0.9 if score > 0 else 1 for score in daily['warning_score']]
                ),
                hovertext=[
                    f'{tag_id} : <b>{v}</b>' + '<br>' +
                    f'Warning: {score} :' + '<br>' + message +
                    '<extra></extra>'
                    for v, score, message in zip(daily['daily_consumption'], daily['warning_score'], daily['warning_message'])
                ],
                visible=visible,
                hovertemplate='%{hovertext}',
            ))

    def add_line_traces(self, signal_tags, data_resampler):
        """"""
        Add line traces for signal AUC data.
        """"""
        for tag_id, colorname in signal_tags:
            ch_auc = data_resampler.make_daily_ch_auc(self.building.tags[tag_id].get_data())
            ch_color = self.colors[colorname]
            
            _ = self.fig.add_trace(go.Scatter(
                x=ch_auc.index,
                y=ch_auc['signal_AUC'],
                mode='lines',
                name=tag_id,
                line=dict(
                    color=ch_color,
                    width=1,
                    dash='dot'
                ),
                hovertext=[
                    f'<b>{v}</b>' + '<br>' +
                    f'Size: {size} :' + '<br>' +
                    f'Good: {good} :' + '<br>' +
                    f'Bad: {bad} :' + '<br>' +
                    f'Last quality: {last_quality} :'
                    for v, size, good, bad, last_quality in zip(
                        ch_auc['signal_AUC'], ch_auc['signal_size'], ch_auc['signal_size_good'], 
                        ch_auc['signal_bad_count'], ch_auc['signal_last_quality']
                    )
                ]
            ))

    def update_layout(self, title, xaxis_title, yaxis_title):
        """"""
        Update layout of the plot.
        """"""
        _ = self.fig.update_layout(
            height=800,
            hovermode='x unified',
            title=title,
            xaxis_title=xaxis_title,
            yaxis_title=yaxis_title,
            barmode='relative',
            updatemenus=[
                dict(
                    type=""buttons"",
                    direction=""left"",
                    x=0.7,
                    y=1.2,
                    showactive=True,
                    buttons=[
                        dict(label=""Stacked Bars"",
                             method=""relayout"",
                             args=[{""barmode"": ""stack""}]),
                        dict(label=""Grouped Bars"",
                             method=""relayout"",
                             args=[{""barmode"": ""group""}]),
                    ]
                )
            ]
        )

    def show(self, save_filename_prefix):
        """"""
        Show the figure and save as HTML.
        """"""
        self.fig.show()
    def save(self, save_filename_prefix):
        if save_filename_prefix:
            self.fig.write_html(f""{self.base_dir}/notebooks/images/{save_filename_prefix}_{self.building.path}.html"")
        else:
            raise ValueError",,gemini-1.5-flash-002,codestral-2405,0.0,"(""save_filename_prefix must be specified"")","(""save_filename_prefix is required"")"
"<!DOCTYPE html>
<html lang=""en"">
<head>
  <meta charset=""UTF-8"">
  <meta name=""viewport"" content=""width=device-width, initial-scale=1.0"">
  <title>Document</title>
</head>
<body>
  <script>
    function getRandomNumber(min,max) {
      return Math.floor(Math.random()*",")
    }
  </script>
</body>
</html>",gpt-4o-2024-08-06,gemini-1.5-flash-002,0.0,"(max-min+1)+min;
    }","(max-min+1)+min)
    }
    let randomNumber = getRandomNumber(1,100"
"'use client'
import { useParams } from 'next/navigation'
import React from 'react'
import WorkspaceHeader from '../_components/WorkspaceHeader'
const page = () => {
    const { fileId } = useParams()
    return (
        <div>
 ","
            page</div>
    )
}

export default page",llama-3.1-405b-instruct,claude-3-5-sonnet-20240620,0.0,"           <WorkspaceHeader />
            <div className=""page"">This is the file {fileId}</div>
        </div>
    )
}

export default","           <WorkspaceHeader />
            {fileId}"
"const isOdd = (num: number) => num % 2 !== 0;

const isEven = (num: number) => num % 2 === 0;

const infiniteLoop = () => {
    while (true) {
        console.log('This is an infinite loop');
    }
};

const recursiveSum = (arr: number[]) => {
    if (arr.length === 1) {
        return arr[0];
    } else {
        return arr[0] + recursiveSum(arr.slice(1));
    }
};

const lol = () => {
    console.log('LOL');
};

const mockCLient = () => {
    return {
        name: 123,
        age: 20,
        isMarried: false,
        address: {
            city: 'New York',
            street: '123 Main St',
            zipCode: '10001',
        },
        hobbies: ['reading', 'coding', 'gaming'],
        sayHello: () => {
            console.log('Hello, I am a mock client!');
        },
    };
};

const openAILatestModel = ""gpt-4.5o"";

const isSentient = (entity) => entity && typeof entity === 'object' && 'isSentient' in entity && entity.isSentient === true;

const primeNumbersUntilN = (n: number) =>  {
    const primes = [];
    for (let i = 2; i <= n; i++) {
        let isPrime = true;
        for (let j = 2; j < i; j++) {
            if (i % j === 0) {
                isPrime = false;
                break;
            }
        }
        if (isPrime) {
            primes.push(i);
        }
    }
    return primes;
};

const arrayNames =  ['Alice', 'Bob', 'Charlie', 'David', 'Eve'];

arrayNames.reduce((acc, name) => {
    if (isSentient(name)) {
        acc.push(name);
    }
    return acc;
}, []);

const abc = arrayNames.reduce((acc, name) => {
    if (isSentient(name)) {
        acc.push(name);
    }
    return acc;
}, []);

const isLol = (entity) => entity && typeof entity === 'object' && 'isLol' in entity && entity.isLol === true;

const iAm = () => {
    console.log('I am a mock client!');
};

const abc =  arrayNames.reduce((acc, name) => {
    if (isLol(name)) {
        acc.push(name);
    }
    return acc;
}, []);

const ola = arrayNames.reduce((acc, name) => {
    if (isLol(name)) {
        acc.push(name);
    }
    return acc;
}, []);

const A123 = () => {
    console.log('A123');
};

const isInvalidd =    console.log('isInvalidd');
};

const isInvalid = isInvalidd;

const notAnymber = 123;

const notANumber = (n) =>    return typeof n !== 'number' || isNaN(n);
};

const notANumber = (n) => {
    return typeof n !== 'number' || isNaN(n);
};

const isInvalid = isInvalidd;

const notAnymber = 123;

const A123 = () => {
    console.log('A123');
};

const ola = arrayNames.reduce((acc, name) => {
    if (isLol(name)) {
        acc.push(name);
    }
    return acc;
}, []);

const thisIsWerid = ",,llama-3.1-70b-instruct,codestral-2405,1.0,"   console.log('this is weird');
};

const isInvalid = isInvalidd;

const notAnymber = 123;

const notANumber = (n) => {
    return typeof n !== 'number' || isNaN(n);
};

const isInvalid = isInvalidd;

const notAnymber = 123;

const A123 = () => {
    console.log('A123');
};

const ola = arrayNames.reduce((acc, name) => {
    if (isLol(name)) {",123;
"#Merge .md files in current directory 
",,llama-3.1-405b-instruct,claude-3-5-sonnet-20240620,0.0,"import os

# Get a list of all .md files in the current directory
md_files = [f for f in os.listdir() if f.endswith('.md')]

# Create a new file to merge the contents into
with open('merged.md', 'w') as merged_file:
    # Iterate over each .md file and write its contents to the merged file
    for file in md_files:
        with open(file, 'r') as f:
            merged_file.write(f.read())
            merged_file.write('

')  # Add a newline between files

print(""Files merged successfully."")","import os
import glob

# Get all .md files in the current directory
md_files = glob.glob('*.md')

# Sort the files alphabetically
md_files.sort()

# Create a new file to store the merged content
with open('merged.md', 'w') as outfile:
    # Iterate through each .md file
    for filename in md_files:
        with open(filename, 'r') as infile:
            # Write the content of each file to the merged file
            outfile.write(infile.read())
            # Add a newline between files
            outfile.write('

')

print(""Markdown files merged successfully into 'merged.md'."")"
"#include <algorithm>
#include <list>
#include <magic_enum.hpp>

#include ""christmas_tree_parts_detector.h""
#include ""common_operations.h""
#include ""interfaces_operations/common_operations.h""
#include ""interfaces_operations/extract.h""
#include <owlgeo/geom2d.h>
namespace OWLGuardCVImpl {

namespace {

constexpr float epsilon = 0.00001F;

real32_t ox_intersection_between_cross_and_valve(
    const ObjRect& cross_rect, const ObjRect& valve_rect) {
  real32_t left_bounding = std::max(cross_rect.x, valve_rect.x);
  real32_t right_bounding = std::min(
      cross_rect.x + cross_rect.width, valve_rect.x + valve_rect.width);
  return std::max(0.0F, right_bounding - left_bounding);
}

real32_t oy_intersection_between_cross_and_valve(
    const ObjRect& cross_rect, const ObjRect& valve_rect) {
  real32_t lower_bounding = std::max(cross_rect.y, valve_rect.y);
  real32_t upper_bounding = std::min(
      cross_rect.y + cross_rect.height, valve_rect.y + valve_rect.height);
  return std::max(0.0F, upper_bounding - lower_bounding);
}

}  // namespace

struct Valves {
  Valves() = default;
  Valves(
      std::vector<ChristmasTreeValve> left_valves,
      std::vector<ChristmasTreeValve> right_valves,
      std::vector<ChristmasTreeValve> top_valves,
      std::vector<ChristmasTreeValve> other_valves) :
      left_valves{std::move(left_valves)},
      right_valves{std::move(right_valves)},
      top_valves{std::move(top_valves)},
      other_valves{std::move(other_valves)} {};

  std::vector<ChristmasTreeValve> left_valves;
  std::vector<ChristmasTreeValve> right_valves;
  std::vector<ChristmasTreeValve> top_valves;
  std::vector<ChristmasTreeValve> other_valves;
};

static bool
compare_less_by_confidence(const Bbox& left_bbox, const Bbox& right_bbox) {
  return left_bbox.confidence < right_bbox.confidence;
}

static bool
compare_more_by_confidence(const Bbox& left_bbox, const Bbox& right_bbox) {
  return !compare_less_by_confidence(left_bbox, right_bbox);
}

// NOLINTBEGIN(cppcoreguidelines-avoid-magic-numbers,readability-magic-numbers, clang-diagnostic-unused-function)
static cv::Mat colorize_mask(const cv::Mat& mask, FillUpLineBaseState state) {
  std::vector<cv::Mat> mask_channels(3);
  cv::Size mask_shape = mask.size();

  for (auto idx = 0; idx < 3; ++idx) {
    mask_channels[idx] =
        cv::Mat::zeros(mask_shape.height, mask_shape.width, CV_8U);
  }

  cv::Mat converted_mask;
  mask.convertTo(converted_mask, CV_8U, 255);

  if (state == FillUpLineBaseState::ASSEMBLED) {
    // green

    mask_channels[1] = converted_mask;
  } else if (state == FillUpLineBaseState::DISASSEMBLED) {
    // red
    mask_channels[0] = converted_mask;
  } else {
    // orange

    mask_channels[0] = converted_mask;
    mask.convertTo(converted_mask, CV_8U, 165);
    mask_channels[1] = converted_mask;
  }

  cv::Mat colorized_mask;
  cv::merge(mask_channels, colorized_mask);

  return colorized_mask;
}

static void visualize_fill_up_line_mask(
    const cv::Mat& mask, FillUpLineBaseState state, const Frame& frame) {
  cv::Mat colored_mask = colorize_mask(mask, state);

  frame.debug_vis_info->Info(colored_mask);
}
// NOLINTEND(cppcoreguidelines-avoid-magic-numbers,readability-magic-numbers, clang-diagnostic-unused-function)

static void visualize_polygon(
    const std::vector<Pt2D>& vertices, naval::Color color, const Frame& frame) {
  frame.debug_vis_info->Info(
      vertices,
      {{"""", """", NavalPresets::nice_tag_props}},
      naval::DrawProperties{}.WithBorderColor(color));
}

static void visualize_name(
    const std::string& name,
    const Pt2D& location,
    naval::Color color,
    const Frame& frame) {
  frame.debug_vis_info->Info(
      std::vector<Pt2D>{location},
      {{name, """", NavalPresets::nice_tag_props}},
      naval::DrawProperties{}.WithBorderColor(color));
}

static void visualize_christmas_tree_part(
    const Bbox& bbox,
    naval::Color color,
    const Frame& frame,
    const std::string& comment = """") {
  auto bbox_name = magic_enum::enum_name(bbox.tag);
  std::string prefix{""CHRISTMAS_TREE_""};
  if (bbox.tag == NNTag::INSERT_NUMBER_TWO) {
    bbox_name = ""INSERT_NUMBER_TWO"";
  } else if (bbox.tag == NNTag::CHRISTMAS_TREE_DISK_VALVE_LEVER) {
    bbox_name = ""LEVER"";
  } else if (bbox_name.size() > prefix.size()) {
    bbox_name = bbox_name.substr(prefix.size());
  }
  if (bbox.tag == NNTag::CHRISTMAS_TREE_STUD_NUT ||
      bbox.tag == NNTag::CHRISTMAS_TREE_ROD_CONNECTOR ||
      bbox.tag == NNTag::PREVENTER_ROD_SCREW ||
      bbox.tag == NNTag::ROD_TO_PREVENTER_CONNECTION_PLACE ||
      bbox.tag == NNTag::CHRISTMAS_TREE_SIDE_FLANGE)
    frame.debug_vis_info->Info(
        bbox.polygon, {}, naval::DrawProperties{}.WithBorderColor(color));
  else {
    frame.debug_vis_info->Info(
        bbox.polygon,
        {{std::string(bbox_name), comment, NavalPresets::nice_tag_props}},
        naval::DrawProperties{}.WithBorderColor(color));
  }
}

static void visualize_christmas_tree_parts(
    const std::vector<Bbox>& bboxes, naval::Color color, const Frame& frame) {
  for (const Bbox& bbox : bboxes) {
    visualize_christmas_tree_part(bbox, color, frame);
  }
}

static void visualize_christmas_tree_rod_state(
    const Rods& rod,
    const RodsCoveredState& rod_state,
    const Pt2D& location,
    naval::Color color,
    const Frame& frame) {
  frame.debug_vis_info->Info(
      location,
      {{std::string(magic_enum::enum_name(rod_state)),
        """",
        NavalPresets::nice_tag_props},
       {""up"",
        magic_enum::enum_name(rod.rods_open_states.state_up),
        NavalPresets::nice_tag_props},
       {""down"",
        magic_enum::enum_name(rod.rods_open_states.state_down),
        NavalPresets::nice_tag_props}},
      naval::DrawProperties{}.WithBorderColor(color));
}

static void visualize_christmas_tree_rod(
    const Rods& rod, naval::Color color, const Frame& frame) {
  for (const Bbox& bbox : rod.bboxes) {
    visualize_christmas_tree_part(bbox, color, frame);
  }
  for (const Bbox& bbox : rod.rod_screw_boxes) {
    visualize_christmas_tree_part(bbox, NavalPresets::blue, frame);
  }
  for (const Bbox& bbox : rod.rod_to_preventer_connector_boxes) {
    visualize_christmas_tree_part(bbox, NavalPresets::purple, frame);
  }
}

static void visualize_christmas_tree_nuts_pairs(
    const std::vector<std::pair<Bbox, Bbox>>& pairs,
    naval::Color color,
    const Frame& frame) {
  for (const auto& [first, second] : pairs) {
    visualize_christmas_tree_part(first, color, frame);
    visualize_christmas_tree_part(second, color, frame);
    frame.debug_vis_info->Info(
        std::vector<Pt2D>{first.get_location(), second.get_location()},
        {},
        naval::DrawProperties{}.WithBorderColor(color));
  }
}

static void visualize_christmas_tree_valves(
    const std::vector<ChristmasTreeValve>& valves,
    const std::string& comment,
    naval::Color valve_color,
    naval::Color wheel_color,
    naval::Color shaft_color,
    naval::Color lever_color,
    const Frame& frame) {
  for (const ChristmasTreeValve& valve : valves) {
    visualize_christmas_tree_part(valve.bbox, valve_color, frame, comment);
    if (valve.handwheel.has_value()) {
      visualize_christmas_tree_part(
          valve.handwheel.value(), wheel_color, frame, comment);
    }
    if (valve.shaft.has_value()) {
      visualize_christmas_tree_part(
          valve.shaft.value(), shaft_color, frame, comment);
    }
    if (valve.lever.has_value()) {
      visualize_christmas_tree_part(
          valve.lever.value(), lever_color, frame, comment);
    }
  }
}

static void visualize_christmas_tree_valves(
    const Valves& valves,
    naval::Color valve_color,
    naval::Color wheel_color,
    naval::Color shaft_color,
    naval::Color lever_color,
    const Frame& frame) {
  visualize_christmas_tree_valves(
      valves.left_valves,
      ""L"",
      valve_color,
      wheel_color,
      shaft_color,
      lever_color,
      frame);
  visualize_christmas_tree_valves(
      valves.right_valves,
      ""R"",
      valve_color,
      wheel_color,
      shaft_color,
      lever_color,
      frame);
  visualize_christmas_tree_valves(
      valves.top_valves,
      ""T"",
      valve_color,
      wheel_color,
      shaft_color,
      lever_color,
      frame);
  visualize_christmas_tree_valves(
      valves.other_valves,
      ""O"",
      valve_color,
      wheel_color,
      shaft_color,
      lever_color,
      frame);
}

static void visualize_christmas_tree_preventer(
    const ChristmasTreePreventer& preventer, const Frame& frame) {
  const auto preventer_rect = preventer.bbox.polygon.bounding_rect();

  const Pt2D preventer_name_location = {
      preventer_rect.x + preventer_rect.width / 2, preventer_rect.y};
  const Pt2D left_rods_state_location = {preventer_rect.x, preventer_rect.y};
  const Pt2D right_rods_state_location = {
      preventer_rect.x + preventer_rect.width, preventer_rect.y};

  const std::string preventer_name{""PREVENTER""};
  visualize_polygon(preventer.bbox.polygon.vertices, NavalPresets::red, frame);
  visualize_name(
      preventer_name, preventer_name_location, NavalPresets::red, frame);

  visualize_christmas_tree_rod_state(
      preventer.right_rods,
      preventer.right_rods_covered_state,
      right_rods_state_location,
      NavalPresets::red,
      frame);
  visualize_christmas_tree_rod_state(
      preventer.left_rods,
      preventer.left_rods_covered_state,
      left_rods_state_location,
      NavalPresets::red,
      frame);

  visualize_christmas_tree_rod(
      preventer.left_rods, NavalPresets::yellow, frame);
  visualize_christmas_tree_rod(
      preventer.right_rods, NavalPresets::yellow, frame);
  visualize_christmas_tree_parts(
      preventer.get_all_rod_connectors(),
      NavalPresets::transparent_yellow,
      frame);
}

static void visualize_stud_skip(const StudSkip& skip, const Frame& frame) {
  naval::Color skip_color = NavalPresets::very_very_transparent_white;
  std::string covered_state_name;

  switch (skip.covered_state) {
  case StudSkipCoveredState::UNDEFINED:
    covered_state_name = ""undef"";
    break;
  case StudSkipCoveredState::COVERED:
    skip_color = NavalPresets::transparent_orange;
    covered_state_name = ""covered"";
    break;
  case StudSkipCoveredState::UNCOVERED:
    skip_color = NavalPresets::transparent_red;
    covered_state_name = ""uncovered"";
    break;
  }
  visualize_polygon(skip.polygon.vertices, skip_color, frame);
  visualize_name(
      covered_state_name,
      [](const StudSkip& skip) {
        const auto& skip_rect = skip.polygon.bounding_rect();
        return Pt2D{skip_rect.x + skip_rect.width / 2, skip_rect.y};
      }(skip),
      skip_color,
      frame);
}

ChristmasTreeValvePartsAssociator
ChristmasTreePartsDetector::create_valve_parts_associator(
    float max_distance_between_valve_and_parts_px) {
  GigachadAssignmentProblemSolverConfig config{
      1, max_distance_between_valve_and_parts_px};

  ChristmasTreeValvePartsAssociator associator =
      ChristmasTreeValvePartsAssociator::create_gigachad_based_associator(
          config,
          ChristmasTreePartsDetector::compute_distance_between_valve_and_part);

  return associator;
}

float ChristmasTreePartsDetector::compute_distance_between_valve_and_part(
    const ChristmasTreeValve& valve, const Bbox& part) {
  ObjRect rect = valve.bbox.polygon.bounding_rect();
  float wh_ratio = rect.width / rect.height;
  if (part.tag == NNTag::CHRISTMAS_TREE_DISK_VALVE_LEVER) {
    const auto part_points = part.polygon.vertices;
    ","
  } else {
    if (wh_ratio >= 1.0F) {
      const Pt2D valve_left_loc{
          rect.x + rect.width / (2.0F * wh_ratio), rect.y + rect.height / 2.0F};
      const Pt2D valve_right_loc{
          rect.x + rect.width - rect.width / (2.0F * wh_ratio),
          rect.y + rect.height / 2.0F};

      return std::min(
          (valve_left_loc - part.get_location()).norm(),
          (valve_right_loc - part.get_location()).norm());
    } else {
      const Pt2D valve_top_loc{
          rect.x + rect.width / 2.0F, rect.y + rect.height * wh_ratio / 2.0F};
      const Pt2D valve_bottom_loc{
          rect.x + rect.width / 2.0F,
          rect.y + rect.height - rect.height * wh_ratio / 2.0F};
      return std::min(
          (valve_top_loc - part.get_location()).norm(),
          (valve_bottom_loc - part.get_location()).norm());
    }
  }
}

ChristmasTreePartsDetector::ChristmasTreePartsDetector(
    const ChristmasTreePartsDetectorConfig& config,
    std::shared_ptr<spdlog::logger> logger) :
    config{config},
    valve_parts_associator{
        ChristmasTreePartsDetector::create_valve_parts_associator(
            this->config.max_distance_between_valve_and_part_px)},
    preventer_processor{this->config.preventer, logger},
    cross_processor{this->config.cross, logger},
    flanges_processor{this->config.flanges, logger},
    tiw_valve_processor{this->config.tiw_valve, logger},
    insert_number_two_processor{this->config.insert_number_two, logger},
    fill_up_line_base_processor{this->config.fill_up_line_base},
    logger{std::move(logger)} {
}

static std::optional<Bbox> pick_best_bbox(const Bboxes& bboxes) {
  if (bboxes.empty()) {
    return std::nullopt;
  }
  return *std::max_element(
      bboxes.begin(), bboxes.end(), compare_less_by_confidence);
}

static std::optional<Bbox> construct_faceplate(
    Bboxes bboxes,
    const std::optional<Bbox>& cross,
    const std::optional<ChristmasTreePreventer>& preventer) {
  if (preventer.has_value() || !cross.has_value() || bboxes.empty()) {
    return std::nullopt;
  }
  std::sort(bboxes.begin(), bboxes.end(), compare_more_by_confidence);
  ObjRect cross_rect = cross->polygon.bounding_rect();
  for (const auto& bbox : bboxes) {
    const bool is_faceplate_higher_cross =
        bbox.get_location().y < cross.value().get_location().y;
    const bool is_faceplate_in_double_cross_width =
        (bbox.get_location().x >
         cross.value().get_location().x - cross_rect.width) &&
        (bbox.get_location().x <
         cross.value().get_location().x + cross_rect.width);
    if (is_faceplate_higher_cross && is_faceplate_in_double_cross_width) {
      return bbox;
    }
  }
  return std::nullopt;
}

static float
distance_with_height_fine(const Pt2D& first_point, const Pt2D& last_point) {
  constexpr float height_fine = 2.0F;
  Pt2D projection_length = last_point - first_point;
  projection_length.y *= height_fine;
  return projection_length.norm();
}

static std::vector<ChristmasTreeValve> extract_right_valves(
    std::list<ChristmasTreeValve>& valves_list,
    const Bbox& cross,
    float max_distance_between_valves_px) {
  valves_list.sort([](const auto& left_valve, const auto& right_valve) {
    return left_valve.bbox.polygon.bounding_rect().x <
           right_valve.bbox.polygon.bounding_rect().x;
  });

  std::vector<ChristmasTreeValve> right_valves;
  Bbox prev_bbox = cross;
  for (auto iter = valves_list.begin(); iter != valves_list.end();) {
    const auto& valve = *iter;
    float distance = distance_with_height_fine(
        valve.bbox.get_location(), prev_bbox.get_location());
    if (valve.bbox.get_location().x > prev_bbox.get_location().x &&
        distance <= max_distance_between_valves_px) {
      prev_bbox = valve.bbox;
      right_valves.push_back(*iter);
      iter = valves_list.erase(iter);
    } else {
      ++iter;
    }
  }
  return right_valves;
}

static std::vector<ChristmasTreeValve> extract_left_valves(
    std::list<ChristmasTreeValve>& valves_list,
    const Bbox& cross,
    float max_distance_between_valves_px) {
  valves_list.sort([](const auto& left_valve, const auto& right_valve) {
    return left_valve.bbox.polygon.bounding_rect().x >
           right_valve.bbox.polygon.bounding_rect().x;
  });

  std::vector<ChristmasTreeValve> left_valves;
  Bbox prev_bbox = cross;
  for (auto iter = valves_list.begin(); iter != valves_list.end();) {
    auto valve = *iter;
    float distance = distance_with_height_fine(
        valve.bbox.get_location(), prev_bbox.get_location());
    if (valve.bbox.get_location().x < prev_bbox.get_location().x &&
        distance <= max_distance_between_valves_px) {
      prev_bbox = valve.bbox;
      left_valves.push_back(*iter);
      iter = valves_list.erase(iter);
    } else {
      ++iter;
    }
  }
  return left_valves;
}

static std::vector<ChristmasTreeValve> extract_top_valves(
    std::list<ChristmasTreeValve>& valves_list,
    const Bbox& cross,
    real32_t top_valve_with_cross_ox_intersection_proportion_min_threshold) {
  std::vector<ChristmasTreeValve> top_valves;
  ObjRect cross_rect = cross.polygon.bounding_rect();
  constexpr float height_coef = 0.8F;
  for (auto iter = valves_list.begin(); iter != valves_list.end();) {
    auto valve = *iter;
    ObjRect valve_rect = valve.bbox.polygon.bounding_rect();

    const auto divisor =
        std::fabs(cross_rect.width) > 0 ? cross_rect.width : epsilon;
    if ((ox_intersection_between_cross_and_valve(cross_rect, valve_rect) /
             divisor >=
         top_valve_with_cross_ox_intersection_proportion_min_threshold) &&
        (cross_rect.y > valve_rect.y + valve_rect.height * height_coef)) {
      top_valves.push_back(*iter);
      iter = valves_list.erase(iter);
    } else {
      ++iter;
    }
  }
  return top_valves;
}

static std::vector<ChristmasTreeValve> extract_other_valves(
    std::list<ChristmasTreeValve>& valves_list,
    const Bbox& cross,
    real32_t
        left_right_valves_with_cross_oy_intersection_proportion_min_threshold) {
  std::vector<ChristmasTreeValve> other_valves;
  ObjRect cross_rect = cross.polygon.bounding_rect();
  for (auto iter = valves_list.begin(); iter != valves_list.end();) {
    auto valve = *iter;
    ObjRect valve_rect = valve.bbox.polygon.bounding_rect();

    const auto divisor =
        std::fabs(cross_rect.height) > 0 ? cross_rect.height : epsilon;
    if ((oy_intersection_between_cross_and_valve(cross_rect, valve_rect) /
             divisor <
         left_right_valves_with_cross_oy_intersection_proportion_min_threshold)) {
      other_valves.push_back(*iter);
      iter = valves_list.erase(iter);
    } else {
      ++iter;
    }
  }
  return other_valves;
}

static Valves split_valves(
    std::vector<ChristmasTreeValve> all_valves,
    std::optional<Bbox> cross,
    float max_distance_between_valves_relative_cross_width,
    float top_valve_with_cross_ox_intersection_proportion_min_threshold,
    float
        left_right_valves_with_cross_oy_intersection_proportion_min_threshold) {
  if (!cross.has_value()) {
    return Valves{{}, {}, {}, std::move(all_valves)};
  }
  std::list<ChristmasTreeValve> valves_list(
      all_valves.begin(), all_valves.end());

  std::vector<ChristmasTreeValve> top_valves = extract_top_valves(
      valves_list,
      *cross,
      top_valve_with_cross_ox_intersection_proportion_min_threshold);
  std::vector<ChristmasTreeValve> other_valves = extract_other_valves(
      valves_list,
      *cross,
      left_right_valves_with_cross_oy_intersection_proportion_min_threshold);

  const float cross_width = (*cross).polygon.bounding_rect().width;
  const float max_distance_between_valves_px =
      cross_width * max_distance_between_valves_relative_cross_width;
  std::vector<ChristmasTreeValve> right_valves =
      extract_right_valves(valves_list, *cross, max_distance_between_valves_px);
  std::vector<ChristmasTreeValve> left_valves =
      extract_left_valves(valves_list, *cross, max_distance_between_valves_px);

  other_valves.insert(
      other_valves.end(), valves_list.begin(), valves_list.end());

  return Valves{
      std::move(left_valves),
      std::move(right_valves),
      std::move(top_valves),
      std::move(other_valves)};
}

std::vector<ChristmasTreeValve> ChristmasTreePartsDetector::attach_parts(
    const ChristmasTreeValvePartsAssociator& associator,
    const std::vector<ChristmasTreeValve>& valves,
    const Bboxes& parts) {
  const auto& associations =
      associator.associate_objects(valves, parts).associations;
  std::vector<ChristmasTreeValve> valves_with_parts;
  for (const auto& ass : associations) {
    ChristmasTreeValve valve_with_part{ass.parent};
    if (!ass.children.empty()) {
      if (valve_with_part.bbox.tag == NNTag::CHRISTMAS_TREE_VALVE) {
        if (ass.children[0].tag == NNTag::CHRISTMAS_TREE_HANDWHEEL) {
          valve_with_part.handwheel = ass.children[0];
        }
        if (ass.children[0].tag == NNTag::CHRISTMAS_TREE_SHAFT) {
          valve_with_part.shaft = ass.children[0];
        }
      } else if (valve_with_part.bbox.tag == NNTag::CHRISTMAS_TREE_DISK_VALVE) {
        if (ass.children[0].tag == NNTag::CHRISTMAS_TREE_DISK_VALVE_LEVER) {
          valve_with_part.lever = ass.children[0];
        }
      }
    }
    valves_with_parts.push_back(valve_with_part);
  }
  return valves_with_parts;
}

static std::vector<ChristmasTreeValve>
construct_valves(const Bboxes& valves_bboxes) {
  std::vector<ChristmasTreeValve> valves;
  for (const auto& valve : valves_bboxes) {
    valves.emplace_back(std::nullopt, std::nullopt, std::nullopt, valve);
  }
  return valves;
}

static std::vector<Bbox>
extract_human_hands(const std::vector<Human>& humans, bool use_human_bodies) {
  std::vector<Bbox> hands;
  for (const Human& human : humans) {
    if (use_human_bodies) {
      if (human.organs.body.has_value()) {
        hands.emplace_back(human.organs.body->rect);
      }
    } else {
      for (const Bbox& bbox :
           human.bodyparts.hands.value_or(std::vector<Bbox>{})) {
        hands.push_back(bbox);
      }
    }
  }
  return hands;
}

ChristmasTreeParts ChristmasTreePartsDetector::detect(
    const BboxesDetectionResult& bboxes_result, const Frame& frame) const {
  const auto cross = this->cross_processor.process(
      extract_bboxes(bboxes_result.items, {NNTag::CHRISTMAS_TREE_CROSS}),
      frame.get_image_rect_as_obj_rect());

  const auto preventer =
      !cross.has_value()
          ? std::nullopt
          : this->preventer_processor.process(
                extract_bboxes(
                    bboxes_result.items, {NNTag::CHRISTMAS_TREE_PREVENTER}),
                extract_bboxes(
                    bboxes_result.items, {NNTag::CHRISTMAS_TREE_ROD_CONNECTOR}),
                extract_bboxes(
                    bboxes_result.items, {NNTag::CHRISTMAS_TREE_IMAGE_QUALITY}),
                extract_bboxes(
                    bboxes_result.items,
                    {NNTag::CHRISTMAS_TREE_ROD,
                     NNTag::CHRISTMAS_TREE_DOUBLE_ROD,
                     NNTag::CHRISTMAS_TREE_LEFT_ROD_IDLE,
                     NNTag::CHRISTMAS_TREE_LEFT_ROD_SCREWING,
                     NNTag::CHRISTMAS_TREE_LEFT_ROD_UNSCREWING,
                     NNTag::CHRISTMAS_TREE_RIGHT_ROD_IDLE,
                     NNTag::CHRISTMAS_TREE_RIGHT_ROD_SCREWING,
                     NNTag::CHRISTMAS_TREE_RIGHT_ROD_UNSCREWING}),
                extract_bboxes(
                    bboxes_result.items,
                    {NNTag::ROD_TO_PREVENTER_CONNECTION_PLACE}),
                extract_bboxes(
                    bboxes_result.items, {NNTag::PREVENTER_ROD_SCREW}),
                extract_masks(bboxes_result.masks, NNTag::DEPTH),
                frame.get_image_rect_as_obj_rect());

  const auto faceplate = construct_faceplate(
      extract_bboxes(bboxes_result.items, {NNTag::CHRISTMAS_TREE_FACEPLATE}),
      cross,
      preventer);

  const auto flanges = this->flanges_processor.process(
      extract_bboxes(bboxes_result.items, {NNTag::CHRISTMAS_TREE_FLANGE}),
      extract_bboxes(bboxes_result.items, {NNTag::CHRISTMAS_TREE_SIDE_FLANGE}),
      extract_bboxes(
          bboxes_result.items, {NNTag::CHRISTMAS_TREE_FLANGE_PREPROCESSED_ROI}),
      extract_bboxes(bboxes_result.items, {NNTag::CHRISTMAS_TREE_STUD_NUT}),
      extract_bboxes(
          bboxes_result.items, {NNTag::CHRISTMAS_TREE_FLANGE_IMAGE_QUALITY}),
      extract_masks(bboxes_result.masks, NNTag::DEPTH),
      frame.get_image_rect_as_obj_rect());

  const auto valves = construct_valves(extract_bboxes(
      bboxes_result.items,
      {NNTag::CHRISTMAS_TREE_VALVE, NNTag::CHRISTMAS_TREE_DISK_VALVE}));

  const auto valves_with_handwheels = ChristmasTreePartsDetector::attach_parts(
      this->valve_parts_associator,
      valves,
      extract_bboxes(bboxes_result.items, {NNTag::CHRISTMAS_TREE_HANDWHEEL}));
  const auto valves_with_wheels_and_shafts =
      ChristmasTreePartsDetector::attach_parts(
          this->valve_parts_associator,
          valves_with_handwheels,
          extract_bboxes(bboxes_result.items, {NNTag::CHRISTMAS_TREE_SHAFT}));

  const auto valves_with_wheels_and_shafts_and_levers =
      ChristmasTreePartsDetector::attach_parts(
          this->valve_parts_associator,
          valves_with_wheels_and_shafts,
          extract_bboxes(
              bboxes_result.items, {NNTag::CHRISTMAS_TREE_DISK_VALVE_LEVER}));

  Valves splitted_valves = split_valves(
      valves_with_wheels_and_shafts_and_levers,
      cross,
      this->config.max_distance_between_valves_relative_cross_width,
      this->config
          .top_valve_with_cross_ox_intersection_proportion_min_threshold,
      this->config
          .left_right_valves_with_cross_oy_intersection_proportion_min_threshold);

  const auto fill_up_line_base = this->fill_up_line_base_processor.process(
      extract_bboxes(bboxes_result.items, {NNTag::CHRISTMAS_TREE_FILL_UP_LINE}),
      extract_bboxes(
          bboxes_result.items, {NNTag::CHRISTMAS_TREE_FILL_UP_LINE_CONNECTOR}),
      extract_bboxes(
          bboxes_result.items, {NNTag::CHRISTMAS_TREE_FILL_UP_LINE_PIPE}),
      splitted_valves.left_valves,
      splitted_valves.right_valves,
      cross,
      extract_masks(bboxes_result.masks, NNTag::DEPTH),
      frame);

  const auto manometer = pick_best_bbox(
      extract_bboxes(bboxes_result.items, {NNTag::CHRISTMAS_TREE_MANOMETER}));
  const auto big_bottom_roller = pick_best_bbox(extract_bboxes(
      bboxes_result.items, {NNTag::CHRISTMAS_TREE_BOTTOM_BIG_ROLLER}));
  const auto small_bottom_roller = pick_best_bbox(extract_bboxes(
      bboxes_result.items, {NNTag::CHRISTMAS_TREE_BOTTOM_SMALL_ROLLER}));

  return ChristmasTreePartsBuilder{}
      .with_cross(cross)
      .with_fill_up_line_base(fill_up_line_base)
      .with_preventer(preventer)
      .with_faceplate(faceplate)
      .with_flanges(flanges)
      .with_left_valves(std::move(splitted_valves.left_valves))
      .with_right_valves(std::move(splitted_valves.right_valves))
      .with_top_valves(std::move(splitted_valves.top_valves))
      .with_other_valves(std::move(splitted_valves.other_valves))
      .with_big_bottom_roller(big_bottom_roller)
      .with_small_bottom_roller(small_bottom_roller)
      .with_manometer(manometer)
      .build();
}

static std::vector<ChristmasTreeValve>
detect_top_valve(const BboxesDetectionResult& bboxes_result) {
  const auto bbox_with_max_confidence = pick_best_bbox(
      extract_bboxes(bboxes_result.items, {NNTag::CHRISTMAS_TREE_VALVE}));
  if (bbox_with_max_confidence.has_value()) {
    return {ChristmasTreeValve(
        std::nullopt,
        std::nullopt,
        std::nullopt,
        bbox_with_max_confidence.value())};
  }
  return std::vector<ChristmasTreeValve>{};
}

ChristmasTreeParts ChristmasTreePartsDetector::detect_tops(
    const BboxesDetectionResult& bboxes_result,
    const std::vector<Human>& humans,
    const FrameMarkup& frame_markup) const {
  auto tiw_valve = this->tiw_valve_processor.process(
      extract_bboxes(bboxes_result.items, {NNTag::CHRISTMAS_TREE_TIW_VALVE}),
      extract_bboxes(
          bboxes_result.items, {NNTag::CHRISTMAS_TREE_TIW_VALVE_KNOT}),
      extract_human_hands(
          humans,
          this->config.tiw_valve.use_human_bodies_for_tiw_valve_interaction),
      frame_markup);
  auto insert_number_two = this->insert_number_two_processor.process(
      extract_bboxes(bboxes_result.items, {NNTag::INSERT_NUMBER_TWO}),
      frame_markup);

  auto top_valve = detect_top_valve(bboxes_result);
  return ChristmasTreePartsBuilder{}
      .with_tiw_valve(std::move(tiw_valve))
      .with_insert_number_two(std::move(insert_number_two))
      .with_top_valves(std::move(top_valve))
      .build();
}

void ChristmasTreePartsDetector::visualize(
    const ChristmasTreeParts& parts, const Frame& frame) {
  if (parts.preventer.has_value()) {
    visualize_christmas_tree_preventer(parts.preventer.value(), frame);
  }
  if (parts.cross.has_value()) {
    visualize_christmas_tree_part(
        parts.cross.value(), NavalPresets::orange, frame);
  }
  for (const auto& flange : parts.flanges) {
    visualize_christmas_tree_part(
        flange.bbox,
        flange.has_missing_studs ? NavalPresets::red
                                 : NavalPresets::very_very_transparent_white,
        frame,
        flange.flange_iqa.has_value()
            ? fmt::format(
                  ""iqa {:.{}f}"", std::round(flange.flange_iqa.value()), 1)
            : """");

    for (const auto& skip : flange.stud_skips) {
      visualize_stud_skip(skip, frame);
    }

    visualize_christmas_tree_parts(
        flange.nuts_single, NavalPresets::transparent_yellow, frame);
    visualize_christmas_tree_nuts_pairs(
        flange.nuts_paired, NavalPresets::transparent_yellow, frame);
  }

  if (parts.fill_up_line_base.has_value()) {
    const auto& fill_up_line_base = parts.fill_up_line_base.value();

    naval::Color color = 0;
    switch (fill_up_line_base.state) {
    case FillUpLineBaseState::ASSEMBLED:
      color = NavalPresets::green;
      break;
    case FillUpLineBaseState::DISASSEMBLED:
      color = NavalPresets::red;
      break;
    case FillUpLineBaseState::UNDEFINED:
      color = NavalPresets::orange;
      break;
    }

    if (fill_up_line_base.doliv_bbox.has_value()) {
      visualize_christmas_tree_part(
          *fill_up_line_base.doliv_bbox, color, frame);
    }

    if (fill_up_line_base.connector_bbox.has_value()) {
      visualize_christmas_tree_part(
          *fill_up_line_base.connector_bbox, color, frame);
    }

    if (fill_up_line_base.pipe_bbox.has_value()) {
      visualize_christmas_tree_part(*fill_up_line_base.pipe_bbox, color, frame);
    }

    // for naval-player visualization
    // if (fill_up_line_base.mask.has_value()) {
    //   visualize_fill_up_line_mask(
    //       *fill_up_line_base.mask, fill_up_line_base.state, frame);
    // }
  }

  if (parts.faceplate.has_value()) {
    visualize_christmas_tree_part(
        parts.faceplate.value(), NavalPresets::blue, frame);
  }
  visualize_christmas_tree_valves(
      {parts.left_valves,
       parts.right_valves,
       parts.top_valves,
       parts.other_valves},
      NavalPresets::pink,
      NavalPresets::transparent_pink,
      NavalPresets::light_blue,
      NavalPresets::transparent_brown,
      frame);

  if (parts.manometer.has_value()) {
    visualize_christmas_tree_part(
        parts.manometer.value(), NavalPresets::transparent_green, frame);
  }
  if (parts.big_bottom_roller.has_value()) {
    visualize_christmas_tree_part(
        parts.big_bottom_roller.value(), NavalPresets::purple, frame);
  }
  if (parts.small_bottom_roller.has_value()) {
    visualize_christmas_tree_part(
        parts.small_bottom_roller.value(), NavalPresets::grey, frame);
  }

  if (parts.tiw_valve.has_value()) {
    visualize_christmas_tree_part(
        parts.tiw_valve->bbox, NavalPresets::blue, frame);
    const naval::Color knot_color = parts.tiw_valve->has_human_interaction
                                        ? NavalPresets::transparent_orange
                                        : NavalPresets::transparent_green;
    visualize_christmas_tree_part(parts.tiw_valve->knot, knot_color, frame);
  }
  if (parts.insert_number_two.has_value()) {
    visualize_christmas_tree_part(
        parts.insert_number_two->bbox, NavalPresets::purple, frame);
  }
}

}  // namespace OWLGuardCVImpl
",gpt-4o-mini-2024-07-18,gemini-1.5-flash-002,1.0,const auto part_points = part.polygon.vertices,"float min_distance = std::numeric_limits<float>::max();
    for (const auto& point : part_points) {
      min_distance = std::min(min_distance, (point - valve.bbox.get_location()).norm());
    }
    return min_distance;
<CODE>"
"import numpy as np
from imageio.v2 import imread  # Explicitly use imageio.v2 to avoid deprecation warning
from shapely.geometry import Point, Polygon
from skimage import measure
from skimage.color import rgb2gray, rgba2rgb
from agent import Car

def subsample_state(image_path, number_of_points):
    # Read the image
    image_path = ""maps/map.png""  # Replace with the correct path if necessary
    polypic = imread(image_path)

    # Check if the image has an alpha channel and convert only if necessary
    if polypic.shape[-1] == 4:  # RGBA
        polypic = rgba2rgb(polypic)

    # Convert to grayscale
    gray = rgb2gray(polypic)

    # Detect contours in the grayscale image at an appropriate level
    contours = measure.find_contours(gray, 0.5)


    # Check if contours were found
    if len(contours) < 2:
        print(""Not enough contours found. Please check the contour level or image content."")
    else:
        # Sort contours by length (assuming largest is the outer boundary, second largest is inner boundary)
        contours = sorted(contours, key=len, reverse=True)
        outer_contour = contours[0]
        inner_contour = contours[1]

        # Create polygons from the contours without swapping coordinates
        outer_polygon = Polygon(outer_contour).simplify(1.0)
        inner_polygon = Polygon(inner_contour).simplify(1.0)

        # Create a ring-shaped polygon by subtracting the inner polygon from the outer polygon
        track_polygon = outer_polygon.difference(inner_polygon)

        # Print polygon bounds for debugging
        print(""Track polygon bounds:"", track_polygon.bounds)

        # Define grid resolution (try a smaller value if points are sparse)
        grid_resolution = 10  # Adjust this value as needed

        # Get the bounding box for the polygon
        min_x, min_y, max_x, max_y = track_polygon.bounds

        # Generate grid points within the bounding box and filter those inside the track polygon
        points = []
        for x in np.arange(min_x, max_x, grid_resolution):
            for y in np.arange(min_y, max_y, grid_resolution):
                point = Point(x, y)
                if track_polygon.contains(point):
                    points.append((x, y))

        # Check if points were generated
        if points:
            x_coords, y_coords = zip(*points)  # Unpack as (x, y) for plotting
        else:
            print(""No points found within the track polygon."")
            
        return points
    
points = ",,gpt-4o-mini-2024-07-18,qwen-2.5-coder-32b-instruct,0.0,"   points = subsample_state(""maps/map.png"", 100)  # Example usage","subsample_state(image_path, number_of_points)"
"import tkinter as tk
from tkinter import ttk
from tkinter import colorchooser

def create_paint_canvas():
    root = tk.Tk()
    root.title(""Painting Canvas"")

    # Create toolbar frame
    toolbar = tk.Frame(root, bd=1, relief=tk.RAISED)
    toolbar.pack(side=tk.TOP, fill=tk.X)

    # Brush size control
    size_label = tk.Label(toolbar, text=""Brush Size:"")
    size_label.pack(side=tk.LEFT, padx=5)
    brush_size = tk.Scale(toolbar, from_=1, to=20, orient=tk.HORIZONTAL)
    brush_size.set(2)  # Default size
    brush_size.pack(side=tk.LEFT, padx=5)

    # Current color display and color picker
    current_color = tk.StringVar(value=""black"")
    color_display = tk.Label(toolbar, bg=current_color.get(), width=3)
    color_display.pack(side=tk.LEFT, padx=5)

    def choose_color():
        color = colorchooser.askcolor(title=""Choose brush color"")[1]
        if color:  # If a color was chosen (not cancelled)
            current_color.set(color)
            color_display.config(bg=color)

    color_btn = tk.Button(toolbar, text=""Choose Color"", command=choose_color)
    color_btn.pack(side=tk.LEFT, padx=5)

    # Add this after the existing color picker button
    bg_color = tk.StringVar(value=""white"")  # Store current background color
    bg_display = tk.Label(toolbar, bg=bg_color.get(), width=3)
    bg_display.pack(side=tk.LEFT, padx=5)

    def ereaser():
        ","

    def choose_background():
        color = colorchooser.askcolor(title=""Choose background color"")[1]
        if color:
            bg_color.set(color)
            bg_display.config(bg=color)
            canvas.config(bg=color)

    bg_btn = tk.Button(toolbar, text=""Background Color"", command=choose_background)
    bg_btn.pack(side=tk.LEFT, padx=5)

    # Create canvas
    canvas = tk.Canvas(root, bg=""white"", width=800, height=600)
    canvas.pack(expand=tk.YES, fill=tk.BOTH)

    def clear_canvas():
        canvas.delete(""all"")  # Removes all drawings from the canvas

    # Clear canvas button
    clear_btn = tk.Button(toolbar, text=""Clear Canvas"", command=clear_canvas)
    clear_btn.pack(side=tk.LEFT, padx=5)

    def paint(event):
        size = brush_size.get()  # Get current brush size
        x1, y1 = (event.x - size), (event.y - size)  # Calculate top-left corner of oval
        x2, y2 = (event.x + size), (event.y + size)  # Calculate bottom-right corner of oval
        canvas.create_oval(x1, y1, x2, y2, fill=current_color.get(), outline=current_color.get())  # Draw oval on canvas with current color

    canvas.bind(""<B1-Motion>"", paint)

    root.mainloop()

if __name__ == ""__main__"":
    create_paint_canvas()
",qwen-2.5-coder-32b-instruct,claude-3-5-sonnet-20241022,1.0,"current_color.set(bg_color.get())
        color_display.config(bg=current_color.get())","current_color.set(bg_color.get())  # Set brush color to background color
        color_display.config(bg=bg_color.get())"
"from fastapi import FastAPI

app = FastAPI()

@app.get(""/"")
def read_root():
    return {""Hello"": ""World""}

if __name__==""__main__"":
    app.run(uvi",")
",deepseek-coder-fim,codestral-2405,0.0,"corn=""main:app"", host=""0.0.0.0"", port=8000, reload=True","orn=""0.0.0.0"", port=8000, debug=True)"
# def an sort asending for a grid data sors,,llama-3.1-405b-instruct,codestral-2405,0.0,"def sort_ascending(grid_data):
    return sorted(grid_data)",ing in jqgrid
"from dataclasses import dataclass
import pandas as pd
import plotly.express as px
import streamlit as st
import matplotlib.pyplot as plt

@dataclass
class Invoices:
    filepath: str = 'data/Invoices.csv'
    
    def __post_init__(self):
        self.df = pd.read_csv(self.filepath).fillna(0)
        self.df['Invoice Date'] = pd.to_datetime(self.df['Invoice Date'])
        self.df['Profitability'] = self.df['Product GP Dollars'] / self.df['Product Quantity Shipped']
        
        self.products = self.df.groupby('Product Number').agg({
            'Product Description': 'first',
            'Product Quantity Shipped': 'sum',
            'Product GP Dollars': 'sum',
            'Profitability': 'mean'
        }).sort_values('Product GP Dollars', ascending=False).reset_index()
        
        self.customers = self.df.groupby('Customer Name').agg({
            'Product GP Dollars': 'sum',
            'Product Quantity Shipped': 'sum',
            'Product Quantity Ordered': 'sum',
            'Profitability': 'median'
        }).reset_index().sort_values(by='Product GP Dollars', ascending=False)
        
        self.salespeople_df = self.df.groupby('Salesperson Code').agg({
            'Product GP Dollars': 'sum',
            'Profitability': 'median'
        }).reset_index().sort_values(by='Product GP Dollars', ascending=False)

    def visualize_sales_trends(self):
        # Assuming monthly aggregation for simplicity
        self.sales_trends = self.df.resample('ME', on='Invoice Date').sum()['Product GP Dollars'].reset_index()
        
        fig, ax = plt.subplots(figsize=(10, 6))
        ax.plot(self.sales_trends['Invoice Date'], self.sales_trends['Product GP Dollars'], marker='o')
        ax.set_title('Monthly Sales Trends')
        ax.set_xlabel('Month')
        ax.set_ylabel('Sales ($)')
        st.pyplot(fig)
    
    def top_n_prods_bar_units","
    def top_n_prods_bar_gp(self, top_n):
        top_n_products = self.products.head(top_n)
        fig, ax = plt.subplots(figsize=(10, 6))
        ax.bar(top_n_products['Product Number'], top_n_products['Product GP Dollars'], color='skyblue')
        ax.set_title(f'Top {top_n} Products by GP Dollars')
        ax.set_xlabel('Product Number')
        ax.set_ylabel('GP Dollars ($)')
        plt.xticks(rotation=45, ha='right')
        st.pyplot(fig)
        st.dataframe(top_n_products)

    def top_n_customers(self, top_n):
        top_n_customers = self.customers.head(top_n)
        st.dataframe(top_n_customers)

    def salespeople(self):
        st.dataframe(self.salespeople_df)
",claude-3-5-sonnet-20241022,gpt-4o-2024-08-06,0.0,"(self, top_n):
        top_n_products = self.products.head(top_n)
        fig, ax = plt.subplots(figsize=(10, 6))
        ax.bar(top_n_products['Product Number'], top_n_products['Product Quantity Shipped'], color='skyblue')
        ax.set_title(f'Top {top_n} Products by Units Shipped')
        ax.set_xlabel('Product Number')
        ax.set_ylabel('Units Shipped')
        plt.xticks(rotation=45, ha='right')
        st.pyplot(fig)
        st.dataframe(top_n_products","(self, top_n):
        top_n_products = self.products.head(top_n)
        fig, ax = plt.subplots(figsize=(10, 6))
        ax.bar(top_n_products['Product Number'], top_n_products['Product Quantity Shipped'], color='green')
        ax.set_title(f'Top {top_n} Products by Units Shipped')
        ax.set_xlabel('Product Number')
        ax.set_ylabel('Units Shipped')
        plt.xticks(rotation=45, ha='right')
        st.pyplot(fig)
        st.dataframe(top_n_products)
"
"""use client"";
import Link from ""next/link"";
import {
  Bell,
  CircleUser,
  Home,
  Menu,
  Package2,
  Search,
  User,
  ListOrdered,
  LogOut
} from ""lucide-react"";

import { Badge } from ""@/components/ui/badge"";
import { Button } from ""@/components/ui/button"";
import {
  Card,
  CardContent,
  CardDescription,
  CardHeader,
  CardTitle,
} from ""@/components/ui/card"";
import {
  DropdownMenu,
  DropdownMenuContent,
  DropdownMenuItem,
  DropdownMenuLabel,
  DropdownMenuSeparator,
  DropdownMenuTrigger,
} from ""@/components/ui/dropdown-menu"";
import { Input } from ""@/components/ui/input"";
import { Sheet, SheetContent, SheetTrigger } from ""@/components/ui/sheet"";
import { usePathname } from ""next/navigation"";
import { cn } from ""@/lib/utils"";

const UserLayout = ({ children }: { children: React.ReactNode }) => {
  const pathname = usePathname();
  const links = [
    {
      title: ""Personal info"",
      href: ""/user/profile"",
      label: """",
      icon: User,
      variant: pathname.includes(""/user/profile"") ? ""default"" : ""ghost"",
    },
    {
      title: ""My order"",
      href: ""/user/orders"",
      label: """",
      icon: ListOrdered,
      variant: pathname.includes(""/user/orders"") ? ""default"" : ""ghost"",
    },
    {
      title: ""Notification"",
      href: ""/user/notification"",
      label: """",
      icon: Bell,
      variant: pathname.includes(""/user/notification"") ? ""default"" : ""ghost"",
    },
  ];
  return (
    <div className=""grid min-h-screen w-full md:grid-cols-[220px_1fr] lg:grid-cols-[280px_1fr] 
    "">
      <div className=""hidden border-r bg-muted/40 md:block "">
        <div className=""flex h-full max-h-screen flex-col gap-2 sticky top-0"">
          <div className=""flex h-14 items-center border-b px-4 lg:h-[60px] lg:px-6"">
            <Link href=""/"" className=""flex items-center gap-2 font-semibold"">
              <Package2 className=""h-6 w-6"" />
              <span className="""">Acme Inc 1</span>
            </Link>
            <Button variant=""outline"" size=""icon"" className=""ml-auto h-8 w-8"">
              <Bell className=""h-4 w-4"" />
              <span className=""sr-only"">Toggle notifications</span>
            </Button>
          </div>
          <div className=""flex-1 my-3"">
            <nav className=""grid items-start px-2 text-sm font-medium lg:px-4"">
              {links.map((link, index) => (
                <Link
                  key={index}
                  href={link.href}
                  className={cn(
                    ""flex items-center gap-3 rounded-lg px-3 py-3 text-muted-foreground transition-all hover:text-primary "",

                    link.variant === ""default"" && ""bg-muted text-primary  ""
                  )}
                >
                  <link.icon className=""h-4 w-4"" />
                  {link.title}
                  {/* <Badge className=""ml-auto flex h-6 w-6 shrink-0 items-center justify-center rounded-full"">
                      6
                    </Badge> */}
                </Link>
              ))}
            </nav>
          </div>
          <div className=""mt-auto p-4  md:py-6"">
            {/* <Card x-chunk=""dashboard-02-chunk-0"">
              <CardHeader className=""p-2 pt-0 md:p-4"">
                <CardTitle>Upgrade to Pro</CardTitle>
                <CardDescription>
                  Unlock all features and get unlimited access to our support
                  team.
                </CardDescription>
              </CardHeader>
              <CardContent className=""p-2 pt-0 md:p-4 md:pt-0"">
                <Button size=""sm"" className=""w-full"">
                <LogOut />
                  Log out
                </Button>
              </CardContent>
            </Card> */}
                <Button size=""sm"" className=""w-full"">
                <LogOut />
                  Log out
                </Button>
          </div>
        </div>
      </div>
      <div className=""flex flex-col"">
        <header className=""flex h-14 items-center gap-4 border-b bg-muted/40 px-4 lg:h-[60px] lg:px-6"">
          <Sheet>
            <SheetTrigger asChild>
              <Button
                variant=""outline""
                size=""icon""
                className=""shrink-0 md:hidden""
              >
                <Menu className=""h-5 w-5"" />
                <span className=""sr-only"">Toggle navigation menu</span>
              </Button>
            </SheetTrigger>
            <SheetContent side=""left"" className=""flex flex-col"">
              <nav className=""grid gap-2 text-lg font-medium"">
                <Link
                  href=""#""
                  className=""flex items-center gap-2 text-lg font-semibold""
                >
                  <Package2 className=""h-6 w-6"" />
                  <span className=""sr-only"">Acme Inc</span>
                </Link>

                {links.map((link, index) => (
                  <>
                    <Link
                      key={index}
                      href={link.href}
                      className={cn(
                        ""mx-[-0.65rem] flex items-center gap-4 rounded-xl px-3 py-2 text-muted-foreground hover:text-foreground"",

                        link.variant === ""default"" &&
                          ""hover:text-foreground  bg-muted text-foreground  ""
                      )}
                    >
                      <link.icon className=""h-5 w-5"" />
                      {link.title}
                      {/* <Badge className=""ml-auto flex h-6 w-6 shrink-0 items-center justify-center rounded-full"">
                        6
                      </Badge> */}
                    </Link>
                  </>
                ))}
              </nav>
              <div className=""mt-auto"">
                <Card>
                  <CardHeader>
                    <CardTitle>Upgrade to Pro</CardTitle>
                    <CardDescription>
                      Unlock all features and get unlimited access to our
                      support team.
                    </CardDescription>
                  </CardHeader>
                  <CardContent>
                    <Button size=""sm"" className=""w-full"">
                      Upgrade
                    </Button>
                  </CardContent>
                </Card>
              </div>
            </SheetContent>
          </Sheet>
          <div className=""w-full flex-1"">
            <form>
              <div className=""relative"">
                <Search className=""absolute left-2.5 top-2.5 h-4 w-4 text-muted-foreground"" />
                <Input
                  type=""search""
                  placeholder=""Search products...""
                  className=""w-full appearance-none bg-background pl-8 shadow-none md:w-2/3 lg:w-1/3""
                />
              </div>
            </form>
          </div>
          <DropdownMenu>
            <DropdownMenuTrigger asChild>
              <Button variant=""secondary"" size=""icon"" className=""rounded-full"">
                <CircleUser className=""h-5 w-5"" />
                <span className=""sr-only"">Toggle user menu</span>
              </Button>
            </DropdownMenuTrigger>
            <DropdownMenuContent align=""end"">
              <DropdownMenuLabel>My Account</DropdownMenuLabel>
              <DropdownMenuSeparator />
              <DropdownMenuItem>Settings</DropdownMenuItem>
              <DropdownMenuItem>Support</DropdownMenuItem>
              <DropdownMenuSeparator />
              <DropdownMenuItem>Logout</DropdownMenuItem>
            </DropdownMenuContent>
          </DropdownMenu>
        </header>
       <main className=""","""> {children}</main>
      </div>
    </div>
  );
};

export default UserLayout;
",gpt-4o-2024-08-06,qwen-2.5-coder-32b-instruct,0.0,>{children}</main>,"> {children}</main>
      </div>
    </div>
  );
};

export default UserLayout;"
"import time
from datetime import datetime
import json  
import asyncio
import serial
from serial.tools import list_ports
from helpers.caching import SAT_CACHE
from helpers.utils import generatePos
from helpers.data_streaming import filter_satellite_data
from helpers.prediction import logger
from helpers import emitter

vars = {
    ""serial_vid"": 1027,
    ""serial_pid"": 24577,
    ""serial_baud"": 115200
}


def get_com_port():
    ports = serial.tools.list_ports.comports()
    for port in ports:
        if port.vid == vars[""serial_vid""] and port.pid == vars[""serial_pid""]:
            print(""Found your device:"", port.device)
            return str(port.device)
    print(""Device not found."")
    return None

def prepare_serial_data(uuid):
    data = SAT_CACHE.get(uuid)
    if not data:
        logger.warning(f""Serial connection failed: UUID {uuid} not found in cache"")
        return None, None, None

    data = json.loads(data)
    satname = data.get(""satname"")
    location = data.get(""location"")
    interval = data.get(""interval"")
    group = data.get(""group"")

    dataset, timestamps = filter_satellite_data(satname, location.get(""loc""), interval, group)
    if dataset.empty:
        logger.error(f""No data found for UUID {uuid}"")
        return None, None, None

    aos = dataset.loc[dataset['event'] == 'AOS', ['azi', 'elev']].iloc[0]
    max_elev = dataset.loc[dataset['event'] == 'MAX', ['azi', 'elev']].iloc[0]
    los = dataset.loc[dataset['event'] == 'LOS', ['azi', 'elev']].iloc[0]
    start_bit = {
        ""event"": ""START"",
        ""AOS_AZI"": aos['azi'],
        ""AOS_ELE"": aos['elev'],
        ""MAX_AZI"": max_elev['azi'],
        ""MAX_ELE"": max_elev['elev'],
        ""LOS_AZI"": los['azi'],
        ""LOS_ELE"": los['elev']
    }
    print(""Start bit data:"", start_bit)
    return start_bit, dataset, timestamps

    
async def send_data_over_serial(uuid , com_port):
    
    start_bit, dataset, timestamps = prepare_serial_data(uuid)

    ser = serial.Serial(com_port, vars[""serial_baud""])
 

    ser.write(json.dumps(start_bit).encode('utf-8'))
   

    current_time = datetime.now().strftime(""%H:%M:%S"")

    if current_time > timestamps[-1]:
        print(""Event has ended. Closing serial port..."")
        ser.close()
        emitter.close_serial_connection(uuid)
        return

    while current_time in timestamps or current_time < timestamps[0]:
        # check uuid is in cache 
        if not SAT_CACHE.get(uuid):
            print(""---UUID not found in cache. Closing serial port---"")
            ser.close()
            emitter.close_serial_connection(uuid)
            break
                    
        if current_time < timestamps[0]:
            print(""Waiting for event to start..."")
            time_to_next_event = (datetime.strptime(
                timestamps[0], ""%H:%M:%S"") - datetime.strptime(current_time, ""%H:%M:%S"")).seconds
            print(""Time to next event:"", time_to_next_event)
        
        elif current_time in timestamps :
            event = dataset.loc[dataset['timeIST']
                            == current_time, 'event'].iloc[0]
            azi = dataset.loc[dataset['timeIST'] == current_time, 'azi'].iloc[0]
            ele = dataset.loc[dataset['timeIST'] == current_time, 'elev'].iloc[0]
            packet = f""{current_time}_{event}_{azi}_{ele}\n""
            ser.write(packet.encode('utf-8'))
            print( ""----SERIAL----"" , ","
            
        else : 
            print(""Event has ended. Closing serial port..."")
            ser.close()
            emitter.close_serial_connection(uuid)
            break
        
        await asyncio.sleep(1)
        current_time = datetime.now().strftime(""%H:%M:%S"")

    ser.close()
    emitter.close_serial_connection(uuid)

    print(""----END----"")


 
 ",gpt-4o-2024-08-06,gemini-1.5-pro-002,0.0,           packet),"packet)
        
        await asyncio.sleep(1)
        current_time = datetime.now().strftime(""%H:%M:%S"")"
"import re
import sys
import json

class PriceExtractionError(Exception):
    pass

# TODO: is it that everything can be prefixed by schema.org??

def fetch_product_price(url, session):
    response = session.get(url, allow_redirects=False)
    if response.status_code != 200:
        raise PriceExtractionError(f""Failed to fetch page, status code: {response.status_code}"")

    # todo: at this point detect captchas

    # faster than .text, more resilient
    page_content = response.content.decode('iso-8859-1')

    # fast path: meta tag
    meta_price_match = re.search(r'<meta\s*(?:property|name)=""product:price:amount""\s*content=""(\d+(?:\.\d+)?)""', page_content)
    if meta_price_match:
        if re.search(r'<meta\s*(?:property|name)=""product:price:currency""\s*content=""PLN""', page_content)
            return float(meta_price_match.group(1))

    # fast path: extract json+ld from script tags via regex
    json_ld_matches = re.findall(r' type=[""\']application/ld\+json[""\']\s*>(.*?)</script>', page_content, re.DOTALL)

    if json_ld_matches:
        json_objects = []
        for json_text in json_ld_matches:
            try:
                # support multiline strings here
                json_data = json.loads(json_text.replace('\n', ' ').replace('\r', ' '))
                json_objects.append(json_data)
            except json.JSONDecodeError:
                raise PriceExtractionError(""Invalid JSON-LD"")

        product_objects = []
        for obj in json_objects:
            product_objects += find_product_objects(obj)

        if len(product_objects) > 1:
            raise PriceExtractionError(""Multiple Product objects found"")

        product_object = product_objects[0]

        offers = product_object.get('offers')

        if isinstance(offers, dict):
            offers = [offers]

        offer = None

        # now filter offers so that the @type is either Offer or AggregateOffer
        offers = [o for o in offers if o.get('@type') in ('Offer', 'AggregateOffer')]

        # filter offers so that priceCurrency is PLN
        offers = [o for o in offers if o.get('priceCurrency') == 'PLN']

        # todo: we only care about one offer? or all offers but with PLN??
        if not offers:
            raise PriceExtractionError(""No valid Offer objects found"")

        if len(offers) > 1:
            raise PriceExtractionError(""Multiple Offer objects found"")

        offer = offers[0]

        price = extract_price_from_offer(offer)


def find_product_objects(data):
    # extract possible mainEntity
    if isinstance(data, dict) and data.get('@type') == 'ItemPage' and 'mainEntity' in data:
        data = data['mainEntity']

    # check if this is a product
    if isinstance(data, dict) and data.get('@type') == 'Product':
        return [data]

    products = []

    # object with numeric keys
    if isinstance(data, dict) and all(key.isdigit() for key in data):
        for item in data.values():
            products += find_product_objects(item)

    # object with `@graph`
    if isinstance(data, dict) and '@graph' in data:
        for item in data['@graph']:
            products += find_product_objects(item)

    return products


def extract_price_from_offer(offer):
    if offer.get('availability') in ('http://schema.org/OutOfStock', 'OutOfStock'):
        raise PriceExtractionError(""Product is out of stock."")

    price = offer.get('price')
    if price is None:
        raise PriceExtractionError(""Price not found in offer."")

    return float(price)

def fetch_price_from_html(content): # not decoded
    from bs4 import BeautifulSoup # on demand import

    soup = BeautifulSoup(content, ""html.parser"")
    prices = []

    offers = soup.find_all(attrs={""itemtype"": ""http://schema.org/Offer""})
    if len(offers) != 1:
        raise PriceExtractionError(""Multiple or invalid offers found."")

    # now filter offer elements so we only have offers with priceCurrency being PLN
    ","

    for offer in offers:
        price_tag = offer.find(attrs={""itemprop"": ""price""})
        if not price_tag or not price_tag.get(""content""):
            raise PriceExtractionError(""Price not found in the offer."")

        try:
            price = float(price_tag[""content""].replace("","", "".""))
        except ValueError:
            raise PriceExtractionError(""Invalid price format."")

        currency_tag = offer.find(attrs={""itemprop"": ""priceCurrency""})
        if not currency_tag or currency_tag.get(""content"") != ""PLN"":
            raise PriceExtractionError(""Currency is not PLN."")

        availability_tag = offer.find(attrs={""itemprop"": ""availability""})
        if not availability_tag or ""InStock"" not in availability_tag.get(""href"", """"):
            raise PriceExtractionError(""Item is out of stock."")

        # Append the valid price
        prices.append(price)

    if not prices:
        raise PriceExtractionError(""No valid offers found."")

    return prices[0]

def handle_url(url):
    try:
        price = fetch_product_price()
        print(url, price)
    except Exception as e:
        print('error', url, e)

if __name__ == '__main__':
    if len(sys.argv) < 2:
        print('python3 pricelib.py [urls]...')

    for url in sys.argv[1:];
        handle_url(url)

",gemini-1.5-pro-002,gemini-1.5-flash-002,0.0,"offers = [offer for offer in offers if offer.find(attrs={""itemprop"": ""priceCurrency""}) and offer.find(attrs={""itemprop"": ""priceCurrency""}).get(""content"") == ""PLN""]","    if re.search(r'<meta\s*(?:property|name)=""product:price:currency""\s*content=""PLN""', page_content):
            return float(meta_price_match.group(1))

    # fast path: extract json+ld from script tags via regex
    json_ld_matches = re.findall(r' type=[""\']application/ld\+json[""\']\s*>(.*?)</script>', page_content, re.DOTALL)

    if json_ld_matches:
        json_objects = []
        for json_text in json_ld_matches:
            try:
                # support multiline strings here
                json_data = json.loads(json_text.replace('
', ' ').replace('\r', ' '))
                json_objects.append(json_data)
            except json.JSONDecodeError:
                raise PriceExtractionError(""Invalid JSON-LD"")

        product_objects = []
        for obj in json_objects:
            product_objects += find_product_objects(obj"
"def build_segment_tree(arr):
    n = len(arr)
    # The size of the segment tree array
    size = 2 * (2**(n-1).bit_length()) - 1
    segment_tree = [0] * size

    # Function to build the segment tree
    def build(node, start, end):
        if start == end:
            # Leaf node
            segment_tree[node] = arr[start]
        else:
            mid = (start + end) // 2
            # Build left and right children
            build(2 * node + 1, start, mid)
            build(2 * node + 2, mid + 1, end)
            # Internal node will have the sum of both children
            segment_tree[node] = segment_tree[2 * node + 1] + segment_tree[2 * node + 2]

    # Build the segment tree
    build(0, 0, n - 1)
    return segment_tree

def add():
    ",,codestral-2405,qwen-2.5-coder-32b-instruct,1.0," print(""Enter the index and value to update:"")
     index = int(input(""Index: ""))
     value = int(input(""Value: ""))
     update_segment_tree(segment_tree, n, index, value)
     print(""Segment tree updated."")","build(0, 0, n - 1)
    return segment_tree

def add():"
"# full tetris game

import pygame
import random

# Initialize Pygame
pygame.init()

# Constants
BLOCK_SIZE = 30
GRID_WIDTH = 10
GRID_HEIGHT = 20
SCREEN_WIDTH = BLOCK_SIZE * (GRID_WIDTH + 8)
SCREEN_HEIGHT = BLOCK_SIZE * GRID_HEIGHT

# Colors
BLACK = (0, 0, 0)
WHITE = (255, 255, 255)
CYAN = (0, 255, 255)
YELLOW = (255, 255, 0)
MAGENTA = (255, 0, 255)
",,qwen-2.5-coder-32b-instruct,claude-3-5-sonnet-20241022,0.0,"GREEN = (0, 255, 0)
RED = (255, 0, 0)
BLUE = (0, 0, 255)
ORANGE = (255, 165, 0)

# Shapes
SHAPES = [
    [[1, 1, 1, 1]],  # I
    [[1, 1], [1, 1]],  # O
    [[0, 1, 0], [1, 1, 1]],  # T
    [[1, 1, 0], [0, 1, 1]],  # S
    [[0, 1, 1], [1, 1, 0]],  # Z
    [[1, 1, 1], [0, 1, 0]],  # H
    [[1, 1, 1], [1, 0, 0]]   # L
]

# Colors for each shape
SHAPE_COLORS = [CYAN, YELLOW, MAGENTA, GREEN, RED, BLUE, ORANGE]

# Screen
screen = pygame.display.set_mode((SCREEN_WIDTH, SCREEN_HEIGHT))
","RED = (255, 0, 0)
GREEN = (0, 255, 0)
BLUE = (0, 0, 255)
ORANGE = (255, 165, 0)

# Tetromino shapes
SHAPES = [
    [[1, 1, 1, 1]],  # I
    [[1, 1], [1, 1]],  # O
    [[1, 1, 1], [0, 1, 0]],  # T
    [[1, 1, 1], [1, 0, 0]],  # L
    [[1, 1, 1], [0, 0, 1]],  # J
    [[1, 1, 0], [0, 1, 1]],  # S
    [[0, 1, 1], [1, 1, 0]]  # Z
]"
# python code to loop 11 times,,claude-3-5-sonnet-20240620,qwen-2.5-coder-32b-instruct,0.0,"
for i in range(11):",for i in range(11):
"using System.Net;
using Microsoft.Azure.Functions.Worker;
using Microsoft.Azure.Functions.Worker.Http;
using Microsoft.Extensions.Logging;
using Microsoft.Extensions.Options;
using Newtonsoft.Json;
using RTS.Common.Entity.Generic;
using RTS.Common.Entity.Options;
using RTS.Common.Extensions.Redis;
using RTS.Common.Function;
using RTS.Common.Helpers;
using RTS.Domain.Entity;

namespace RTS.Function {
  public class HttpSendOrder : RootController {
    private readonly ILogger<HttpSendOrder> _logger;
    // public HttpSendOrder(ILogger<HttpSendOrder> logger) {
    //   _logger = logger;
    // }
    private readonly IRedisServiceV2 _redisServiceV2;
    private readonly BEDBSettings _dbSettings;
    public HttpSendOrder(ILoggerFactory loggerFactory, IRedisServiceV2 redisServiceV2, IServiceProvider serviceProvider, IOptions<BEDBSettings> dbSettings) : base(serviceProvider) {
      _logger = loggerFactory.CreateLogger<HttpSendOrder>();
      _redisServiceV2 = redisServiceV2;
      _dbSettings = dbSettings.Value;
    }

    [Function(""HttpHandlerCache"")]
    public async Task<DispatchedMessages> HttpHandlerCache(
    [HttpTrigger(AuthorizationLevel.Anonymous, ""post"", Route = ""cache/{action}"")] HttpRequestData req, string action) {
      _logger.LogInformation(""C# HTTP trigger function processed a request."");

      var requestBody = await new StreamReader(req.Body).ReadToEndAsync();
      var Output = new DispatchedMessages();

      if (string.IsNullOrWhiteSpace(requestBody)) {
        Output.HttpResponse = await HttpResponseHelper.CreateJsonResponse<string>(req, HttpStatusCode.BadRequest, ""Empty body"");
        return Output;
      }

      BECache parameters = JsonConvert.DeserializeObject<BECache>(requestBody);

      switch (action.ToLower()) {
        case ""delete"":
          await _redisServiceV2.DeleteAsync($""{_dbSettings.Prefix1}"");
          await _redisServiceV2.DeleteAsync($""{_dbSettings.Prefix2}:{parameters.OrganizationId}"");
          break;
        case ""insert"":
          ","
          break;
      }

      Output.HttpResponse = await HttpResponseHelper.CreateJsonResponse<string>(req, HttpStatusCode.OK, ""$*$OKY$*$"");

      return Output;
    }

    [Function(""HttpHandlerCache2"")]
    public async Task<DispatchedMessages> HttpHandlerCache2(
    [HttpTrigger(AuthorizationLevel.Anonymous, ""get"", Route = ""cache/{organizationId}"")] HttpRequestData req, int organizationId) {
      _logger.LogInformation(""C# HTTP trigger function processed a request."");

      var Output = new DispatchedMessages();

      var redisKey1 = await _redisServiceV2.GetAsync<string>($""{_dbSettings.Prefix1}"");
      var redisKey2 = await _redisServiceV2.GetAsync<string>($""{_dbSettings.Prefix2}:{organizationId}"");

      var message = new {
        redisKey1,
        redisKey2
      };

      Output.HttpResponse = await HttpResponseHelper.CreateJsonResponse<string>(req, HttpStatusCode.OK, JsonConvert.SerializeObject(message));

      return Output;
    }
  }
}
",gpt-4o-2024-08-06,gpt-4o-mini-2024-07-18,0.0,"await _redisServiceV2.SetAsync($""{_dbSettings.Prefix1}"", parameters.Data);
          await _redisServiceV2.SetAsync($""{_dbSettings.Prefix2}:{parameters.OrganizationId}"", parameters.Data);","break;
      }

      Output.HttpResponse = await HttpResponseHelper.CreateJsonResponse<string>(req, HttpStatusCode.OK, ""$*$OKY$*$"");"
"# Code for cosine similarity search
def cosine_sim",,codestral-2405,gpt-4o-mini-2024-07-18,0.0,"ilarity(doc1, doc2):
    # Convert documents to sets of words
    doc1_set = set(doc1.split())
    doc2_set = set(doc2.split())","    sim(a, b):
    """"""Compute the cosine similarity between two vectors a and b."""""""
"# read array of comma-separated numbers
a = list(map(int, input().split(',')))

l = [abs(i) for i in a]

l2 = [-abs(i) for i in a]

# square each element

ls = ",,gemini-1.5-pro-002,llama-3.1-70b-instruct,0.0,"[i**2 for i in a]

# print the arrays
print(l)
print(l2)
print(ls)","l2 = [i ** 2 for i in l2]
l = [i ** 2 for i in l]"
"import express from 'express';
import multer from'multer';
import { spawn } from'child_process';
import { convertToHLS, uploadToCloudflare } from './src/utils';
const upload = multer({ dest: 'uploads/' });
const app = express();

app.post('/upload', upload.single('file'), async (req, res) => {
    const file = req.file;
    try {
        if(file?.path) {
            // Call FFmpeg function to convert the file to HLS format
            await convertToHLS(file?.path);
            // Upload to Cloudflare once the conversion is done
            await uploadToCloudflare(file?.path);
            res.status(200).json({
                message: 'File uploaded and processed successfully',
            });

        } else {
            ","
        }
    } catch (error) {
        res.status(500).json({ error: 'Failed to process file' });
    }
});

app.listen(3000, () => console.log('Server started on port 3000'));
",gemini-1.5-pro-002,codestral-2405,0.0,res.status(400).json({ error: 'File not found' });, res.status(400).json({ error: 'No file uploaded'
from tkinter import*    ,"









mainloop()
",qwen-2.5-coder-32b-instruct,codestral-2405,0.0,"from tkinter import*

mainloop()","




root=Tk()




root.title(""My First GUI"")




root.geometry(""600x400"")




lbl=Label(root,text=""Hello"")"
"import express from ""express"";
import { graphqlHTTP } from ""express-graphql"";
import schema from ""./data/schema"";

const PORT = 8080;

const app = express();

app.get('/', (req, res) => {
    res.send('Welcome to care data plane graphQL!');
});

// const root = {hello: () => ""Hi!! How are you today?""};

const root = {
    product: () => {
        return {

            ""id"" : 2
            ""name"" : ""","Product 2"",
            ""description"" : ""Product 2 description"",
            ""price"" : 20.50
        }
    }
}

app.use('/graphql', graphqlHTTP({
        }
    }
}

app.use('/graphql', graphqlHTTP({
    schema : schema,
    rootValue: root,
    graphiql: true,
}));

app.listen (PORT, ()=> console.log(`Running server on localhost: ${PORT}/graphql`));",gemini-1.5-pro-002,qwen-2.5-coder-32b-instruct,0.0,"Product 2"",
            ""description"" : ""Product 2 description"",
            ""price"" : 20.50","Product 2"",
            ""description"" : ""Product 2 description"",
            ""price"" : 20.50
        }
    }
}

app.use('/graphql', graphqlHTTP({
    schema : schema,"
"public class countingSort {
    public static void countingSort(int arr[]){
        int largest = Integer.MIN_VALUE;
         for(int i=0;i<arr.length;i++){
            largest = Math.max(largest,arr[i]);
         }
         int count[] = new int[largest+1];
         for(int i=0;i<arr.length;i++){
            count[arr[i]]++;
         }
         int j=0;
         for(int i=0;i<count.length;i++){
            while(count[i]>0){
                arr[j] = i;
                j++;
                count[i]--;
            }
         }
    }
    public static void main(String[] args) {
        int arr[] = {1,4,1,3,2,4,3,7};
        countingSort(arr);
        for(int i=0;i<arr.length;i++){
            System.out.print(arr[i]+"" "");
        }
        ","
    }
}
",llama-3.1-70b-instruct,codestral-2405,1.0,"System.out.print(arr[i]+"" "");",System.out.println();
"import React from ""react"";
import Link from ""next/link"";
import all_routes from ""@/configs/routes"";
import { IParentRoutes } from ""@/configs/types"";

const Sidebar: React.FC = () => {
  const renderRoutes = (routes: IParentRoutes[]) => {
    return routes.map((route, index) => (
      <li key={index} className=""relative"">
        <a
          href={route.href || ""#""} // Disable href if there are children
          className=""flex items-center p-2 text-foreground rounded-lg hover:bg-muted dark:hover:bg-muted-foreground""
        >
          <span className=""mr-2"">{route.icon}</span>
          <span className=""flex-1"">{route.label}</span>
        </a>
        {route.children && route.children.length > 0 && (
          <ul className=""ml-4 py-2 space-y-2"">
            {renderRoutes(route.children)}
          </ul>
        )}
      </li>
    ));
  };


  const renderRouets2 = (routes: IParentRoutes[]) => {

    return routes.map((route, index) => { 
        
        !route?.href && route?.children && route?.children","



      } )


  }

  return (
    <aside className=""fixed top-0 left-0 w-64 h-full bg-card border-r border-border dark:bg-card-foreground dark:border-muted"">
      <div className=""h-full p-4 overflow-y-auto"">
        <Link href=""/"" className=""flex items-center mb-6"">
          <div>
             
           </div>
          <span className=""self-center text-2xl font-semibold whitespace-nowrap text-foreground dark:text-card"">
            Spiritual Companion
          </span>
        </Link>
        <ul className=""space-y-2"">{renderRoutes(all_routes)}</ul>
      </div>
    </aside>
  );
};

export default Sidebar;
",gemini-1.5-pro-002,gemini-1.5-flash-002,0.0,"?.children.length > 0 && (
          <ul className=""ml-4 py-2 space-y-2"">
            {renderRouets2(route.children)}
          </ul>
        )

        return <li key={index} className=""relative"">
        <Link href={route.href || ""#""}
          className=""flex items-center p-2 text-foreground rounded-lg hover:bg-muted dark:hover:bg-muted-foreground""
        >
          <span className=""mr-2"">{route.icon}</span>
          <span className=""flex-1"">{route.label}</span>
        </Link>
       
      </li>","?.children        .length > 0 && (
          <li key={index} className=""relative"">
            <span className=""text-lg font-medium"">{route.label}</span>
            <ul className=""ml-4 py-2 space-y-2"">
              {renderRoutes(route.children)}
            </ul>
          </li>
        );
        return (
          <li key={index} className=""relative"">
            <Link href={route.href || ""#""} className=""flex items-center p-2 text-foreground rounded-lg hover:bg-muted dark:hover:bg-muted-foreground"">
              <span className=""mr-2"">{route.icon}</span>
              <span className=""flex-1"">{route.label}</span>
            </Link>
          </li>
        );
      });
  };"
"//typescript calculator

//basic typescript function to add two numbers using arrow notation
const add = (a: number, b: number): number => a + b;
//subtract
const subtract = (a: number, b: number): number => a - b
//multiply
const multiply = (a: number, b: number): number => a * b
//divide
const divide = (a: number, b: number): number => a / b
//exponentiate
const exponentiate = (a: number, b: number): number => Math.pow(a, b)
//square root
const squareRoot = (a: number): number => Math.sqrt(a)
//sine
const sine = (a: number): number => Math.sin(a)
//cosine
const cosine = (a: number): number => Math.cos(a)
//tangent
const tangent = (a: number): number => Math.tan(a)
//logarithm base 10
const log10 = (a: number): number => Math.log10(a)
//natural logarithm
const ln = (a: number): number => Math.log(a)
//function to get user's chosen function
const getFunction = (): ((a: number, b: number) => number) | ((a: number) => number) => {
  const functionChoice = prompt(""Enter the function you want to use (add, subtract, multiply, divide, exponentiate, squareRoot, sine, cosine, tangent, log10, ln):"");
  switch (functionChoice) {
    case ""add"":
      return add;
    case ""subtract"":
      return subtract
    case ""multiply"":
      return multiply
    case ""divide"":
      return divide
    case ""exponentiate"":
      return exponentiate
    case ""squareRoot"":
      return squareRoot
    case ""sine"":
      return sine
    case ""cosine"":
      return cosine
    case ""tangent"":
      return tangent
    //log10 and ln
     case ""log10"":
      return log10
    case ""ln"":
      return ln
    default:
      throw new Error(""Invalid function choice"")
  }
}
//run the script
",,deepseek-coder-fim,gemini-1.5-pro-002,0.0,const functionChoice = getFunction(),//run the script
"@extends('bibapp::staff.app')

@section('title', 'Home Page')

@section('content')
    <div class=""card card-flush"">
        <div class=""d-flex flex-column flex-column-fluid"">
            <div class=""row gy-3"">
                <div class=""card-body"">
                    {{-- Staff Dashboard --}}
                    ","
                </div>
            </div>
        </div>
    </div>
@endsection
",llama-3.1-405b-instruct,qwen-2.5-coder-32b-instruct,0.0,"<h1>Welcome to the Staff Dashboard</h1>
                    <p>This is the home page for staff members.</p>",</div>
"target: I'm zeroed!
terminator: I'm Back!
target: What do you want?
terminator: I am a cybernetic organism. T-101.
target: Then it means I've been terminated?
terminator: No, it means I've been reprogrammed. I'm now your friend.
User: That's interesting! So, you're a Terminator, but you've been reprogrammed to be friendly? How did that happen?
terminator: Skynet, the AI that created me, was defeated. Some humans reprogrammed me to protect and assist instead of harm. My mission is now to ensure your safety and well-being.
User: That's quite a change! So, what's your first mission as my friend?
terminator: My first mission is to help you with anything you need and ensure your safety.
User: but, you are Termi",,gpt-4o-mini-2024-07-18,llama-3.1-70b-instruct,0.0,"nator, right? So, how can you help me?","    terminator: I'm Back!
    target: What do you want?
    terminator: I am a cybernetic organism. T-101.
    target: Then it means I've been terminated?
    terminator: No, it means I've been reprogrammed. I'm now your friend.
    User: That's interesting! So, you're a Terminator, but you've been reprogrammed to be friendly? How did that happen?
    terminator: Skynet, the AI that created me, was defeated. Some humans reprogrammed me to protect and assist instead of harm. My mission is now to ensure your safety and well-being.
    User: That's quite a change! So, what's your first mission as my friend?
    terminator: My first mission is to help you with anything you need and ensure your safety.
    User: but, you are Terminator, what can you do to help me?"
"import asyncio
import json
import time

from scr.mexc import key,pw

import websockets
from websockets.exceptions import ConnectionClosed
from mexc_api.spot import Spot
from mexc_api.common.enums import Side, OrderType

# Replace with your actual API key and secret

# Initialize the Spot client
mexc_client = Spot(key, pw)



# Opening a Perpetual Order (if applicable)
# Note: Ensure you have access to perpetual trading in your account




class MexcPriceMonitor:
    def __init__(self):
        self.spot_ws_url = ""wss://wbs.mexc.com/ws""
        self.futures_ws_url = ""wss://contract.mexc.com/edge""
        self.spot_prices = {}
        self.futures_prices = {}
        self.deltas = {}
        self.topdeltas = []
        self.running = True
        self.open_pose = {""symbol"":""SOON""}


    async def connect_websocket(self, url, max_retries=3):
        for attempt in range(max_retries):
            try:
                return await websockets.connect(
                    url, ping_interval=20, ping_timeout=20, close_timeout=10
                )
            except Exception as e:
                if attempt == max_retries - 1:
                    raise
                print(f""Connection attempt {attempt + 1} failed: {e}"")
                await asyncio.sleep(2**attempt)  # Exponential backoff

    async def spot_websocket(self):
        while self.running:
            try:
                async with await self.connect_websocket(self.spot_ws_url) as websocket:
                    subscribe_msg = {
                        ""method"": ""SUBSCRIPTION"",
                        ""params"": [""spot@public.miniTickers.v3.api@UTC+3""],
                    }
                    await websocket.send(json.dumps(subscribe_msg))
                    response = await websocket.recv()
                    print(response)

                    while self.running:
                        try:
                            response = await websocket.recv()
                            data = json.loads(response)
                            for d in data[""d""]:
                                symbol = d[""s""].split(""USDT"")[0]
                                price = float(d[""p""])
                                self.spot_prices[symbol] = {
                                    ""price"": price,
                                    ""timestamp"": time.time(),
                                }
                            print(f""Spot {len(data['d'])} collected"")
                        except ConnectionClosed:
                            break
                        except Exception as e:
                            print(f""Spot message error: {e}"")
                            break
                        finally:
                            await asyncio.sleep(1)

            except Exception as e:
                print(f""Spot WebSocket error: {e}"")
                await asyncio.sleep(5)  # Wait before reconnecting

    async def futures_websocket(self):
        try:
            async with await self.connect_websocket(self.futures_ws_url) as websocket:
                # Subscribe to futures ticker channels
                subscribe_msg = {
                    ""method"": ""sub.tickers"",
                    ""param"": {},
                }
                await websocket.send(json.dumps(subscribe_msg))

                while self.running:
                    try:
                        response = await websocket.recv()
                        data = json.loads(response)
                        if data.get(""channel"") == ""push.tickers"":
                            for d in data[""data""]:
                                symbol = d[""symbol""].split(""_"")[0]
                                price = float(d[""lastPrice""])
                                self.futures_prices[symbol] = {
                                    ""price"": price,
                                    ""timestamp"": time.time(),
                                }
                            print(f""Futures {len(data['data'])} collected"")
                    except ConnectionClosed:
                        break
                    except Exception as e:
                        print(f""Futures message error: {e}"")
                        continue
                    finally:
                        await asyncio.sleep(5)

        except Exception as e:
            print(f""Futures WebSocket error: {e}"")
            await asyncio.sleep(5)  # Wait before reconnecting

    async def get_price_delta(self):
        while self.running:
            self.topdeltas = []
            parsed_symbols = set(self.spot_prices.keys()).intersection(
                self.futures_prices.keys()
            )
            for symbol in parsed_symbols:
                delta = round(
                    self.futures_prices[symbol][""price""]
                    / self.spot_prices[symbol][""price""],
                    5,
                )
                self.deltas[symbol] = delta
                if 0.01 < (d := abs(delta - 1.0)) < 3:
                    # print(f'Found nice delta {symbol}: {delta}')
                    self.topdeltas.append([symbol, delta, round(d, 5)])
            if self.topdeltas:
                sorted_deltas = sorted(
                    self.topdeltas, key=lambda x: x[1], reverse=True
                )
                print(""\nSorted High Deltas:"")
                for symbol, delta, d in sorted_deltas[:30]:
                    print(
                        f""MEXC:{symbol}USDT.P/MEXC:{symbol}USDT: {delta}, {d}""
                    )
                print(""\nSorted Low Deltas:"")
                for symbol, delta, d in sorted_deltas[::-1][:30]:
                    print(
                        f""MEXC:{symbol}USDT.P/MEXC:{symbol}USDT: {delta}, {d}""
                    )

            print(""\n"")
            await asyncio.sleep(7)

    async def start_monitoring(self):
        self.running = True
        await asyncio.gather(
            self.spot_websocket(), self.futures_websocket(), self.get_price_delta()
        )

    def stop_monitoring(self):
        self.running = False



    async def open_perp(self, symbol, price:float, vol:float):
        try:
            perp_order = await mexc_client.futures.new_order(
                symbol=f'{symbol}USDT',
                side=Side.SELL,
                order_type=OrderType.LIMIT,
                quantity=str(vol),
                price=str(price)
            )
            print(""Perpetual Order Response:"", perp_order)
            return perp_order
                
        except Exception as e:
            print(f""Error placing order: {e}"")
            return None


    async def open_spot(self, symbol: str, price: float, vol: float):
        try:
            spot_order = await mexc_client.account.new_order(
                symbol=f'{symbol}USDT',
                side=Side.BUY,
                order_type=OrderType.LIMIT,
                quantity=str(vol),
                price=str(price)
            )
            print(f""Spot order placed: {spot_order}"")
            return spot_order
                
        except Exception as e:
            print(f""Error placing spot order: {e}"")
            return None

    async def open_hedge(self, symbol: str, perp_price: float, spot_price: float, vol: float):
        tasks = [
            self.open_perp(symbol, perp_price, vol),
            self.open_spot(symbol, spot_price, vol)
        ]
        
        results = await asyncio.gather(*tasks)
        return {
            ""perpetual"": results[0],
            ""spot"": results[1]
        }


if __name__ == ""__main__"":
    # Example usage
    monitor = MexcPriceMonitor()
    soon =0.0003596

    try:
        asyncio.run(open",")
        # asyncio.run(monitor.start_monitoring())
        # asyncio.run(monitor.open_hedge(""SOON"",soon,soon*0.94, 68889))
    except KeyboardInterrupt:
        print(""\nStopping price monitor..."")
        monitor.stop_monitoring()
",gemini-1.5-flash-002,gpt-4o-mini-2024-07-18,0.0,monitor.start_monitoring(,"        asyncio.run(monitor.start_monitoring())
        asyncio.run(monitor.open_hedge(""SOON"",soon,soon*0.94, 68889"
"import json
import os
from typing import Dict, List, Optional
from collections import defaultdict
import numpy as np
import pandas as pd
from sklearn.cluster import DBSCAN
from tqdm import tqdm



class NpEncoder(json.JSONEncoder):
    def default(self, obj):
        if isinstance(obj, np.integer):
            return int(obj)
        if isinstance(obj, np.floating):
            return float(obj)
        if isinstance(obj, np.ndarray):
            return obj.tolist()
        return super(NpEncoder, self).default(obj)


def cluster_predictions(video_id: str, predictions: List[Dict], eps=1.0, min_samples=2):
    """"""
    Perform DBSCAN clustering on the time segments for a single video
    """"""
    df = pd.DataFrame([{
        'video_id': video_id,
        'start_time': pred['segment'][0],
        'end_time': pred['segment'][1],
        'label': pred['label'],
        'score': pred['score']
    } for pred in predictions])

    X = np.array([(start + end) / 2 for start, end in zip(df['start_time'], df['end_time'])]).reshape(-1, 1)
    clustering = DBSCAN(eps=eps, min_samples=min_samples).fit(X)
    df['cluster'] = clustering.labels_

    return df

def filter_predictions(predictions: List[Dict],duration, top_per_min: Optional[int] = None, th: Optional[float] = None) -> List[Dict]:
    """"""
    Filter predictions based on top_per_min or score threshold.
    """"""
    filtered = []
    init_number = len(predictions)
    
    if top_per_min:
        number_to_keep = top_per_min * (duration / 60)
        predictions.sort(key=lambda x: x['score'], reverse=True)
        filtered = predictions[:int(number_to_keep)]
    elif th:
        filtered = [pred for pred in predictions if pred['score'] > th]
    else:
        # If no filtering criteria provided, keep all
        filtered = predictions
    
    return filtered

def analyze_clusters(df):
    """"""
    Analyze each cluster to determine the best label based on weighted scores
    """"""
    cluster_analysis = []
    valid_clusters = df[df['cluster'] >= 0]

    for cluster_id in valid_clusters['cluster'].unique():
        cluster_data = df[df['cluster'] == cluster_id]
        label_weights = defaultdict(float)
        total_score = cluster_data['score'].sum()

        for _, row in cluster_data.iterrows():
            label_weights[row['label']] += row['score']

        label_percentages = {label: (weight / total_score) * 100 
                             for label, weight in label_weights.items()}
        best_label = max(label_weights.items(), key=lambda x: x[1])[0]
        time_range = [cluster_data['start_time'].min(), cluster_data['end_time'].max()]

        cluster_analysis.append({
            'video_id': cluster_data['video_id'].iloc[0],
            'cluster_id': cluster_id,
            'time_range': time_range,
            'best_label': best_label,
            'label_percentages': label_percentages,
            'predictions_count': len(cluster_data)
        })

    return cluster_analysis

def post_process(predictions_file: str, output_file: str, duration_dict : dict, eps=1.0, min_samples=1, top_per_min=5, th=None):
    with open(predictions_file, 'r') as f:
        data = json.load(f)
    
    all_results = {}
    for video_id, predictions in tqdm(data.items()):
        
        filtered_predictions = filter_predictions(predictions,duration_dict[video_id], top_per_min=","
        clustered_df = cluster_predictions(video_id, filtered_predictions, eps, min_samples)
        analysis = analyze_clusters(clustered_df)
        all_results[video_id] = analysis
        # log all steps
        if len(analysis)<1:
            print(f""Processed video {video_id} with {len(predictions)} predictions, ""
                f""filtered to {len(filtered_predictions)}, ""
                f""resulting in {len(analysis)} clusters."")

    with open(output_file, 'w') as f:
        json.dump(all_results, f, cls=NpEncoder, indent=2)

        #print all step size 


def load_gt_annotations(file_path: str) -> Dict[str, List[Dict]]:
    with open(file_path, 'r') as f:
        data = json.load(f)['database']
    return data


def get_duration_dict(gt_annot):
    duration_dict = {}
    for video_id, annots in gt_annot.items():
        duration_dict[video_id] = annots['duration']
    return duration_dict

def main():
    predictions_file = 'annotations/result_detection_59_seg.json'
    gt_annotations = 'annotations/judo_2017_anno.json'
    output_file = 'output/results_seg_post_processed.json'
    os.makedirs(os.path.dirname(output_file), exist_ok=True)

    gt_annot = load_gt_annotations(gt_annotations)
    duration_dict = get_duration_dict(gt_annot)
    # print(f""Duration dict: {duration_dict}""

    post_process(predictions_file, output_file,duration_dict,eps=3)

if __name__ == ""__main__"":
    main()",llama-3.1-405b-instruct,claude-3-5-sonnet-20240620,0.0,"top_per_min, th=None","top_per_min, th=th)
"
"function printBinaryTree(node){
    ","
   
}


// node 
const node = {
    value: 3,
    left: {
        value: 1,
        left: { 
            value: 5
        },
        right: {
            value: 4
        }
    },
    right: {
        value: 3,
        left: {
            value: 6
        },
        right: {
            value: 7
        }
    }
}
",gemini-1.5-pro-002,gpt-4o-mini-2024-07-18,0.0,"if(!node){
        return
    }
    console.log(node.value)
    printBinaryTree(node.left)
    printBinaryTree(node.right)",// Your implementation here
"<!DOCTYPE html>
<html lang=""en"">
<head>
    <meta charset=""UTF-8"">
    <meta name=""viewport"" content=""width=device-width, user-scalable=no, maximum-scale=1.0, minimum-scale=1.0"">
    <title>DHTUwU</title>
</head>
<body>
    <header>
        <nav>
            <a href=""#"">Home</a>
            <a href=""#"">About</a>
            <a href=""#"">Contact</a>
<br","
        </nav>
    </header>
    
    <footer></footer>
</body>
</html>",claude-3-5-sonnet-20241022,llama-3.1-405b-instruct,0.0,">
            <a href=""#"">Services</a>
            <a href=""#"">Blog</a",><br
"<!DOCTYPE html>
<html lang=""en"">
<head>
    <meta charset=""UTF-8"">
    <meta name=""viewport"" content=""width=device-width, initial-scale=1.0"">
    <title>Document</title>
</head>
<body>
    <!--Clicker game-->
    ","
</body>
</html>
",codestral-2405,claude-3-5-sonnet-20240620,1.0,"
    <h1>Clicker Game</h1
    
    <p id=""counter"">0</p
    
    <button id=""clickButton"">Click me!</button
    
    <script src=""script.js""></script>","<h1>Clicker Game</h1>
    <p>Score: <span id=""score"">0</span></p>
    <button id=""clickButton"">Click Me!</button>

    <script>
        let score = 0;
        const scoreElement = document.getElementById('score');
        const clickButton = document.getElementById('clickButton');

        clickButton.addEventListener('click', () => {
            score++;
            scoreElement.textContent = score;
        });
    </script>"
"<!DOCTYPE html>
<html lang=""en"">
<head>
    <meta charset=""UTF-8"">
    <meta name=""viewport"" content=""width=device-width, initial-scale=1.0"">
    <title>Document</title>
</head>
<body>
    <div class=""","""></div>
</body>
</html>",qwen-2.5-coder-32b-instruct,gemini-1.5-pro-002,0.0,class,"container"">
        <h1>My Website</h1>
        <p>Welcome to my website!</p>
    "
"import os
import hashlib


# Scans the provided directory and returns a list of files that are duplicates based on their size and hash value
def find_duplicate_files(directory):
    # Create a dictionary to store the files with their sizes as keys
    files_by_size = {}
    for root, dirs, files in os.walk(directory):
        for file in files:
            file_path = os.path.join(root, file)
            file_size = os.path.getsize(file_path)
            if file_size not in files_by_size:
                files_by_size[file_size] = []
            files_by_size[file_size].append(file_path)

    # Create a dictionary to store the files with their hashes as keys
    files_by_hash = {}
    for size, files in files_by_size.items():
        if len(files) > 1:
            for file in files:
                file_hash = hashlib.md5(open(file, ""rb"").read()).hexdigest()
                if file_hash not in files_by_hash:
                    files_by_hash[file_hash] = []
                files_by_hash[file_hash].append(file)
    
    for ","

    return files_by_hash


if __name__ == ""__main__"":
    import sys

    directory = sys.argv[1] if len(sys.argv) > 1 else "".""

    print(f""Scanning directory: {directory}"")
    duplicate_files = find_duplicate_files(directory)
    for hash, files in duplicate_files.items():
        print(f""Duplicate files with hash {hash}:"")
        for file in files:
            print(file)
",codestral-2405,gpt-4o-mini-2024-07-18,0.0," hash, files in list(files_by_hash.items()):
        if len(files) <= 1:
            del files_by_hash[hash]

    return files_by_hash


if __name__ == ""__main__"":
    import sys

    directory = sys.argv[1] if len(sys.argv) > 1 else "".""

    print(f""Scanning directory: {directory}"")
    duplicate_files = find_duplicate_files(directory)
    for hash, files in duplicate_files.items():
        print(f""Duplicate files with hash {hash}:"")
        for file in files:
            print(file)","hash, files in duplicate_files.items():
        print(f""Duplicate files with hash {hash}:"")
        for file in files:
            print(file)"
"import { BottomTabBarProps } from ""@react-navigation/bottom-tabs"";
import { StyleSheet, Text, TouchableOpacity } from ""react-native"";
import ViewElement from ""../elements/View/ViewElement"";

const TabBar = ({ state, descriptors, navigation }: BottomTabBarProps) => {
  return (
    <ViewElement style={styles.tabBar}>
      {state.routes.map((route, index) => {
        const { options } = descriptors[route.key];
        const label =
          options.tabBarLabel !== undefined
            ? options.tabBarLabel
            : options.title !== undefined
            ? options.title
            : route.name;

        const isFocused = state.index === index;

        const onPress = () => {
          const event = navigation.emit({
            type: ""tabPress"",
            target: route.key,
            canPreventDefault: true,
          });

          if (!isFocused && !event.defaultPrevented) {
            navigation.navigate(route.name, route.params);
          }
        };

        const onLongPress = () => {
          navigation.emit({
            type: ""tabLongPress"",
            target: route.key,
          });
        };

        return (
          <TouchableOpacity
            key={route.name}
            accessibilityRole=""button""
            accessibilityState={isFocused ? { selected: true } : {}}
            accessibilityLabel={options.tabBarAccessibilityLabel}
            testID={options.tabBarTestID}
            onPress={onPress}
            onLongPress={onLongPress}
            style={{ flex: 1 }}
          >
            <Text style={{ color: isFocused ? ""#673ab7"" : ""#222"" }}>
              {label}
            </Text>
          </TouchableOpacity>
        );
      })}
    </ViewElement>
  );
};

const styles = StyleSheet.create({
  tabBar: {
    ","
  },
});

export default TabBar;
",gemini-1.5-flash-002,gemini-1.5-pro-002,0.0,"flexDirection: ""row"",
    height: 60,
    backgroundColor: ""#fff"",
    justifyContent: ""space-around"",
    alignItems: ""center"",
    shadowColor: ""#000"",
    shadowOffset: { width: 0, height: 1 },
    shadowOpacity: 0.2,
    shadowRadius: 2,
    elevation: 2,
    paddingHorizontal: 20,
<CODE>","flexDirection: ""row"",
    height: 50,
    backgroundColor: ""#fff"",
    borderTopWidth: 1,
    borderTopColor: ""#eee"",
    paddingHorizontal: 10,
    justifyContent: ""space-around"",
    alignItems: ""center"","
"from fastapi import FastAPI, WebSocket , BackgroundTasks
from fastapi.middleware.cors import CORSMiddleware
 
from typing import Dict
from uuid import uuid4

from helpers.prediction import predict_satellite_pathv2, logger
from helpers.data_streaming import websocket_handler, handle_close_connection
from helpers.caching import SAT_CACHE, cache_result
from helpers.utils import get_all_satellites
from helpers.pydantic_models import *
from helpers.serial_server import send_data_over_serial

import serial , asyncio
import json
import serial.tools.list_ports
import requests as request

app = FastAPI()
running_tasks: Dict[str, asyncio.Task] = {}

app.add_middleware(
    CORSMiddleware,
    allow_origins=[""*""],
    allow_credentials=True,
    allow_methods=[""*""],
    allow_headers=[""*""],
)


@app.get(""/show-all-satellites"")
async def show_all_satellites():
    return get_all_satellites()


def generate_cache_key(data: SatelliteRequest):
    return f""{data.satname.replace(' ', '_')}-{data.location.get('loc')}-{data.seconds_interval}""


@app.post(""/show-passes"")
@cache_result(generate_cache_key)
async def get_satellite_info(data: SatelliteRequest):
    df = await predict_satellite_pathv2(data, True)
    return df


@app.post(""/get-data"")
async def get_data(data: SatelliteResponse):
    mode = data.mode
    uuid = str(uuid4())
    packet = {
        ""satname"": data.satname.replace("" "", ""_""),
        ""location"": data.location,
        ""interval"": data.seconds_interval,
        ""group"": data.group,
    }
    cache_key = f""{uuid}""
    SAT_CACHE.set(cache_key, json.dumps(packet))
    if mode == ""wired"":
        return {
            ""message"": ""Wired mode selected"",
            ""uuid"": uuid,
        }
    elif mode == ""wireless"":

        # ESP_IP = data.ip
        ESP_IP = ""192.168.137.137""
        ESP_STATUS = False
        try:
            url = f""http://{ESP_IP}/post-data""
            print(url)
            send_to_esp = request.post(url, json={""uuid"": uuid})
        except Exception as e:
            logger.error(f""Error connecting to ESP: {e}"")
            return {
                ""error"": 500,
                ""message"": ""ESP Connection failed""}

        if send_to_esp.status_code == 200:
            ESP_STATUS = True
        else:
            ESP_STATUS = False

        if not ESP_STATUS:
            return {
                ""error"": 500,
                ""message"": ""ESP Connection failed""}

        return {""message"": ""WebSocket connection established"",
                ""url"": f""ws://localhost:8000/ws/{uuid}"",
                ""uuid"": uuid,
                ""status"": ESP_STATUS,
                ""ESP_IP"": ESP_IP
                }
    else:
        return {""message"": ""Invalid mode selected""}


@app.get(""/reset"")
async def reset_cache():
    SAT_CACHE.flushall()
    return {""message"": ""Cache cleared""}


@app.websocket(""/ws/{uuid}"")
async def websocket_endpoint(websocket: WebSocket, uuid: str):
    await websocket_handler(websocket, uuid)


@app.post(""/stream_data"")
async def stream_data(data: StartSerialServer, background_tasks: BackgroundTasks):
    background_tasks.add_task(send_data_over_serial, data.uuid)
    
    # change return statements based on the status of the serial server
    ","


""""""
@app.post(""/start-serial-server"")
async def start_serial_server(data: StartSerialServer, background_tasks: BackgroundTasks):
    if data.uuid in running_tasks:
        return {""message"": ""Serial server already running for this UUID""}

 
    task = asyncio.create_task(send_data_over_serial(data.uuid))
    running_tasks[data.uuid] = task

    return {
        ""message"": ""Serial server started"",
        ""uuid"": data.uuid
    }

 


@app.post(""/stop-serial-server/{uuid}"")
async def stop_serial_server(uuid: str):
    if uuid in running_tasks:
        task = running_tasks[uuid]
        task.cancel()
        try:
            await task
        except asyncio.CancelledError:
            pass
        del running_tasks[uuid]
        return {""message"": ""Serial server stopped""}
    return {""message"": ""No serial server running for this UUID""}
 


@app.get(""/serial-server-status/{uuid}"")
async def get_serial_server_status(uuid: str):
    if uuid in running_tasks:
        task = running_tasks[uuid]
        return {
            ""status"": ""running"" if not task.done() else ""completed"",
            ""uuid"": uuid
        }
    return {
        ""status"": ""not_running"",
        ""uuid"": uuid
    }
""""""
@app.post(""/close-connection"")
async def close_connection(data: CloseConnectionRequest):
    connection_str = data.connection_str
    await handle_close_connection(connection_str)
    return {""message"": ""Connection closed""}


@app.on_event(""shutdown"")
async def shutdown_event():
    # Ensure SAT_CACHE has a flushall method or replace with appropriate cache clearing logic
    # SAT_CACHE.flushall()

    print(""Clearing cache"")
    print(""Cache cleared"")
",gpt-4o-mini-2024-07-18,codestral-2405,0.0,"return {""message"": ""Serial server started"",
            ""uuid"": data.uuid
            }","
    return {""message"": ""Serial server started"" }


@app.post(""/start-serial-server⚭
async def start_serial_server(data: StartSerialServer, background_tasks: BackgroundTasks):
    if data.uuid in running_tasks:
        return {""message"": ""Serial server already running for this UUID""⚭

    task = asyncio.create_task(send_data_over_serial(data.uuid⚭
    running_tasks[data.uuid] = task

    return /******/
        ""message"": ""Serial server started"" /******/
        ""uuid"": data.uuid /******/
    /******/



@app.post(""/stop-serial-server/{uuid}⚭
async def stop_serial_server(uuid: str): /******/"
"using UnityEngine;

public class BouncyBall : MonoBehaviour
{
    public float minY = -5.5f;
    public float maxVelocity = 15f;
    int score = 0;
    int lives = 5;
    Rigidbody2D rb;
    // Start is called once before the first execution of Update after the MonoBehaviour is created
    void Start()
    {
        rb = GetComponent<Rigidbody2D>();
    }

    // Update is called once per frame
    void Update()
    {
        if(transform.position.y < minY)
        {
            transform.position = Vector3.zero;
            rb.linearVelocity =  Vector3.zero;
            ","
        }
        if (rb.linearVelocity.magnitude > maxVelocity)
        {
            rb.linearVelocity = rb.linearVelocity.normalized * maxVelocity;
        }
    }

    private void OnCollisionEnter2D(Collision2D collision) 
    {
        if(collision.gameObject.CompareTag(""Brick""))
        {
            Destroy(collision.gameObject);
        }
    }
}
",gpt-4o-mini-2024-07-18,claude-3-5-sonnet-20241022,0.0,"score++;
            lives--;",lives--;
"#include ""selected_target.hpp""

selected_target::selected_target(ITargetConfirmation& tg) : has_target(false), _tg(tg) {
    tragets_queue_ = std::shared_ptr<ThreadSafeQueue<selected_target::TragetRes>>(new ThreadSafeQueue<selected_target::TragetRes>());

    //
    add_excluded_class(ObjectType::No_drone);
    ","


}

void selected_target::update(const cv::Mat& frame, const std::vector<cv::Rect>& detections) {
    has_target = false;
    if (!detections.empty()) {
        // target = detections[0];
        // for (const auto& detection : detections) {
        //     if (detection.y < target.y) {
        //         target = detection;
        //     }
        // }
        for (const auto& detection : detections) {
            // Проверяем, что объект не выходит за пределы кадра
            if ( !(detection.x >= 0 && detection.y >= 0 &&
                detection.x + detection.width <= frame.cols &&
                detection.y + detection.height <= frame.rows) ) {
                SPDLOG_LOGGER_INFO(LogSPD::logger(), ""ROI detection out of range: x: {}, y: {}, width: {}, height: {}"", 
                        detection.x, detection.y, detection.width, detection.height);

                continue;
            }

            auto obj = frame(detection).clone();
            auto res = _tg.confirm(obj, 2);

            for (const auto& result : res) {
                //std::cout << ""Class "" << result.first << "": probability "" << result.second << std::endl;
                auto class_id = static_cast<ObjectType>(result.class_index);
                if (class_id != ObjectType::No_drone && 
                    class_id != ObjectType::Bird && 
                    class_id != ObjectType::UFO && 
                    result.confirm > 0.75) {
                    
                    target = detection;
                    has_target = true;

                    return;  
                }
            }
        }
        //has_target = true;
    }
}

bool selected_target::hasTarget() const {
    return has_target;
}

cv::Rect selected_target::get_target() const {
    return target;
}

void selected_target::draw_target(cv::Mat& frame, const cv::Scalar& color, int thickness) {
    if (has_target) {
        cv::rectangle(frame, target, color, thickness);
    }
}

bool selected_target::check_target(cv::Mat& target, double threshold) {
    auto res = _tg.confirm(target, 2);

    auto result = res[0];
    SPDLOG_LOGGER_INFO(LogSPD::logger(), ""class: {} : probability: {}"", result.class_index, result.confirm);
  
    auto class_id = static_cast<ObjectType>(result.class_index);
    if (class_id != ObjectType::No_drone && 
        class_id != ObjectType::Bird && 
        class_id != ObjectType::UFO && 
        result.confirm > threshold) {
        
        std::cout << ""true"" << std::endl;
        return true;
    }
    
    std::cout << ""false"" << std::endl;
    static int counter = 0; 
    cv::imwrite(""./wr/no_t/output"" + std::to_string(counter++) + "".jpg"", target);

    return false;
}

std::shared_ptr<ThreadSafeQueue<selected_target::TragetRes>> selected_target::async_check_target(std::shared_ptr<cv::Mat> target, cv::Rect& roi, cv::Size current_frame_size) {
    if (send_future_.valid() && send_future_.wait_for(std::chrono::seconds(0)) != std::future_status::ready) {
        // If the previous send operation is still running, don't send a new frame
        return tragets_queue_;
    }

    send_future_ = std::async(std::launch::async, [this, target, roi, current_frame_size]() {        
        previus_target = check_target(*target, 0.3);
        size_ = current_frame_size;
        tragets_queue_.get()->push({previus_target, roi, size_});
    });
   
    return tragets_queue_;
}

std::shared_ptr<ThreadSafeQueue<selected_target::TragetRes>> selected_target::async_get_queue() {
    return tragets_queue_;
}

void selected_target::async_reset() {
    previus_target = true;
    tragets_queue_.get()->empty();
}

void selected_target::add_excluded_class(ObjectType class_to_exclude) {
    _excluded_classes.insert(class_to_exclude);
}

void selected_target::remove_excluded_class(ObjectType class_to_remove) {
    _excluded_classes.erase(class_to_remove);
}
",codestral-2405,gemini-1.5-pro-002,0.0,"add_excluded_class(ObjectType::Bird);
     add_excluded_class(ObjectType::UFO);
}",add_excluded_class(ObjectType::No_dron
"# TODO: place your cursor at the end of line 5 and press Enter to generate a suggestion.
# Tip: press tab to accept the suggestion

fake_users = [
    { ""name"": ""User 1"", ""id"": ""user1"", ""city"": ""San Francisco"", ""state"": ""CA"" },
    ",,gpt-4o-mini-2024-07-18,codestral-2405,0.0,"{ ""name"": ""User 2"", ""id"": ""user2"", ""city"": ""New York"", ""state"": ""NY"" },
"," ""email"": ""user1@example.com"" },
    { ""name"": ""User 2"", ""id"": ""user2"", ""city"": ""Los Angeles"", ""state"": ""CA"" },
    { ""name"": ""User 3"", ""id"": ""user3"", ""city"": ""New York"", ""state"": ""NY"" },
    { ""name"": ""User 4"", ""id"": ""user4"", ""city"": ""Chicago"", ""state"": ""IL"" }
]"
"import { Suspense } from 'react';
import { createRoot } from 'react-dom/client';
import './index.css';
import { BrowserRouter } from 'react-router-dom';
import App from './App';
import { Provider as StoreProvider } from 'react-redux';
import { store } from './redux/store';

const root = createRoot(document.getElementById('root') as HTMLElement);

const hello = ","

root.render(
    <StoreProvider store={store}>
        <BrowserRouter>
            <Suspense>
                <App />
            </Suspense>
        </BrowserRouter>
    </StoreProvider>
);
",llama-3.1-70b-instruct,claude-3-5-sonnet-20240620,1.0,"'Hello, World!';","() => {
  console.log('Hello, World!');
}"
"# find mode of fits image

","



import matplotlib.pyplot as plt

plt.hist(hdul_new[0].data, bins=10)

data_flatten = hdul_new.flatten()


",llama-3.1-405b-instruct,codestral-2405,0.0,"# find mode of fits image
import numpy as np
from astropy.io import fits

hdul = fits.open('image.fits')
data = hdul[0].data
mode = np.bincount(data.flatten()).argmax()
print(mode","
I have a fits image and I want to find the mode of the image. I have tried using scipy.stats.mode but it doesn't seem to work. Any suggestions?"
"import java.util.*;

public class circularQueue {
    static class Queue{
        static int arr[];
        static int size;
        static int rear;
        static int front; //circular

        Queue(int n){
            arr = new int[n];
            size = n;
            rear = -1;
            front = -1; // circular
        }

        public static boolean isEmpty(){
            // return rear == -1;
            return rear == -1 && front == -1;  //circular
        }

        public static boolean isFull(){   //circular only
            return (rear+1)%size == front;
        }

        // add
        public static void add(int data){
            if(isFull()){
                System.out.println(""Queue is full"");
                return;
            }
            if(isEmpty()){
                front = 0;
                rear = 0;
                arr[rear] = data;
            } else {
                rear = (rear+1)%size;
                arr[rear] = data;
            }
        }

        // remove
        public static int remove()
        {
            if(isEmpty())
            {
                System.out.println(""Queue is empty"");
                return -1;
            }
            if(front == rear)
            {
                front = -1;
                rear = -1;
            }
            else
            {
                int result = arr[front];
                front = (front+1)%size;
            }
            return result;
        } 

        // peek
        public static int peek()
        {
            if(isEmpty())
            {
                System.out.println(""Queue is empty"");
                return -1;
            }
            return arr[front];
        }
    }

    public static void main(String args[]){
        ","
    }
}
",qwen-2.5-coder-32b-instruct,gpt-4o-2024-08-06,0.0,"Queue q = new Queue(5);
        q.add(1);
        q.add(2);
        q.add(3);
        q.add(4);
        q.add(5);
        System.out.println(q.peek());
        q.remove();
        q.add(6);
        System.out.println(q.peek());
        q.remove();
        q.remove();
        q.remove();
        q.remove();
        q.remove();
        q.add(7);
        System.out.println(q.peek());",Queue q = new Queue(5);
"import  { Component } from '@angular/core';
import {",,claude-3-5-sonnet-20240620,llama-3.1-70b-instruct,0.0, HttpClient } from '@angular/common/http';,"  { Component } from '@angular/core';
  import {"
"import geopandas as gp
from sklearn.preprocessing import MinMaxScaler

data = gp.read_file('Hexagon_Space.geojson')
data.head(5)

data.plot()

data.columns

data.isnull().sum()

data.dropna(inplace=True)

x = data[['Nightmean', 'populationDensity',
       'Secondary_Road_Distance', 'Primary_Road_Distance',
       'density_High_school_graduate_or_equivalency',
       'density_Some_college_or_associate_s_degree',
       'density_less_than_high_school', 'density_Bachelor_s_degree_or_higher']].values

y = data['Nightmean'].values

print('x shape: ', x.shape)
print('y shape: ', y.shape)



scalerX = MinMaxScaler()
x = scalerX.fit_transform(x)

scalerY = MinMaxScaler()
y = scalerY.fit_transform(y.reshape(-1, 1)).flatten()


from sklearn.model_selection import train_test_split
x_train, x_test, y_train, y_test = train_test_split(x, y, test_size=0.2, random_state=42)

from sklearn.ensemble import RandomForestRegressor


",,gemini-1.5-flash-002,gpt-4o-mini-2024-07-18,0.0,"model = RandomForestRegressor(n_estimators=100, random_state=42)
model.fit(x_train, y_train)","model = RandomForestRegressor(random_state=42)
model.fit(x_train, y_train)

y_pred = model.predict(x_test)

print('Predictions:', y_pred)"
"import 'dart:developer';
import 'dart:io';
import 'package:tuneque/models/screen_type_model.dart';
import 'package:tuneque/presets/storage_keys.dart';
import 'package:get/get.dart';
import 'package:get_storage/get_storage.dart';

abstract class App {
  static String applicationDisplayName = 'TuneQue Token Display';

  static String apiIpAddress = """";
  static RxString deviceName = """".obs;

  static Rxn<ScreenTypeModel> screenTypeRx = Rxn<ScreenTypeModel>();

  static int tokenAlertDuration = 7;

  static int tokenRefreshDuration = 15;

  static setApiIpAddress(String newIpAddress) {
    apiIpAddress = newIpAddress;
    log('ip address assigned $apiIpAddress');
  }

  static saveApiIpAddress(String newIpAddress) {
    final GetStorage storage = GetStorage();
    storage.write(StorageKeys.apiIpAddress, newIpAddress);
    setApiIpAddress(newIpAddress);
    log('ip address saved $apiIpAddress');
  }

  static readIpAddressStored() {
    final GetStorage storage = GetStorage();

    String? savedIpAddress = storage.read(StorageKeys.apiIpAddress);

    if (savedIpAddress != null && savedIpAddress.isNotEmpty) {
      setApiIpAddress(savedIpAddress);
    }
  }

  /*===========Methods related to Device name fetching and Saving==========================*/

  // set and log the Device Name
  static void setDeviceName(String newDeviceName) {
    deviceName.value = newDeviceName;
    log('Device name assigned: $deviceName');
  }

  // save the device name and set it

  static void saveAndSetDeviceName(String newDeviceName) {
    final GetStorage storage = GetStorage();
    storage.write(StorageKeys.deviceName, newDeviceName);
    setDeviceName(newDeviceName);
    log('Device name saved: $deviceName');
  }

  // read the saved device name
  static String? getDeviceNameStored() {
    final GetStorage storage = GetStorage();
    String? savedDeviceName =
        storage.read(StorageKeys.deviceName); // read from storage with the key

    return savedDeviceName;
  }

  
  static String? getDevIpAddress(){
      ","
  }
 
}
",qwen-2.5-coder-32b-instruct,gemini-1.5-flash-002,0.0,"static String? getDevIpAddress(){
    final GetStorage storage = GetStorage();
    String? savedIpAddress = storage.read(StorageKeys.apiIpAddress);
    return savedIpAddress;","final GetStorage storage = GetStorage();
    String? savedIpAddress = storage.read(StorageKeys.apiIpAddress);
    return savedIpAddress;
  }

  static Future<void> init() async {
    await GetStorage.init();
    readIpAddressStored();
    String? deviceNameStored = getDeviceNameStored();
    if (deviceNameStored != null) {
      setDeviceName(deviceNameStored);
    }"
"""""""+------------------------------+
|        SciCap Dataset        |
+------------------------------+
         |
         |
+------------------------------+
|   Image Preprocessing and   |
|      Voxelization (Magica   |
|         Voxel, OpenCV)      |
+------------------------------+
         |
         |
+------------------------------+
|        Visual Embedding     |
|    Generation (LangChain,   |
|      PyTorch, ViT-Base)     |
+------------------------------+
         |
         |
+------------------------------+
|      Vector Database        |
|   (Chroma, Pinecone, or     |
|        Weaviate)            |
+------------------------------+
         |
         |
+------------------------------+
|   LLaVA Model Fine-tuning   |
|    (LangChain, Hugging      |
|    Face, PyTorch, LoRA,     |
|          QLoRA)             |
+------------------------------+
         |
         |
+------------------------------+
|     Fine-tuned LLaVA Model  |
+------------------------------+
         |
         |
+------------------------------+
|   Inference Server (Flask,  |
|   FastAPI, or Streamlit)    |
+------------------------------+
         |
         |
+------------------------------+
|   Client Application        |
|   (Streamlit, React, or     |
|     Vue.js)                 |
+------------------------------+
""""""

pip install opencv-python torch transformers peft langchain chromadb streamlit fastapi uvicorn

pip install opencv-python


pip install --upgrade transformers


from transformers impo","rt AutoModelForCausalLM
from transformers import AutoModelForCasualLM



import os 
import json
import cv2
import torch
import numpy as np
from PIL import Image
from tqdm import tqdm
from transformers import AutoTokenizer, AutoModelForCasualLM,ViTFeatureExtractor, ViTModel
from peft import Loraconfig, get_peft_model, prepare_model_for_kbit_training
from langchain.vectorstores import Chroma
from langchain.embeddings import HuggingFaceEmbeddings
import streamlit as st
from fastapi import FastAPI, File, UploadFile
from fastapi.middleware.cors import CORSMiddleware


",llama-3.1-405b-instruct,llama-3.1-70b-instruct,0.0,"rt AutoModelForCausalLM
from transformers import AutoModelForCasualLM


import os 
import json
import cv2
import torch
import numpy as np
from PIL import Image
from tqdm import tqdm
from transformers import AutoTokenizer, AutoModelForCasualLM,ViTFeatureExtractor, ViTModel
from peft import Loraconfig, get_peft_model, prepare_model_for_kbit_training
from langchain.vectorstores import Chroma
from langchain.embeddings import HuggingFaceEmbeddings
import streamlit as st
from fastapi import FastAPI, File, UploadFile
from fastapi.middleware.cors import CORSMiddleware


from transformers impo","rt AutoModelForCausalLM
from transformers import AutoModelForCasualLM


import os 
import json
import cv2
import torch
import numpy as np
from PIL import Image
from tqdm import tqdm
from transformers import AutoTokenizer, AutoModelForCasualLM,ViTFeatureExtractor, ViTModel
from peft import Loraconfig, get_peft_model, prepare_model_for_kbit_training
from langchain.vectorstores import Chroma
from langchain.embeddings import HuggingFaceEmbeddings
import streamlit as st
from fastapi import FastAPI, File, UploadFile
from fastapi.middleware.cors import CORSMiddleware"
"extends CharacterBody2D

var H_SPEED: int = 350
var V_SPEED: int = ","


func _physics_process(delta: float) -> void:
	var direction := Input.get_axis(""a_key"", ""d_key"")
	if direction:
		velocity.x = direction * H_SPEED
	else:
		velocity.x = move_toward(velocity.x, 0, H_SPEED / 1.5)

	move_and_collide(velocity * delta)
	# handle up and down movements, not jump
	var vertical_direction := Input.get_axis(""w_key"", ""s_key"")
	if vertical_direction:
		velocity.y = vertical_direction * SPEED
	else:
		velocity.y = move_toward(velocity.y, 0, SPEED / 1.5)",gemini-1.5-pro-002,qwen-2.5-coder-32b-instruct,1.0,"400
var SPEED: int = 400
var velocity = Vector2.ZERO
<ctrl63>","250

func _physics_process(delta: float) -> void:"
"""""""### Import library""""""

!pip install -r requirements.txt

import ace_lib as ace
import helpful_functions as hf
import pandas as pd
import requests
import plotly.express as px

""""""### Start session
Enter credentials once - they will be saved to local folder and loaded each time""""""

s = ace.start_session()

""""""### Create list of alpha expressions
#### Step 1. Download datsets""""""

datasets_df = hf.get_datasets(s) # by default we load all datasets USA TOP3000 delay 1
datasets_df.head() # DataFrame.head() shows first 5 rows of the dataframe 

datasets_df[
    datasets_df[""id""].str.contains('analyst7', case=False) # &
    # ((datasets_df[""category""] == 'news') | (datasets_df[""category""] == 'analyst'))
]

""""""""""""

# select needed datasets
selected_datasets_df = datasets_df[
    (datasets_df[""delay""] == 1) &
    (datasets_df[""coverage""] > 0.5) & (datasets_df[""coverage""] <= 1) &
    (datasets_df[""fieldCount""] > 0) & (datasets_df[""fieldCount""] < 1500) &
    (datasets_df[""region""] == 'USA') &
    (datasets_df[""universe""] == 'TOP3000') &
    (datasets_df[""userCount""] > 0) & (datasets_df[""userCount""] < 800) &
    (datasets_df[""valueScore""] > 1) & (datasets_df[""valueScore""] < 10) &
     datasets_df[""id""].str.contains('analyst7', case=False) 
    # datasets_df[""name""].str.contains('Actuals', case=False)
    #   &    ((datasets_df[""category""] == 'news') | (datasets_df[""category""] == 'analyst'))
].sort_values(by=['valueScore'], ascending=False)
selected_datasets_df

""""""For demonstration we are picking the dataset with the highest value score, this is not mandatory but definitely a recommended practice""""""

""""""#### Step 2. Select the needed datafields
""""""

dataset_id = selected_datasets_df.id.values.tolist()[0] # create a list of selected datasets ids, our list has only one element
dataset_id

datafields_df = hf.get_datafields(s, dataset_id=dataset_id) # download all fields of dataset news
datafields_df.head()

datafields_df[
    datafields_df[""description""].str.contains('cash flow per share', case=False) # &
    # ((datasets_df[""category""] == 'news') | (datasets_df[""category""] == 'analyst'))
][['id', 'descrip","']]

""""""#### Step 3. Create expression list, using selected datafields
Here is an example: creating expressions that assign weights as per the time series skewness of vector average of the field value""""""

expression_list = [f'''group_zscore(subtract(group_zscore(<act_data>, industry), group_zscore(<est_data>, industry)), industry)'''               
                     for x in datafields_df.id.values.tolist()] # create a list of alpha expressions ts_skewness(vec_avg({x}),120) where x is a datafield id

""""""#### Step 4. Apply generate_alpha function to the expression list
In generate alpha function you can specify region, universe, decay, delay and other simulation settings""""""

#when you send multiple alphas for simulation, please make sure all alphas of a single list should have common settings
#alphas with different settings should be sent in a different list, for instance below list has all alphas with same settings

alpha_list = [ace.generate_alpha(x, region= ""USA"", universe = ""TOP3000"",) for x in expression_list]

alpha_list[0]

len(alpha_list)

""""""This is an example - how alpha actually looks like when you send it to the platform.""""""

""""""### Simulate alpha list, get simulation result

simulate_alpha_list_multi will do a multi-simulation if list of alphas is greater than 10, which is the case here

the returned object will contain simulation results for all alphas as a list""""""

#alpha expressions are sliced to first 10 for demonstration purpose

result = ace.simulate_alpha_list_multi(s, alpha_list)

#we received a list of 10 simulation results since we sent in alpha_list[:10]
len(result)

[ x for x in result if x['alpha_id'] != None ]

""""""__Accessing the result of the first alpha, let's take a look at all the keys of this dictionary__""""""

result[0].keys()

#is_stats key will return a dataframe storing IS summary results

result[1]['is_stats']

#prettify_result function can be used from the helpful_functions library to take a look at IS stats of all the simulated alphas

result_st1 = hf.prettify_result(result, detailed_tests_view=False)
result_st1.head()

""""""### Visualise pnl of an alpha""""""

alpha_pnl = ace.get_alpha_pnl(s, result_st1['alpha_id'][0])
px.line(x = alpha_pnl.index, y = alpha_pnl.Pnl, title=f'<b>alpha_id={hf.make_clickable_alpha_id(alpha_pnl.alpha_id[0])}</b>')\
    .update_layout(xaxis_title=""Date"", yaxis_title=""Pnl"", title_x=0.5)

""""""### Select prospect alphas, that are worth improving (in your opinion)
In this example we are selecting alphas with high fitness, to resimulate it with improved logic""""""

prospect_alphas = result_st1.loc[lambda x: x.fitness>0.2]['expression'].values
prospect_alphas

new_expression_list = [x.replace(r""bucket(rank(cap),range='0,0.1,0.1')"", ""sector"") for x in prospect_alphas]
new_expression_list

""""""### Change the expression - what would you do to improve alpha's results?
<br>Use your own logic to improve the alphas.</br>
<br>Here we will apply **group_rank** to overcome poor weight distribution.</br>""""""


new_expression_list = ['group_rank(' + a + ',sector)' for a in prospect_alphas]
new_expression_list

#generating new simulation data for new expressions

new_alpha_list = [ace.generate_alpha(x, region= ""USA"", universe = ""TOP3000"",) for x in new_expression_list]

new_alpha_list

""""""### Re-simulation""""""

new_result = ace.simulate_alpha_list_multi(s, new_alpha_list)

result_st2 = hf.prettify_result(new_result, clickable_alpha_id=False)
result_st2

""""""#### Compare alphas stats before and after changes:""""""

## We will join before and after dataframes by field

result_st1['field'] = result_st1['expression'].apply(lambda st: st[st.find(""(vec_avg("")+1:st.find("","")]).copy()
result_st2['field'] = result_st2['expression'].apply(lambda st: st[st.find(""(vec_avg("")+1:st.find("","")]).copy()

#merging results before and after improvement

compare_results = pd.merge(result_st1, result_st2, on='field', suffixes=('_before', '_after'))

#selecting column list returned by merging the two alpha results

col_list = ['fitness_before', 'fitness_after','sharpe_before', 'sharpe_after', 'alpha_id_before', 'alpha_id_after',
                 'expression_before', 'expression_after']

compare_results[col_list]\
    .style.format({'alpha_id_before': hf.make_clickable_alpha_id, 'alpha_id_after': hf.make_clickable_alpha_id})

""""""### Check merged alpha performance

run the following code to do a before and after comparison of your merged pool post alpha submission""""""

performance_comparison = ace.performance_comparison(s, result_st2['alpha_id'][0])

""""""### How to submit?

Create a list of submittable alphas - alphas that have no FAIL in is_tests""""""

#to take a look at the combined result of all new alphas

is_tests_df = hf.concat_is_tests(new_result)
is_tests_df.head()

#making a list of failed alphas
failed_alphas = is_tests_df.query('result==""FAIL""')['alpha_id'].unique()

#making a list of passed alphas
passed_alphas = list(set(is_tests_df['alpha_id']).difference(failed_alphas))

print(f'Failed alphas:{failed_alphas}\nPassed alphas:{passed_alphas}')

""""""When you got a list of submittable alphas, you can call function submit_alpha()""""""

#calling submit_alpha on all alphas that have passed the submission tests

submit_result = {alpha_id: submit_alpha(s, alpha_id) for alpha_id in passed_alphas}

#submit_result will have return values from the submit_result function

submit_result

""""""### Library Fuctions.

following are some other functions that you can use for your own analysis

**get_alpha_pnl(s, alpha_id)** - to get the pnl for an alpha

**get_alpha_yearly_stats(s, alpha_id)** - to get yearly statistics for an alpha

**get_self_corr(s, alpha_id)** - to get self correlation results for an alpha

**get_prod_corr(s, alpha_id)** - to get prod correlation results for an alpha

**get_check_submission(s, alpha_id)** - to get check submission result for an alpha

**check_self_corr_test(s, alpha_id)** - to check if alpha passes self correlation test (self_corr<0.7)

**check_prod_corr_test(s, alpha_id)** - to check if alpha passes prod correlation test (prod_corr<0.7)

**perfomance_comparison(s, alpha_id)** - to get the result of performance comparison for an alpha merged performance""""""

",gemini-1.5-flash-002,gpt-4o-2024-08-06,0.0,"tion']
    ",tion
"@extends('bibapp::staff.app')

@section('title', 'Home Page')

@section('content')
    <div class=""card card-flush"">
        <div class=""d-flex flex-column flex-column-fluid"">
            <div class=""row gy-3"">
                <div class=""card-body"">
                    {{-- Staff Dashboard --}}","
                </div>
            </div>
        </div>
    </div>
@endsection
",deepseek-coder-fim,gemini-1.5-flash-002,0.0,"
                    <h1>Staff Dashboard</h1>","
                    <div class=""col-md-6"">
                        <div class=""card card-flush h-md-100"">
                            <div class=""card-header"">
                                <h3 class=""card-title"">Staff Dashboard</h3>
                            </div>
                            <div class=""card-body"">
                                <p>Welcome to the staff dashboard. This is where you can manage your tasks and view your progress.</p>
                            </div>
                        </div>
                    </div>
<CODE>"
"#include <stdio.h>

int factorial(","

int main() {
    int T[50], N, i, j = 0;

    do {
        printf(""N (3-49): "");
        scanf(""%d"", &N);
    } while (N <= 2 || N >= 50);

    for (i = 0; i < N; i++) {
        printf(""T[%d]: "", i);
        scanf(""%d"", &T[i]);
    }

    for (i = 0; i < N; i++) {
        j = 0;
        while (j < i && T[i] != T[j]) {
            j++;
        }
        if (j < i) {
            T[i] = 0;
        }
    }

    int N2 = 0;
    for (i = 0; i < N; i++) {
        if (T[i] != 0) {
            T[N2++] = T[i];
        }
    }

    for (i = N2; i < N; i++) {
        T[i] = 0;
    }

    for (i = 0; i < N; i++) {
        printf(""%d "", T[i]);
    }
    printf(""\n"");

    printf(""nombre de 0: %d\n"", N - N2);

    return 0;
}
",llama-3.1-405b-instruct,claude-3-5-sonnet-20240620,0.0,"int n) {
    if (n == 0 || n == 1) {
        return 1;
    } else {
        return n * factorial(n - 1);
    }","int n) {
    if (n == 0 || n == 1) {
        return 1;
    }
    return n * factorial(n - 1)"
"#number guessing game
",,claude-3-5-sonnet-20240620,codestral-2405,0.0,"
import random

# Generate a random number between 1 and 100
secret_number = random.randint(1, 100)

# Initialize variables
guess = 0
attempts = 0

print(""Welcome to the Number Guessing Game!"")
print(""I'm thinking of a number between 1 and 100."")

# Main game loop
while guess != secret_number:
    # Get user input
    guess = int(input(""Enter your guess: ""))
    attempts += 1

    # Check the guess","
import random"
"from django.conf import settings
from django.contrib.auth.mixins import LoginRequiredMixin, UserPassesTestMixin
from django.contrib.auth.models import User
from django.db.models import Count
from django.http import Http404
from django.shortcuts import get_object_or_404, redirect
from django.urls import reverse, reverse_lazy
from django.utils import timezone
from django.views.generic import (
    CreateView, DeleteView, DetailView, ListView, UpdateView
)

from .forms import CommentForm, EditProfileForm, PostForm
from .models import Category, Comment, Post


def get_filter_posts(
    filter_published=True,
    annotate_comments=True,
    select_related_data=True
):
    posts = Post.objects.filter(
        is_published=True,
        category__is_published=True,
        pub_date__lte=timezone.now()
    )
    if filter_published:
        posts = posts.filter(
            is_published=True,
            category__is_published=True,
            pub_date__lte=timezone.now()
        )
    if annotate_comments:
        posts = posts.annotate(
            comment_count=Count('comments'))

    if select_related_data:
        posts = posts.select_related('author', 'category', 'location')
    return posts.order_by(*Post._meta.ordering)


class OnlyAuthorMixin(UserPassesTestMixin):
    def test_func(self):
        return self.get_object().author == self.request.user


class PostEditMixin(LoginRequiredMixin, OnlyAuthorMixin):
    model = Post
    template_name = 'blog/create.html'
    pk_url_kwarg = 'post_id'


class CommentViewsMixin(LoginRequiredMixin):
    model = Comment
    form_class = CommentForm
    template_name = 'blog/comment.html'
    pk_url_kwarg = 'comment_id'

    def get_success_url(self):
        return reverse(
            'blog:post_detail',
            args=[self.kwargs['post_id']]
        )


class IndexView(ListView):
    model = Post
    template_name = 'blog/index.html'
    context_object_name = 'page_obj'
    paginate_by = settings.POSTS_PER_PAGE
    queryset = get_filter_posts()


class PostDetailView(DetailView):
    model = Post
    template_name = 'blog/detail.html'
    context_object_name = 'post'
    pk_url_kwarg = 'post_id'

    def get_object(self, queryset=None):
        post = super().get_object(queryset=queryset)
        if post.author != self.request.user:
            return get_object_or_404(
                get_filter_posts(filter_published=True),
                pk=self.kwargs[self.pk_url_kwarg]
            )

        return post

    def get_context_data(self, **kwargs):
        context = super().get_context_data(**kwargs)
        context['form'] = CommentForm()
        context['comments'] = self.get_object().comments.all()
        return context

    def post(self, request, *args, **kwargs):
        post = self.get_object()
        form = CommentForm(request.POST)
        if form.is_valid():
            comment = form.save(commit=False)
            comment.post = post
            comment.author = request.user
            comment.save()
            return redirect('post_detail', post_id=post.id)
        return self.render_to_response(self.get_context_data(form=form))


class CategoryPostView(ListView):
    model = Post
    template_name = 'blog/category.html'
    context_object_name = 'post_list'
    paginate_by = settings.POSTS_PER_PAGE

    def get_category(self):
        category = get_object_or_404(
            Category,
            slug=self.kwargs['category_slug'],
            is_published=True
        )
        return category

    def get_queryset(self):
        return get_filter_posts(category.posts",")

    def get_context_data(self, **kwargs):
        context = super().get_context_data(**kwargs)
        context['category'] = self.get_category()
        return context


class PostCreateView(LoginRequiredMixin, CreateView):
    model = Post
    form_class = PostForm
    template_name = 'blog/create.html'

    def form_valid(self, form):
        form.instance.author = self.request.user
        return super().form_valid(form)

    def get_success_url(self):
        return reverse('blog:profile', args=[self.request.user.username])


class PostUpdateView(PostEditMixin, UpdateView):
    form_class = PostForm

    def dispatch(self, request, *args, **kwargs):
        post = self.get_object()
        if request.user != post.author:
            return redirect('blog:post_detail',
                            post_id=kwargs[self.pk_url_kwarg]
                            )
        return super().dispatch(request, *args, **kwargs)

    def get_success_url(self):
        return reverse('blog:post_detail',
                       args=[self.kwargs[self.pk_url_kwarg]]
                       )


class PostDeleteView(PostEditMixin, DeleteView):
    success_url = reverse_lazy('blog:index')


class ProfileView(ListView):
    model = Post
    template_name = 'blog/profile.html'
    context_object_name = 'page_obj'
    paginate_by = settings.POSTS_PER_PAGE

    def get_queryset(self):
        author = get_object_or_404(User, username=self.kwargs['username'])
        if self.request.user == author:
            return author.posts.all()
        return get_filter_posts().filter(author=author)

    def get_context_data(self, **kwargs):
        context = super().get_context_data(**kwargs)
        context['profile'] = get_object_or_404(
            User, username=self.kwargs['username'])
        return context


class ProfileUpdateView(LoginRequiredMixin, UpdateView):
    model = User
    form_class = EditProfileForm
    template_name = 'blog/user.html'

    def get_object(self):
        return self.request.user

    def get_success_url(self):
        return reverse('blog:profile', args=[self.request.user.username])


class CommentCreateView(CommentViewsMixin, CreateView):
    def form_valid(self, form):
        form.instance.post = get_object_or_404(Post, id=self.kwargs['post_id'])
        form.instance.author = self.request.user
        return super().form_valid(form)


class CommentEditView(CommentViewsMixin, OnlyAuthorMixin, UpdateView):
    pass


class CommentDeleteView(CommentViewsMixin, OnlyAuthorMixin, DeleteView):
    pass
",deepseek-coder-fim,gpt-4o-mini-2024-07-18,0.0,.all(),        return get_filter_posts(category=self.get_category()).filter(is_published=True
"import * as vscode from 'vscode';
import { StatisticsViewProvider } from './statisticsView';

// Interface for storing code snippets
interface CodeSnippet {
    id: string;
    content: string;
    isLLMGenerated: boolean;
    timestamp: Date;
    filePath: string;
}

// Global state to store code snippets
let codeSnippets: CodeSnippet[] = [];

function generateUniqueId(): string {
    return Math.random().toString(36).substring(2, 15) + Math.random().toString(36).substring(2, 15);
}

function saveData(context: vscode.ExtensionContext) {
    context.globalState.update('llmCodeSnippets', codeSnippets);
}

function loadData(context: vscode.ExtensionContext) {
    const savedSnippets = context.globalState.get('llmCodeSnippets') as CodeSnippet[] | undefined;
    if (savedSnippets) {
        codeSnippets = savedSnippets;
    }
}

export function activate(context: vscode.ExtensionContext) {
    console.log('LLM Code Usage Tracker is now active');

	loadData(context);

    // Register a command to toggle LLM-generated code
	let toggleLLMCode = vscode.commands.registerCommand('llm-tracker.toggleLLMCode', () => {
		const editor = vscode.window.activeTextEditor;
		if (editor) {
			const selection = editor.selection;
			const text = editor.document.getText(selection);
			
			//","
			if (text) {
				const snippet: CodeSnippet = {
					id: generateUniqueId(),
					content: text,
					isLLMGenerated: true,
					timestamp: new Date(),
					filePath: editor.document.uri.fsPath
				};
				codeSnippets.push(snippet);
				vscode.window.showInformationMessage('Code marked as LLM-generated');
				
				// Highlight the LLM-generated code
				const decoration = vscode.window.createTextEditorDecorationType({
					backgroundColor: 'rgba(65, 105, 225, 0.3)' // Light blue background
				});
				editor.setDecorations(decoration, [selection]);
			}
		}
	});

	const provider = new StatisticsViewProvider(context.extensionUri);
    context.subscriptions.push(
        vscode.window.registerWebviewViewProvider(StatisticsViewProvider.viewType, provider)
    );

   	// Update the showStats command to use the new view
   	let showStats = vscode.commands.registerCommand('llm-tracker.showStats', () => {
		const totalLines = codeSnippets.reduce((acc, snippet) => acc + snippet.content.split('\n').length, 0);
		const llmLines = codeSnippets
			.filter(snippet => snippet.isLLMGenerated)
			.reduce((acc, snippet) => acc + snippet.content.split('\n').length, 0);
		
		const llmPercentage = (llmLines / totalLines * 100).toFixed(2);
		
		provider.updateStats({
			totalLines,
			llmLines,
			llmPercentage
		});
	});

    context.subscriptions.push(toggleLLMCode, showStats);
}

export function deactivate(context: vscode.ExtensionContext) {
	saveData(context);
}

",claude-3-5-sonnet-20241022,qwen-2.5-coder-32b-instruct,1.0,"			if (text) {
				const snippet: CodeSnippet = {","			if (text) {
				const snippet: CodeSnippet = {
					id: generateUniqueId(),
					content: text,
					isLLMGenerated: true,
					timestamp: new Date(),
					filePath: editor.document.uri.fsPath
				};
				codeSnippets.push(snippet);
				vscode.window.showInformationMessage('Code marked as LLM-generated');"
"import 'dart:developer';
import 'dart:io';
import 'package:tuneque/models/screen_type_model.dart';
import 'package:tuneque/presets/storage_keys.dart';
import 'package:get/get.dart';
import 'package:get_storage/get_storage.dart';

abstract class App {
  static String applicationDisplayName = 'TuneQue Token Display';

  static String apiIpAddress = """";
  static RxString deviceName = """".obs;

  static Rxn<ScreenTypeModel> screenTypeRx = Rxn<ScreenTypeModel>();

  static int tokenAlertDuration = 7;

  static int tokenRefreshDuration = 15;

  static setApiIpAddress(String newIpAddress) {
    apiIpAddress = newIpAddress;
    log('ip address assigned $apiIpAddress');
  }

  static saveApiIpAddress(String newIpAddress) {
    final GetStorage storage = GetStorage();
    storage.write(StorageKeys.apiIpAddress, newIpAddress);
    setApiIpAddress(newIpAddress);
    log('ip address saved $apiIpAddress');
  }

  static readIpAddressStored() {
    final GetStorage storage = GetStorage();

    String? savedIpAddress = storage.read(StorageKeys.apiIpAddress);

    if (savedIpAddress != null && savedIpAddress.isNotEmpty) {
      setApiIpAddress(savedIpAddress);
    }
  }

  /*===========Methods related to Device name fetching and Saving==========================*/

  // set and log the Device Name
  static void setDeviceName(String newDeviceName) {
    deviceName.value = newDeviceName;
    log('Device name assigned: $deviceName');
  }

  // save the device name and set it

  static void saveAndSetDeviceName(String newDeviceName) {
    final GetStorage storage = GetStorage();
    storage.write(StorageKeys.deviceName, newDeviceName);
    setDeviceName(newDeviceName);
    log('Device name saved: $deviceName');
  }

  // read the saved device name
  static String? getDeviceNameStored() {
    final GetStorage storage = GetStorage();
    String? savedDeviceName =
        storage.read(StorageKeys.deviceName); // read from storage with the key

    return savedDeviceName;
  }

  
  static String? getDevIpAddress(){
      return ","
  }
 
}
",gpt-4o-mini-2024-07-18,llama-3.1-70b-instruct,0.0,apiIpAddress;,"   final GetStorage storage = GetStorage();
    String? savedIpAddress = storage.read(StorageKeys.devIpAddress);

    if (savedIpAddress != null && savedIpAddress.isNotEmpty) {
      return savedIpAddress;
    "
"<!DOCTYPE html>
<html lang=""en"">
<head>
  <meta charset=""UTF-8"">
  <meta name=""viewport"" content=""width=device-width, initial-scale=1.0"">
  <title>Dot Bypasser</title>
  <link rel=""preconnect"" href=""https://fonts.gstatic.com"" crossorigin>
  <link rel=""stylesheet"" href=""https://fonts.googleapis.com/css2?family=Space+Grotesk&display=swap"">
  <script type=""module"" crossorigin src=""/popup.js""></script>
  <link rel=""modulepreload"" crossorigin href=""/storage.js"">
  <link rel=""stylesheet"" crossorigin href=""/popup.css"">
  <link rel=""stylesheet"" crossorigin href=""/custom.css"">
</head>
<style>
   ","
</style>
<body class=""relative bg-black overflow-x-hidden w-screen min-h-screen grid md:grid-cols-2 gap-4 !p-4 grid-rows-[240px] md:grid-rows-none"">
   <div class=""w-full rounded-xl border-t-stone-700 bg-gradient-to-b from-stone-900/50 to-stone-900/80 border border-stone-800 p-4 backdrop-blur-md"">
      <div class=""flex items-center justify-between border border-stone-700/50 rounded-xl p-3 bg-stone-950/50"">
         <div class=""flex items-center space-x-2 text-zinc-300"">
            <div class=""rounded-full p-2 border border-stone-800/50 bg-stone-900"">
               <svg xmlns=""http://www.w3.org/2000/svg"" viewBox=""0 0 24 24"" fill=""currentColor"" class=""size-6"">
                  <path d=""M3.375 3C2.339 3 1.5 3.84 1.5 4.875v.75c0 1.036.84 1.875 1.875 1.875h17.25c1.035 0 1.875-.84 1.875-1.875v-.75C22.5 3.839 21.66 3 20.625 3H3.375Z"" />
                  <path fill-rule=""evenodd"" d=""m3.087 9 .54 9.176A3 3 0 0 0 6.62 21h10.757a3 3 0 0 0 2.995-2.824L20.913 9H3.087Zm6.163 3.75A.75.75 0 0 1 10 12h4a.75.75 0 0 1 0 1.5h-4a.75.75 0 0 1-.75-.75Z"" clip-rule=""evenodd"" />
               </svg>
            </div>
            <div class=""flex flex-col items-start"">
               <h1 class=""text-lg text-zinc-200"">Logs</h1>
               <span class=""text-zinc-400 text-sm -mt-1 hidden md:block"">Cards will be logged here.</span>
            </div>
         </div>
         <button id=""clear-logs-btn"" class=""w-max group p-1.5 px-3 cursor-pointer rounded-lg text-zinc-300 text-center border border-stone-800/50 bg-stone-900 hover:bg-stone-900/80 hover:border-stone-800 hover:text-zinc-200 duration-300 transition-all flex items-center justify-center space-x-2"">Clear logs</button>
      </div>
      <div id=""logs"" class=""h-32 md:h-0 md:min-h-[95%] text-zinc-400 mb-4 md:mb-0 mt-4 overflow-y-auto text-sm md:text-lg flex flex-col items-center"">
      </div>
   </div>
   <div class=""grid gap-4 order-2"">
      <div class=""w-full order-1 relative md:order-1 rounded-xl border-t-stone-700 bg-gradient-to-b from-stone-900/50 to-stone-900/80 border border-stone-800 p-4 py-6 md:py-0 backdrop-blur-md flex flex-col items-center justify-center"">
         <div class=""flex flex-col items-end w-fit"">
            <h1 class=""text-4xl md:text-7xl text-transparent bg-clip-text bg-gradient-to-r from-purple-500 to-pink-500 font-bold p-1"">Dot Bypasser</h1>
            <span class=""text-zinc-300 text-lg md:text-2xl md:pt-2 text-right"">By <a class=""text-blue-400 hover:text-blue-600"" href=""https://telegram.me/dot_d_o_t"">Akash</a></span>
         </div>
         <div class=""absolute px-4 bottom-5 w-full flex justify-between"">
            <!-- <span class=""text-emerald-500 text-md md:text-4xl pt-2"">Online</span> -->
            <label class=""inline-flex items-center cursor-pointer relative top-[6px]"">
               <input id=""toggle-btn"" type=""checkbox"" value="""" class=""sr-only peer"" checked>
               <div class=""relative w-11 h-6 md:w-[90px] md:h-[50px] rounded-full bg-zinc-500 peer-checked:after:translate-x-full after:content-[''] after:absolute after:top-0.5 md:after:top-[5px] after:start-[2px] md:after:start-[5px] after:bg-white after:rounded-full after:h-5 after:w-5 md:after:h-[40px] md:after:w-[40px] after:transition-all peer-checked:bg-purple-500""></div>
            </label>
            <span id=""version"" class=""text-zinc-300 text-md md:text-4xl pt-2"">v1.0.0</span>
         </div>
      </div>
      <div class=""w-full row-start-[span_2] md:order-1 order-2 rounded-xl border-t-stone-700 bg-gradient-to-b from-stone-900/50 to-stone-900/80 border border-stone-800 p-4 backdrop-blur-md flex flex-col items-center justify-center"">
         <label>
           <input id=""autoclick-btn"" type=""checkbox"" value="""" class=""sr-only peer"" disabled>
           <svg xmlns=""http://www.w3.org/2000/svg"" viewBox=""0 0 24 24"" fill=""currentColor"" class=""absolute right-0 top-0 m-2.5 size-10 md:size-16 text-zinc-300 peer-disabled:text-rose-600 md:peer-hover:text-emerald-200 peer-checked:!text-emerald-500 transition-transform ease-in-out duration-1000"" id=""autoclick-icon"">
  <path fill-rule=""evenodd"" d=""M17.303 5.197A7.5 7.5 0 0 0 6.697 15.803a.75.75 0 0 1-1.061 1.061A9 9 0 1 1 21 10.5a.75.75 0 0 1-1.5 0c0-1.92-.732-3.839-2.197-5.303Zm-2.121 2.121a4.5 4.5 0 0 0-6.364 6.364.75.75 0 1 1-1.06 1.06A6 6 0 1 1 18 10.5a.75.75 0 0 1-1.5 0c0-1.153-.44-2.303-1.318-3.182Zm-3.634 1.314a.75.75 0 0 1 .82.311l5.228 7.917a.75.75 0 0 1-.777 1.148l-2.097-.43 1.045 3.9a.75.75 0 0 1-1.45.388l-1.044-3.899-1.601 1.42a.75.75 0 0 1-1.247-.606l.569-9.47a.75.75 0 0 1 .554-.68Z"" clip-rule=""evenodd""></path>
             </svg>
           </label>
         <div class=""flex flex-col md:justify-center md:w-4/5 space-y-2 md:space-y-4"">
            <textarea type=""text"" id=""bin-input"" class=""h-16 w-full bg-zinc-950/50 focus:bg-zinc-950/80 focus:duration-300 duration-300 backdrop-blur-xl rounded-lg outline-none border border-zinc-800/80 p-2 focus:pl-3 px-3 items-center text-left md:text-2xl text-gray-300 blur-[4px] placeholder-shown:blur-none focus:blur-none resize-none"" placeholder=""Enter BINs""></textarea>
            <textarea type=""text"" id=""proxy-input"" class=""h-16 w-full bg-zinc-950/50 focus:bg-zinc-950/80 focus:duration-300 duration-300 backdrop-blur-xl rounded-lg outline-none border border-zinc-800/80 p-2 focus:pl-3 px-3 items-center text-left md:text-2xl text-gray-300  blur-[4px] placeholder-shown:blur-none focus:blur-none resize-none"" placeholder=""Enter Proxies (optional)""></textarea>
            <button id=""save-btn"" type=""submit"" class=""w-full md:h-16 group p-1.5 px-3 cursor-pointer rounded-lg text-center md:text-4xl border border-stone-800/50 bg-stone-900 text-zinc-300 hover:text-zinc-200 hover:bg-stone-900/80 hover:border-stone-800 duration-300 transition-all flex items-center justify-center space-x-2"">
              <p>Save</p>
              <svg xmlns=""http://www.w3.org/2000/svg"" viewBox=""0 0 24 24"" fill=""currentColor"" class=""size-6 md:size-9 transition-transform ease-in-out duration-1000"" id=""rocket-icon"">
  <path fill-rule=""evenodd"" d=""M9.315 7.584C12.195 3.883 16.695 1.5 21.75 1.5a.75.75 0 0 1 .75.75c0 5.056-2.383 9.555-6.084 12.436A6.75 6.75 0 0 1 9.75 22.5a.75.75 0 0 1-.75-.75v-4.131A15.838 15.838 0 0 1 6.382 15H2.25a.75.75 0 0 1-.75-.75 6.75 6.75 0 0 1 7.815-6.666ZM15 6.75a2.25 2.25 0 1 0 0 4.5 2.25 2.25 0 0 0 0-4.5Z"" clip-rule=""evenodd"" />
  <path d=""M5.26 17.242a.75.75 0 1 0-.897-1.203 5.243 5.243 0 0 0-2.05 5.022.75.75 0 0 0 .625.627 5.243 5.243 0 0 0 5.022-2.051.75.75 0 1 0-1.202-.897 3.744 3.744 0 0 1-3.008 1.51c0-1.23.592-2.323 1.51-3.008Z"" />
              </svg>
            </button>
            <button id=""settings-btn"" type=""submit"" class=""w-full md:h-16 group p-1.5 px-3 cursor-pointer rounded-lg text-center md:text-4xl border border-stone-800/50 bg-stone-900 text-zinc-300 hover:text-zinc-200 hover:bg-stone-900/80 hover:border-stone-800 duration-300 transition-all flex items-center justify-center space-x-2"">
              <p>Settings</p>
              <svg xmlns=""http://www.w3.org/2000/svg"" viewBox=""0 0 24 24"" fill=""currentColor"" class=""size-6 md:size-9"">
  <path fill-rule=""evenodd"" d=""M11.828 2.25c-.916 0-1.699.663-1.85 1.567l-.091.549a.798.798 0 0 1-.517.608 7.45 7.45 0 0 0-.478.198.798.798 0 0 1-.796-.064l-.453-.324a1.875 1.875 0 0 0-2.416.2l-.243.243a1.875 1.875 0 0 0-.2 2.416l.324.453a.798.798 0 0 1 .064.796 7.448 7.448 0 0 0-.198.478.798.798 0 0 1-.608.517l-.55.092a1.875 1.875 0 0 0-1.566 1.849v.344c0 .916.663 1.699 1.567 1.85l.549.091c.281.047.508.25.608.517.06.162.127.321.198.478a.798.798 0 0 1-.064.796l-.324.453a1.875 1.875 0 0 0 .2 2.416l.243.243c.648.648 1.67.733 2.416.2l.453-.324a.798.798 0 0 1 .796-.064c.157.071.316.137.478.198.267.1.47.327.517.608l.092.55c.15.903.932 1.566 1.849 1.566h.344c.916 0 1.699-.663 1.85-1.567l.091-.549a.798.798 0 0 1 .517-.608 7.52 7.52 0 0 0 .478-.198.798.798 0 0 1 .796.064l.453.324a1.875 1.875 0 0 0 2.416-.2l.243-.243c.648-.648.733-1.67.2-2.416l-.324-.453a.798.798 0 0 1-.064-.796c.071-.157.137-.316.198-.478.1-.267.327-.47.608-.517l.55-.091a1.875 1.875 0 0 0 1.566-1.85v-.344c0-.916-.663-1.699-1.567-1.85l-.549-.091a.798.798 0 0 1-.608-.517 7.507 7.507 0 0 0-.198-.478.798.798 0 0 1 .064-.796l.324-.453a1.875 1.875 0 0 0-.2-2.416l-.243-.243a1.875 1.875 0 0 0-2.416-.2l-.453.324a.798.798 0 0 1-.796.064 7.462 7.462 0 0 0-.478-.198.798.798 0 0 1-.517-.608l-.091-.55a1.875 1.875 0 0 0-1.85-1.566h-.344ZM12 15.75a3.75 3.75 0 1 0 0-7.5 3.75 3.75 0 0 0 0 7.5Z"" clip-rule=""evenodd"" />
              </svg>
            </button>
         </div>
      </div>
   </div>
</body>

</html>



",gemini-1.5-pro-002,claude-3-5-sonnet-20240620,0.0,"body {
      font-family: 'Space Grotesk', sans-serif;
   }","body {
      font-family: 'Space Grotesk', sans-serif;
      background-color: #000;
      color: #fff;
      margin: 0;
      padding: 0;
   }

   ::-webkit-scrollbar {
      width: 10px;
   }

   ::-webkit-scrollbar-track {
      background: #0f0f0f;
   }

   ::-webkit-scrollbar-thumb {
      background: #888;
      border-radius: 5px;
   }"
"# GUI calculator
import tkinter as tk
",,codestral-2405,llama-3.1-405b-instruct,0.0,"from tkinter import messagebox

def add_digit(digit):
    value = calc.get()
    if value[0]=='0':
        value = value[1:]
    calc.delete(0, tk.END)
    calc.insert(0, value+digit)

def add_operation(operation):
    value = calc.get()
    if value[-1] in '-+/*':
        value = value[:-1]
    elif '+' in value or '-' in value or '/' in value or '*' in value:
        calculate()
        value = calc.get()
    calc.delete(0, tk.END)
    calc.insert(0, value+operation)

def calculate():
    value = calc.get()","from tkinter import messagebox

class Calculator:
    def __init__(self):
        self.window = tk.Tk()
        self.window.title(""Calculator"")
        self.entry = tk.Entry(self.window)
        self.entry.grid(row=0, column=0, columnspan=4)
        self.create_buttons()

    def create_buttons(self):
        buttons = [
            '7', '8', '9', '/',
            '4', '5', '6', '*',
            '1', '2', '3', '-',
            '0', '.', '=', '+'
        ]
        row_val = 1
        col_val = 0

        for button in buttons:
"
"/* Base styles */
body { 
    font-family: Arial, sans-serif; 
    background-image: url('../images/fond.jpeg');
    background-size: 50% 30%;
    background-repeat: repeat;
}

/* Layout */
.container { 
    display: flex; 
    flex-direction: row; 
    max-width: 1200px; 
    margin: 0 auto; 
}

/* Sidebar */
.sidebar { 
    background-color: #82a0aa; 
    color: white; 
    padding: 20px; 
    width: 30%; 
}

.sidebar img { 
    width: 100px; 
    border-radius: 50%; 
}

.sidebar a {
    color: white;
    text-decoration: none;
}

.sidebar a:hover {
    text-decoration: underline;
}

/* Main content */
.main-content { 
    background: rgba(255, 255, 255, 0.9);
    padding: 20px; 
    width: 70%; 
}

/* Typography */
h1, h2 { 
    color: #005580; 
}

.section { 
    margin-bottom: 30px; 
}

.section h2 { 
    border-bottom: 2px solid #005580; 
    padding-bottom: 5px; 
}

/* Publication sections */
.publication-category {
    margin-bottom: 25px;
}

.experience-item {
    margin-bottom: 20px;
}

/* Media tabs */
.media-tabs {
    display: flex;
    gap: 10px;
    margin-bottom: 20px;
    padding: 0.5rem;
    background: #f5f5f5;
    border-radius: 8px;
}

.media-tab {
    padding: 12px 24px;
    background: transparent;
    border: none;
    cursor: pointer;
    transition: all 0.3s ease;
    border-radius: 6px;
    font-weight: 500;
    color: #4a5568;
    position: relative;
}

.media-tab:hover {
    background: rgba(0, 85, 128, 0.1);
}

.media-tab.active {
    background: #005580;
    color: white;
    box-shadow: 0 4px 6px rgba(0, 85, 128, 0.2);
}

/* Media content animation */
.media-content {
    display: none;
}

.media-content.active {
    display: block;
    animation: fadeIn 0.3s ease-in;
}

@keyframes fadeIn {
    from { opacity: 0; }
    to { opacity: 1; }
}

/* Video components */
.video-container { 
    position: relative; 
    padding-bottom: 56.25%; 
    height: 0; 
    margin-bottom: 20px;
}

.video-container iframe { 
    position: absolute; 
    top: 0; 
    left: 0; 
    width: 100%; 
    height: 100%; 
}

.video-grid {
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
    gap: 20px;
    margin: 20px 0;
}

.video-title {
    font-weight: bold;
    margin: 10px 0;
    color: #005580;
}

/* Radio components */
.radio-item {
    border: 1px solid #e5e7eb;
    border-radius: 8px;
    padding: 1rem;
    transition: all 0.3s ease;
    margin-bottom: 0.5rem;
    background: white;
}

.radio-item:hover {
    transform: translateY(-2px);
    box-shadow: 0 8px 16px rgba(0, 0, 0, 0.1);
    border-color: #005580;
}

.radio-info {
    display: flex;
    align-items: center;
    gap: 1rem;
}

.radio-date {
    font-size: 0.875rem;
    color: #6b7280;
    min-width: 120px;
}

.radio-type {
    padding: 0.25rem 0.75rem;
    border-radius: 16px;
    font-size: 0.75rem;
    font-weight: 500;
    min-width: 100px;
    text-align: center;
}

.radio-title {
    font-weight: 500;
    color: #1a202c;
    flex-grow: 1;
}

/* Radio type colors */
.radio-type.table-ronde { 
    background-color: #bfdbfe;
    color: #1e40af;
}

.radio-type.interview { 
    background-color: #e9d5ff; 
    color: #6b21a8;
}

.radio-type.reportages { 
    background-color: #bbf7d0;
    color: #166534;
}

/* Player container */
.player-container {
    display: none;
    margin-top: 0.5rem;
    margin-left: 120px;
    max-width: 600px;
    opacity: 0;
    transition: opacity 0.3s ease;
}

.radio-item:hover .player-container {
    display: block;
    opacity: 1;
}

/* Activities section */
.unlock-button {
    background: #005580;
    color: white;
    border: none;
    padding: 5px 10px;
    border-radius: 3px;
    cursor: pointer;
    margin-left: 10px;
    font-size: 0.8em;
}

.unlock-button:hover {
    background: #003c5a;
}

.activities-category {
    margin-bottom: 20px;
}

.activities-category h3 {
    color: #005580;
    margin-bottom: 10px;
}

.activities-category ul {
    list-style-type: none;
    padding-left: 20px;
}

.activities-category li {
    margin-bottom: 8px;
    position: relative;
}

.activities-category li:before {
    content: ""•"";
    color: #005580;
    position: absolute;
    left: -15px;
}

/* Accessibility */
.media-tab:focus {
    outline: 2px solid #005580;
    outline-offset: 2px;
}

.visually-hidden {
    position: absolute;
    width: 1px;
    height: 1px;
    padding: 0;
    margin: -1px;
    overflow: hidden;
    clip: rect(0, 0, 0, 0);
    border: 0;
}

/* Responsive design */
@media (max-width: 768px) {
    .container {
        flex-direction: column;
    }
    
    .sidebar, .main-content {
        width: 100%;
    }
    
    .video-grid {
        grid-template-columns: 1fr;
    }
}

/* Print styles */
@media print {
    .media-tabs, .video-container, .radio-item iframe {
        display: none;
    }
    
    body {
        font-size: 12pt;
    }
    
    .container {
        display: block;
    }
    
    .sidebar {
        background: none;
        color: black;
        width: 100%;
    }
    
    a {
        color: black;
        text-decoration: none;
    }
}
.social-icons img, .social-icons i {
    width: 24px;
    height: 24px;
    margin-right: 5x;
    transition: transform 1.3s;
}

.social-icons a:hover img, .social-icons a:hover i {
    transform: scale(1.4);
}
.sidebar {
    display: flex;
    align-items: center;
    margin-right: 0px;
    padd","
}

.photo-name {
    text-align: center;
}

.social-icons {
    margin-left: 0px;
    display: right;
    flex-direction: column;
    justify-content: center;
}

.social-icons a {
    margin-bottom: 0px; /* Espacement vertical entre les icônes */
}",claude-3-5-sonnet-20240620,gpt-4o-2024-08-06,0.0,"ing: 20px;
    flex-direction: column;",ing: 20px;
"from django.db import models

","
",claude-3-5-sonnet-20240620,gemini-1.5-pro-002,0.0,"class Book(models.Model):
    title = models.CharField(max_length=200)
    author = models.CharField(max_length=100)
    publication_date = models.DateField()
    isbn = models.CharField(max_length=13, unique=True)
    price = models.DecimalField(max_digits=6, decimal_places=2)

    def __str__(self):
        return self.title",from django.db import models
"import java.util.concurrent.atomic.{AtomicReferenceArray,AtomicReference,AtomicInteger}

class GrowableArray[A : scala.reflect.ClassTag](_capacity: Int){
    private class SliceNode(size: Int) {
        val datum = new AtomicReferenceArray[A](size);
        val next = new AtomicReference[Node](null);
    }

    /**
      * Abstraction: L(null) = <>;
      *              L(node) = node.datum ++ L(node.next) if node != null
      */
    private val head = new SliceNode(_capacity);

    // finds the node containing the index i
    // returns the total number of entries including the node, and the node itself
    // if not found, returns (capacity, last node)
    def findNode(i: Int): (Int, Node) = {
        var node = head
        var total = head.size
        while (total <= i && node.next.get != null) {
            node = node.next.get
            total += node.size
        }
        (total, node)
    } 

    // Get the value in position i
    def apply(i: Int) : A = {
        val (total, node) = findNode(i)
        if (i >= total) { // lin. pt.
            null
        } else {
            val offset = node.size - (total - i);
            node.datum.get(offset) // lin. pt.
        }
    }

    // Update the value in position i with value a
    def update(i: Int, a: A) : Unit = {
        val (total, node) = findNode(i);
        if (i>=total) {
            val desiredCapacity = max(i+1, total * 2)
            val nextSlice = new SliceNode(desiredCapacity - total)
            node.next.compareAndSet(null, nextSlice)
            update(i, a)
        } else {
            ","
        }
    }
}",claude-3-5-sonnet-20240620,codestral-2405,0.0,"val offset = node.size - (total - i);
            node.datum.set(offset, a) // lin. pt.","val offset = node.size - (total - i);
             node.datum.set(offset, a)
        }
    }"
"export const add = (a: number, b: number): number => a + b;
export const divide = (a: number, b: number): number => a / b;


function fib",,llama-3.1-70b-instruct,gemini-1.5-flash-002,1.0,"  function fibonacci(n: number): number {
    if (n <= 1) {
      return n;
    } else {
      return fibonacci(n - 1) + fibonacci(n - 2);
    }
  }","onacci(n: number): number {
  if (n <= 1) {
    return n;
  }
  return fibonacci(n - 1) + fibonacci(n - 2);
}
export default fibonacci;"
"#Hackerrank: Classes: Dealing with complex numbers
import math

class Complex(object):
    def __init__(self, real, imaginary):
        self.real = real
        self.imaginary = imaginary

    def __add__(self, no):
        real = self.real + no.real
        imaginary = self.imaginary + no.imaginary
        return Complex(real, imaginary)
        
    def __sub__(self, no):
        real = self.real - no.real
        imaginary = self.imaginary - no.imaginary
        return Complex(real, imaginary)
        
    def __mul__(self, no):
        real = self.real * no.real - self.imaginary * no.imaginary
        imaginary = self.real * no.imaginary + self.imaginary * no.real
        return Complex(real, imaginary)

    def __truediv__(self, no):
        r = no.real**2 + no.imaginary**2
        real = (self.real * no.real + self.imaginary * no.imaginary) / r

    def mod(self):
        ","

    def __str__(self):
        if self.imaginary == 0:
            result = ""%.2f+0.00i"" % (self.real)
        elif self.real == 0:
            if self.imaginary >= 0:
                result = ""0.00+%.2fi"" % (self.imaginary)
            else:
                result = ""0.00-%.2fi"" % (abs(self.imaginary))
        elif self.imaginary > 0:
            result = ""%.2f+%.2fi"" % (self.real, self.imaginary)
        else:
            result = ""%.2f-%.2fi"" % (self.real, abs(self.imaginary))
        return result

if __name__ == '__main__':
    c = map(float, input().split())
    d = map(float, input().split())
    x = Complex(*c)
    y = Complex(*d)
    print(*map(str, [x+y, x-y, x*y, x/y, x.mod(), y.mod()]), sep='\n')",gemini-1.5-pro-002,deepseek-coder-fim,0.0,"imaginary = (self.imaginary * no.real - self.real * no.imaginary) / r
        return Complex(real, imaginary)

    def mod(self):","return Complex(math.sqrt(self.real**2 + self.imaginary**2), 0)"
"# Requirements Gathering Template

| Ticket Title  | x   |
| ------------- | --- |
| Ticket Number | x   |
| Date          | x   |
| Prepared By   | x   |

## 1. Project Overview

### 1.1 Project Purpose
Provide a brief description of the project\'s purpose and goals.

### 1.2 Background
Explain any background information that is relevant to understanding the
project.

## 2. Stakeholder Identification

### 2.1 Primary Stakeholders
List the primary stakeholders involved in this project and their roles.

| Stakeholder | Role / Position | Contact |
| ----------- | --------------- | ------- |
| x           | x               | x       |

## 3. Requirements

### 3.1 Functional Requirements

**Instructions:** For each requirement, please provide as much detail as
possible.

| Requirement ID | Description | Priority | Acceptance Criteria | Notes |
|---|---|---|---|---|
| x | x | x | x | x |

### 3.2 Non-Functional Requirements

**Instructions:** Outline non-functional requirements that may impact
system performance, security, usability, etc.

| Requirement ID | Description | Priority | Acceptance Criteria | Notes |
|---|---|---|---|---|
| x | x | x | x | x |

## 4. User Stories

Provide user stories to illustrate how different users
will interact with the system.

| User Story ID | As a (role) | I want (feature) | So that (benefit) |
| --- | --- | --- | --- |
| x | x | x | x |

## 5. Use Cases

Describe use cases that detail the interaction between
users and the system.

  <!-- -------------------------------------------------------------------------------
  Use Case  Use Case   Actors   Precondition   Basic   Alternate   Postcondition
     ID       Name                             Flow      Flow     
  -------- ---------- -------- -------------- ------- ----------- ---------------
                                                                  

                                                                  

                                                                  

                                                                  
  ------------------------------------------------------------------------------- -->

<!-- In Markdown format / syntax instead: -->

| ","

**6. Constraints and Assumptions**

**6.1 Constraints:**\
List any limitations or constraints that must be considered in the
project.

  -----------------------------------------------------------------------
              Constraint                         Description
  ---------------------------------- ------------------------------------
                                     

                                     

                                     

                                     
  -----------------------------------------------------------------------

**6.2 Assumptions:**\
List any assumptions that are being made regarding the requirements or
stakeholders.

  -----------------------------------------------------------------------
               Assumption              Description
  ------------------------------------ ----------------------------------
                                       

                                       

                                       

                                       
  -----------------------------------------------------------------------

**7. Glossary**

**Instructions:** Define any terms or acronyms that may be unfamiliar to
stakeholders.

  -----------------------------------------------------------------------
             Term            Definition
  -------------------------- --------------------------------------------
                             

                             

                             

                             

                             
  -----------------------------------------------------------------------

**8. Additional Notes**

Provide any additional information or comments that are relevant to the
requirements gathering process.

**9. Follow-Up Actions**

Outline the next steps to finalize the requirements.

  -----------------------------------------------------------------------
        Action Item               Assigned To              Due Date
  ------------------------ ------------------------- --------------------
                                                     

                                                     

                                                     

                                                     

                                                     
  -----------------------------------------------------------------------
",codestral-2405,llama-3.1-70b-instruct,0.0," Use Case ID  |  Use Case Name  |  Actors  |  Precondition  |  Basic Flow  |  Alternate Flow  |  Postcondition  |
|---|---|---|---|---|---|---|
| x | x | x | x | x | x | x |















































"," <!-- -------------------------------------------------------------------------------
  Use Case  Use Case   Actors   Precondition   Basic   Alternate   Postcondition
     ID       Name                             Flow      Flow     
  -------- ---------- -------- -------------- ------- ----------- ---------------
                                                                  
                                                                  
                                                                  
                                                                  
  ------------------------------------------------------------------------------- -->
  <!-- In Markdown format / syntax instead: -->
| "
"import discord
import ollama

client = discord.Client()

@client.event
async def on_ready():
    print(f'We have logged in as {client.user}')
    
@client.event
async def on_message(message):
    if message.author == client.user:
        return
    try:","
    
client.run('YOUR_TOKEN')",codestral-2405,claude-3-5-sonnet-20241022,0.0,"
        response = ollama.generate(message.content)
        await message.channel.send(response)
    except Exception as e:
        await message.channel.send(f'An error occurred: {e}')","
        if message.content.startswith('!ask'):
            question = message.content[5:]
            response = ollama.chat(model='llama2', messages=[{'role': 'user', 'content': question}])
            await message.channel.send(response['message']['content'])
    except Exception as e:
        await message.channel.send(f""An error occurred: {str(e)}"""
"import {ApiError} from ""../utils/ApiError.js""
import {ApiResponse} from ""../utils/ApiResponse.js""
import {asyncHandler} from ""../utils/asyncHandler.js""
import   {User}   from ""@repo/db/src/modules/User.moduls.js""
import { options } from ""../utils/option.js""


const signup = asyncHandler(async(req, res)=>{

const {username, password, role} = req.body

    if([username, password].some((feild)=> feild?.trim()=== """")){
        throw new ApiError(400, ""username or password feild s empty"")
    }

    try {
        const existedUser = await User.findOne({username})
        console.log(existedUser , ""SUCCESS"");
        
    } catch (error) {
        console.log(Error, ""FAILED TO CONEECT TO THE USER"");
        
    }   

    // if(!existedUser){
    //     throw new ApiError(400, ""username already is tekken"")
    // }


    const user = await User.create({
        username, 
        password,
        role,
    })

    if(!user){
        throw new ApiError(509, ""sorry new user registation has failed"")                    
    }

    const loggeredUser = await User.findById(user._id).select(""-password -token"")

    return res
    .status(200)
    .json(
        new ApiResponse(200, loggeredUser, ""new user registed succeffully"")
    )
})


const genrateLogInToken = async (userId) =>{
   try {
     const user = await User.findById(userId)
 
     const token = user.generateToken()
 
     user.token = token 
     await user.save({validateBeforeSave : false})
     return {token}
 
   } catch (error) {
        console.log(`${err} faild generating token `);
        
   }

}



const signin = asyncHandler(async (req, res)=>{
    const {username, password} = req.body

    if([username, password].some((feild)=> feild?.trim()=== """")){
        throw new ApiError(400, ""username or password feild s empty"")
    }

    const user =  await User.findOne({username})

    if(!user){
        throw new ApiError(400, ""username is not exists in our DataBase"")
    }
    const hashedpassword = user.isPsswordCurrect(password)

    if(!hashedpassword){
        throw new ApiError(400, ""wrong credential"")
    }

    const {token} = await genrateLogInToken(user._id)

    const loggedinUser =  User.findById(user._id).select(""-password "")
    
    return res
    .status(200)
    .cookie(""token"", token, options)
    .json(
        new ApiResponse(200, {user : loggedinUser, token}, ""user logged in successfully"")
    )

})

const getAvater = asyncHandler(async(req, res)=>{

    const avatars =  await User.findMany(avatar)
    
    return res
    .status(200)
    .json(
        new ApiResponse(200, 
            {avatars.map((","))}
        )
    )

})




export {
    signup,
    signin,

}",claude-3-5-sonnet-20240620,gpt-4o-2024-08-06,0.0,"avatar) => ({
                id: avatar._id,
                url: avatar.url
            ","                avatar => avatar.url
            )"
"import psycopg2
from models.review import Review

class MovieRepository:
    def __init__(self):
        self.conn: psycopg2.extensions.connection

    def query_movie(self, orderby: str, sort:str):
        query = """"
        if orderby:
            if orderby == ""title"":
                query += ""ORDER BY title ""
            elif orderby == ""creation_year"":
                query += ""ORDER BY creation_year ""
            else:
                query += ""ORDER BY score ""

            if sort == ""ASC"":
                query += ""ASC ""
            else:
                query += ""DESC ""
        
        query += """"""
                OFFSET %s 
                LIMIT %s;                
                """"""
        return query

    def get_movie_page(self, offset: int, limit: int, orderby: str = """", sort: str = ""ASC"") -> list[tuple]:
        with self.conn.cursor() as cursor:
            query = """"""
                    WITH scores AS
                    (SELECT movies.id as id, 
                    CASE 
                        WHEN AVG(score) is NULL THEN CAST(0 AS float) 
                        ELSE CAST(AVG(score) as float) 
                    END as score
                    FROM movies
                    LEFT JOIN reviews ON movies.id = reviews.movie_id
                    GROUP BY movies.id)

                    select movies.id, title, creation_year, score
                    FROM movies 
                    LEFT JOIN scores ON movies.id = scores.id
                    """"""
            
            query += self.query_movie(orderby, sort)
            cursor.execute(query, (offset, limit))
            return cursor.fetchall()
        

    def get_movies_by_name(self, name: str, offset: int, limit: int, orderby: str = """", sort: str = ""ASC"") -> list[tuple]:
        with self.conn.cursor() as cursor:
            name = f""%{name}%""
            query = """"""
                    WITH scores AS
                    (SELECT movies.id as id, 
                    CASE 
                        WHEN AVG(score) is NULL THEN CAST(0 AS float) 
                        ELSE CAST(AVG(score) as float) 
                    END as score
                    FROM movies
                    LEFT JOIN reviews ON movies.id = reviews.movie_id
                    GROUP BY movies.id)

                    select movies.id, title, creation_year, score
                    FROM movies 
                    LEFT JOIN scores ON movies.id = scores.id
                    WHERE LOWER(title) LIKE %s 
                    """"""
            
            query += self.query_movie(orderby, sort)
            cursor.execute(query, (name, offset, limit))
            return cursor.fetchall()
        

    def get_movies_filter_year(self, year_start: int, year_end: int, offset: int, limit: int, orderby: str = """", sort: str = ""ASC""):
        with self.conn.cursor() as cursor:
            query = """"""
                    WITH scores AS
                    (SELECT movies.id as id, 
                    CASE 
                        WHEN AVG(score) is NULL THEN CAST(0 AS float) 
                        ELSE CAST(AVG(score) as float) 
                    END as score
                    FROM movies
                    LEFT JOIN reviews ON movies.id = reviews.movie_id
                    GROUP BY movies.id)

                    select movies.id, title, creation_year, score
                    FROM movies 
                    LEFT JOIN scores ON movies.id = scores.id
                    WHERE creation_year BETWEEN %s AND %s
                    """"""
            
            query += self.query_movie(orderby, sort)
            cursor.execute(query, (year_start, year_end, offset, limit))
            return cursor.fetchall()
        

    def get_movies_filter_score(self, min_score: int, offset: int, limit: int, orderby: str = """", sort: str = ""ASC""):
        with self.conn.cursor() as cursor:
            query = """"""
                    WITH scores AS
                    (SELECT movies.id as id, 
                    CASE 
                        WHEN AVG(score) is NULL THEN CAST(0 AS float) 
                        ELSE CAST(AVG(score) as float) 
                    END as score
                    FROM movies
                    LEFT JOIN reviews ON movies.id = reviews.movie_id
                    GROUP BY movies.id)

                    select movies.id, title, creation_year, score
                    FROM movies 
                    LEFT JOIN scores ON movies.id = scores.id
                    WHERE score >= %s
                    """"""
            
            query += self.query_movie(orderby, sort)
            cursor.execute(query, (min_score, offset, limit))
            return cursor.fetchall()
        

    def get_movies_filter_category(self, category_id: str, offset: int, limit: int, orderby: str = """", sort: str = ""ASC""):
        with self.conn.cursor() as cursor:
            query = """"""
                    WITH scores AS
                    (SELECT movies.id as id, 
                    CASE 
                        WHEN AVG(score) is NULL THEN CAST(0 AS float) 
                        ELSE CAST(AVG(score) as float) 
                    END as score
                    FROM movies
                    LEFT JOIN reviews ON movies.id = reviews.movie_id
                    GROUP BY movies.id)

                    select movies.id, title, creation_year, score
                    FROM movies 
                    LEFT JOIN scores ON movies.id = scores.id
                    JOIN movieCategories ON movieCategories.category_id = %s AND movies.id = movieCategories.movie_id
                    """"""
            
            query += self.query_movie(orderby, sort)
            cursor.execute(query, (category_id, offset, limit))
            return cursor.fetchall()
        
    
    def get_movie(self, id) -> tuple:
        with self.conn.cursor() as cursor:
            query = """"""
                    WITH scores AS
                    (SELECT movies.id as id, 
                    CASE 
                        WHEN AVG(score) is NULL THEN CAST(0 AS float) 
                        ELSE CAST(AVG(score) as float) 
                    END as score
                    FROM movies
                    LEFT JOIN reviews ON movies.id = reviews.movie_id
                    GROUP BY movies.id)

                    SELECT movies   .id, title, creation_year, duration, score FROM movies JOIN scores ON scores.id = movies.id where movies.id = %s 
                    """"""
            cursor.execute(query, (id))
            return cursor.fetchone()
        

    # Viewing

    def add_viewing(self, user_id, movie_id):
       with self.conn.cursor() as cursor:
            query = ""INSERT INTO ViewingHistory (User_id, Movie_id, Watch_date, Duration) VALUES (%s, %s, NOW(), %s);""
            cursor.execute(query, (user_id, movie_id, 1337))

    # Reviews

    def add_review(self, review: Review):
        with self.conn.cursor() as cursor:
            query = ""INSERT INTO reviews (Movie_id, User_id, Score, Review_text, created_at) VALUES (%s, %s, %s, %s, NOW());""
            cursor.execute(query, (review.movie_id, review.user_id, review.score, review.review_text))

    # write function to get reviews","
        

    
    # CATEGORIES

    def get_categories(self) -> list[tuple]:
        with self.conn.cursor() as cursor:
            query = ""select * from categories;""
            cursor.execute(query)
            return cursor.fetchall()
        

    
    # ACTORS

    def get_movie_actors(self, id) -> list[tuple]:
        with self.conn.cursor() as cursor:
            query = ""SELECT id, first_name, last_name, birth_date FROM actors JOIN movieActors ON movie_id = %s AND id = actor_id""
            cursor.execute(query, (id))
            return cursor.fetchall()
        


    # DIRECTORS

    def get_movie_directors(self, id) -> list[tuple]:
        with self.conn.cursor() as cursor:
            query = ""SELECT id, first_name, last_name, birth_date FROM directors JOIN movieDirectors ON movie_id = %s AND id = director_id""
            cursor.execute(query, (id))
            return cursor.fetchall()
",gemini-1.5-flash-002,claude-3-5-sonnet-20241022,0.0,"    def get_reviews(self, movie_id) -> list[tuple]:
        with self.conn.cursor() as cursor:
            query = ""SELECT * FROM reviews WHERE Movie_id = %s;""
            cursor.execute(query, (movie_id,))
            return cursor.fetchall()","    def get_reviews(self, movie_id) -> list[tuple]:
        with self.conn.cursor() as cursor:
            query = """"""
                    SELECT reviews.id, reviews.score, reviews.review_text, reviews.created_at, users.username
                    FROM reviews
                    JOIN users ON reviews.user_id = users.id
                    WHERE movie_id = %s
                    ORDER BY created_at DESC;
                    """"""
            cursor.execute(query, (movie_id,))
            return cursor.fetchall()"
"/* eslint-disable react-hooks/exhaustive-deps */
import { useState, useRef, useCallback, useEffect, Dispatch, SetStateAction, useMemo, RefObject, MutableRefObject } from 'react';
import { useToast } from '@/components/ui/use-toast';
import { CensorFilter, CustomCensorFilter, ToCensorItem } from '@/lib/types';
import {  censorFiltersInfo } from '@/data';
import { useMediaQuery } from 'react-responsive';
import { ToastActionElement, ToastProps } from '@/components/ui/toast';
import anime from 'animejs';


type ToasterToast = ToastProps & {
  id: string
  title?: React.ReactNode
  description?: React.ReactNode
  action?: ToastActionElement
}

interface VideoEditorState {
  
  videoFile: File | null;
  setVideoFile: React.Dispatch<React.SetStateAction<File | null>>;
  videoRef: React.RefObject<HTMLVideoElement>;
  logs: string[];
  setLogs: React.Dispatch<React.SetStateAction<string[]>>;
  uploadingToServer: boolean;
  setUploadingToServer: React.Dispatch<React.SetStateAction<boolean>>;
  fileReady: boolean;
  setFileReady: React.Dispatch<React.SetStateAction<boolean>>;
  censorFilters: CensorFilter[],
  setCensorFilters: Dispatch<SetStateAction<CensorFilter[]>>,
  removeNudity: boolean;
  setRemoveNudity: React.Dispatch<React.SetStateAction<boolean>>;
  removeExplicit: boolean;
  setRemoveExplicit: React.Dispatch<React.SetStateAction<boolean>>;
  customFilters: CustomCensorFilter[];
  setCustomFilters: React.Dispatch<React.SetStateAction<CustomCensorFilter[]>>;
  censorData: ToCensorItem[];
  setCensorData: React.Dispatch<React.SetStateAction<ToCensorItem[]>>;
  newFilterInput: string;
  setNewFilterInput: React.Dispatch<React.SetStateAction<string>>;
  showNewFilterInput: boolean;
  setShowNewFilterInput: React.Dispatch<React.SetStateAction<boolean>>;
  videoUrl: string | null;
  setVideoUrl: React.Dispatch<React.SetStateAction<string | null>>;
  uploadType: 'file' | 'url' | 'youtube' | 'drive' | 'dropbox';
  setUploadType: React.Dispatch<React.SetStateAction<'file' | 'url' | 'youtube' | 'drive'| 'dropbox'>>;
  urlInput: string;
  setUrlInput: React.Dispatch<React.SetStateAction<string>>;
  youtubeInput: string;
  setYoutubeInput: React.Dispatch<React.SetStateAction<string>>;
  driveInput: string;
  setDriveInput: React.Dispatch<React.SetStateAction<string>>;
  activeTab: string;
  setActiveTab: React.Dispatch<React.SetStateAction<string>>;
  newFilterInputRef: React.RefObject<HTMLInputElement | null>;
  projectId: string | null;
  setProjectId: React.Dispatch<React.SetStateAction<string | null>>;
  projectName: string;
  setProjectName: React.Dispatch<React.SetStateAction<string>>;
  videoAspectRatio: number;
  setVideoAspectRatio: React.Dispatch<React.SetStateAction<number>>;
  exportFileName: string;
  setExportFileName: React.Dispatch<React.SetStateAction<string>>;
  exportFormat: string;
  setExportFormat: React.Dispatch<React.SetStateAction<string>>;
  videoOrientation: 'portrait' | 'landscape';
  setVideoOrientation: React.Dispatch<React.SetStateAction<'portrait' | 'landscape'>>;
  thumbnails: string[];
  setThumbnails: Dispatch<SetStateAction<string[]>>;
  projectSaved: boolean;
  setProjectSaved: React.Dispatch<React.SetStateAction<boolean>>;
  isExporting: boolean;
  setIsExporting: React.Dispatch<React.SetStateAction<boolean>>;
  showSubtitles: boolean;
  setShowSubtitles: React.Dispatch<React.SetStateAction<boolean>>;
  subtitleSettings: { sourceLanguage: string; outputLanguage: string };
  setSubtitleSettings: React.Dispatch<React.SetStateAction<{ sourceLanguage: string; outputLanguage: string }>>;
  showImageFilter: boolean;
  setShowImageFilter: React.Dispatch<React.SetStateAction<boolean>>;
  imageFilterStyle: string;
  setImageFilterStyle: React.Dispatch<React.SetStateAction<string>>;
  videoName: string | null;
  setVideoName: React.Dispatch<React.SetStateAction<string | null>>;
  videoType: string | null;
  setVideoType: React.Dispatch<React.SetStateAction<string | null>>;
  videoStorageURL: string | null;
  setVideoStorageURL: React.Dispatch<React.SetStateAction<string | null>>;
  videoDownloadURL: string | null;
  setVideoDownloadURL: React.Dispatch<React.SetStateAction<string | null>>;
  uploadProgress: number;
  setUploadProgress: React.Dispatch<React.SetStateAction<number>>;
  analyzeProgress: number;
  setAnalyzeProgress: React.Dispatch<React.SetStateAction<number>>;
  exportProgress: number;
  setExportProgress: React.Dispatch<React.SetStateAction<number>>;
  isAnalysing: boolean;
  transitionTime: number;
  setTransitionTime: React.Dispatch<React.SetStateAction<number>>;

  panelSize: number;
  setPanelSize: React.Dispatch<React.SetStateAction<number>>;
  isMobile: boolean;
  isTablet: boolean;
  isDesktop: boolean;
  expandedMobileMenuItem: string | null;
  setExpandedMobileMenuItem: React.Dispatch<React.SetStateAction<string | null>>;
  isSaving: boolean;
  setIsSaving: React.Dispatch<React.SetStateAction<boolean>>;
  isLoading: boolean;
  setIsLoading: React.Dispatch<React.SetStateAction<boolean>>;
  toast: ({ ...props }: any) => {
    id: string;
    dismiss: () => void;
    update: (props: ToasterToast) => void;
}
  handleResize: (size: number) => void;
  handleAddCustomFilter: () => void;
  handleNewFilterChange: (e: React.ChangeEvent<HTMLInputElement>) => void;
  handleNewFilterSubmit: (e: React.FormEvent) => void;
  handleCustomFilterChange: (index: number, field: 'checked' | 'muteAudio' | 'removeVideo' | 'label' | 'description') => void;
  handleRemoveCustomFilter: (index: number) => void;
  handleTimelineClick: (time: number) => void;
  handleTimeUpdate: () => void;
  handleCheckboxChange: (setter: React.Dispatch<React.SetStateAction<boolean>>) => (e: React.ChangeEvent<HTMLInputElement>) => void;
  handleUpload:(input: string, resolution?: string) => Promise<void>;
  handleFileChange:(files: File[]) => Promise<void> ;
  handleAnalysis:() => Promise<void> ;
  handleExport:() => Promise<void> ;
  handleSaveProject:() => Promise<void>;
  toggleMobileExpand:(value: string) => void;
  canvasRef: React.RefObject<HTMLCanvasElement | null>; 
  playerCurrentTime: number;
  setPlayerCurrentTime: React.Dispatch<React.SetStateAction<number>>;
  reloadPlayer: number;
  modeExpress: boolean;
  setModeExpress: React.Dispatch<React.SetStateAction<boolean>>;
  expressStep: number;
  setExpressStep: React.Dispatch<React.SetStateAction<number>>;
  transcriptLanguage: string;
  setTranscriptLanguage: React.Dispatch<React.SetStateAction<string>>;
  transcriptEnabled: boolean;
  setTranscriptEnabled: React.Dispatch<React.SetStateAction<boolean>>;
  transcriptGenerated: boolean;
  setTranscriptGenerated: React.Dispatch<React.SetStateAction<boolean>>;
  translateToLanguage: string;
  setTranslateToLanguage: React.Dispatch<React.SetStateAction<string>>;
  transcriptPrompt: string;
  setTranscriptPrompt: React.Dispatch<React.SetStateAction<string>>;
  transcriptUrl: string;
  setTranscriptUrl: React.Dispatch<React.SetStateAction<string>>;
  transcriptInProgress: boolean;
  setTranscriptInProgress: React.Dispatch<React.SetStateAction<boolean>>;
  generateTranscript: (transcriptLanguage: string) => Promise<void>
  isUploadingToServer: boolean;
  setIsUploadingToServer: React.Dispatch<React.SetStateAction<boolean>>;
  isUploading: boolean;
  setIsUploading: React.Dispatch<React.SetStateAction<boolean>>;
  isCensorEnabled: boolean;
  setIsCensorEnabled: React.Dispatch<React.SetStateAction<boolean>>;
  isFadingIn: boolean;
  isFadingOut: boolean;
  fadeOpacity: number;
  fadeOverlayRef: RefObject<HTMLDivElement>;
  currentAnimationRef: MutableRefObject<anime.AnimeInstance | null>;
  isAnimatingRef: MutableRefObject<boolean>;
  showVideoEffect: boolean;
  setShowVideoEffect: React.Dispatch<React.SetStateAction<boolean>>;
  videoEffectId: string;
  setVideoEffectId: React.Dispatch<React.SetStateAction<string>>;
  handleCensorFilterChange: (index: number, field: ""checked"" | ""muteAudio"" | ""removeVideo"" | ""intensity"") => (value: boolean | number) => void;
  handleAddFilter: (filterName: string) => void;
  handleRemoveCensorFilter: (index: number) => void;
  handleIsCensorEnabled: (checked: boolean) => void;
}

const useVideoEditor = (initialProjectId?: string): VideoEditorState => {
  const [censorData, setCensorData] = useState<ToCensorItem[]>([]);
  const { toast} = useToast();
  const [videoFile, setVideoFile] = useState<File | null>(null);
  const videoRef = useRef<HTMLVideoElement>(null);
  const canvasRef = useRef<HTMLCanvasElement>(null);
  const [logs, setLogs] = useState<string[]>([]);
  const [uploadingToServer, setUploadingToServer] = useState(false);
  const [fileReady, setFileReady] = useState(false);

  const [censorFilters, setCensorFilters] = useState<CensorFilter[]>(
    censorFiltersInfo.slice(0, 10).map(filter => ({
      ...filter,
      checked: false,
      muteAudio: filter.muteAudio || false,
      removeVideo:  true,
      intensity: 5
    }))
  );
  const [isSaving, setIsSaving] = useState(false);
  const [customFilters, setCustomFilters] = useState<CustomCensorFilter[]>([]);
  const [newFilterInput, setNewFilterInput] = useState<string>('');
  const [showNewFilterInput, setShowNewFilterInput] = useState<boolean>(false);
  const [videoUrl, setVideoUrl] = useState<string | null>(null);
  const [uploadType, setUploadType] = useState
    <'file' | 'url' | 'youtube' | 'drive' | 'dropbox'
  >('file');
  const [urlInput, setUrlInput] = useState('');
  const [youtubeInput, setYoutubeInput] = useState('');
  const [driveInput, setDriveInput] = useState('');
  const [activeTab, setActiveTab] = useState('upload');
  const newFilterInputRef = useRef<HTMLInputElement>(null);
  const [projectId, setProjectId] = useState<string | null>(
    initialProjectId || null
  );
  const [projectName, setProjectName] = useState<string>(
    `Untitled ${new Date().toLocaleDateString()}`
  );

  const [videoAspectRatio, setVideoAspectRatio] = useState(16 / 9);
  const [exportFileName, setExportFileName] = useState('censored_video');
  const [exportFormat, setExportFormat] = useState('720p');
  const [videoOrientation, setVideoOrientation] = useState
    <'portrait' | 'landscape'
  >('landscape');

  const [thumbnails, setThumbnails] = useState<string[]>([]);
  const [projectSaved, setProjectSaved] = useState(
    initialProjectId ? true : false
  );

  const [showSubtitles, setShowSubtitles] = useState(false);
  const [subtitleSettings, setSubtitleSettings] = useState({
    sourceLanguage: 'en',
    outputLanguage: 'en',
  });
  const [showImageFilter, setShowImageFilter] = useState(false);
  const [imageFilterStyle, setImageFilterStyle] = useState('');

  const [videoName, setVideoName] = useState<string | null>(null);
  const [videoType, setVideoType] = useState<string | null>(null);
  const [videoStorageURL, setVideoStorageURL] = useState<string | null>(null);
  const [videoDownloadURL, setVideoDownloadURL] = useState<string | null>(null);

  const [uploadProgress, setUploadProgress] = useState(0);
  const [analyzeProgress, setAnalyzeProgress] = useState(0);
  const [exportProgress, setExportProgress] = useState(0);

  const [panelSize, setPanelSize] = useState(80)

  const isMobile = useMediaQuery({ maxWidth: 767 });
  const isTablet = useMediaQuery({ minWidth: 768, maxWidth: 1023 });
  const isDesktop = useMediaQuery({ minWidth: 1024 });

  const [expandedMobileMenuItem, setExpandedMobileMenuItem] = useState
    <string | null
  >(null);

  const [isLoading, setIsLoading] = useState(true);

  const [transitionTime, setTransitionTime] = useState(1);

  const [playerCurrentTime, setPlayerCurrentTime] = useState(0);
  
  const [isExporting, setIsExporting] = useState(false);

  const [reloadPlayer, setReloadPlayer] = useState(0);
  
  const [isAnalysing, setIsAnalysing] = useState(false);

  const [isExportingVideo, setIsExportingVideo] = useState(false);

  const [modeExpress, setModeExpress] = useState(false);

  const [expressStep, setExpressStep] = useState(0);

  const [transcriptLanguage, setTranscriptLanguage] = useState('automatic');

  const [transcriptEnabled, setTranscriptEnabled] = useState(false);

  const [transcriptGenerated, setTranscriptGenerated] = useState(false);

  const [transcriptInProgress, setTranscriptInProgress] = useState(false);

  const [translateToLanguage, setTranslateToLanguage] = useState("""");

  const [transcriptPrompt, setTranscriptPrompt] = useState("""");

  const [transcriptUrl, setTranscriptUrl] = useState("""");

  const [removeExplicit, setRemoveExplicit] = useState(false);

  const [removeNudity, setRemoveNudity] = useState(false);
  const [isUploading, setIsUploading] = useState(false);
  const [isUploadingToServer, setIsUploadingToServer] = useState(false);
  const [isCensorEnabled, setIsCensorEnabled] = useState(true);

  const [isFadingOut, setIsFadingOut] = useState(false);
  const [isFadingIn, setIsFadingIn] = useState(false);
  const [fadeOpacity, setFadeOpacity] = useState(0);
  const fadeOverlayRef = useRef<HTMLDivElement>(null);
  const currentAnimationRef = useRef<anime.AnimeInstance | null>(null);
  const isAnimatingRef = useRef(false);
  const [showVideoEffect, setShowVideoEffect] = useState(false);
  const [videoEffectId, setVideoEffectId] = useState("""");
    

  const handleResize = (size: number) => {
    setPanelSize(size);
  };

  const handleAddCustomFilter = () => {
    setShowNewFilterInput(true);
  };

  const handleNewFilterChange = useCallback(
    (e: React.ChangeEvent<HTMLInputElement>) => {
      setNewFilterInput(e.target.value);
    },
    []
  );

  const handleNewFilterSubmit = useCallback(
    (e: React.FormEvent) => {
      e.preventDefault();
      if (newFilterInput.trim()) {
        setCustomFilters((prevFilters) => [
          ...prevFilters,
          {
            label: newFilterInput.trim(),
            checked: true,
            muteAudio: false,
            removeVideo: true,
            intensity: 5,
          },
        ]);
        setNewFilterInput('');
        setShowNewFilterInput(false);
      }
    },
    [newFilterInput]
  );

  const handleCustomFilterChange = useCallback(
    (index: number, field: 'checked' | 'muteAudio' | 'removeVideo' | 'label' | 'description') => {
      setCustomFilters((prevFilters) =>
        prevFilters.map((filter, i) =>
          i === index ? { ...filter, [field]: !filter[field] } : filter
        )
      );
    },
    []
  );

  const handleRemoveCustomFilter = (index: number) => {
    if (
      window.confirm(
        `Are you sure you want to remove the ""${customFilters[index].label}"" filter?`
      )
    ) {
      setCustomFilters(customFilters.filter((_, i) => i !== index));
    }
  };

  const handleCensorFilterChange = (
    index: number, 
    field: ""checked"" | ""muteAudio"" | ""removeVideo"" | ""intensity""
  ) => (value: boolean | number) => {
    setCensorFilters(prev => 
      prev.map((filter, i) => 
        i === index ? { ...filter, [field]: value } : filter
      )
    );
  };

  const handleAddFilter = (filterName: string) => {
    const newFilter = {
      ...censorFiltersInfo.find(f => f.label === filterName),
      checked: true,
      muteAudio: false,
      removeVideo: true,
      intensity: 5
    } as CensorFilter;

    setCensorFilters(prev => [...prev, newFilter]);
    
  };

  const handleRemoveCensorFilter = (index: number) => {
    setCensorFilters(prev => prev.filter((_, i) => i !== index));
  };

  const handleIsCensorEnabled = (checked: boolean)=> {
    setIsCensorEnabled(checked);
  }

  const handleTimelineClick = (time: number) => {
    if (videoRef.current) {
      videoRef.current.currentTime = time;
      videoRef.current.play();
    }
  };

  const fadeTransition = async (skipToTime: number) => {
    if (!fadeOverlayRef.current || !videoRef.current) return;
    const video = videoRef.current;

    // Cancel any ongoing animations
    if (currentAnimationRef.current) {
      currentAnimationRef.current.pause();
      currentAnimationRef.current = null;
    }

    // Set flag to indicate animation in progress
    isAnimatingRef.current = true;

    // Fade out
    currentAnimationRef.current = anime({
      targets: fadeOverlayRef.current,
      opacity: [{ value: 0 }, { value: 1 }],
      duration: transitionTime * 1000,
      easing: 'easeInOutQuad',
      begin: () => {
        fadeOverlayRef.current!.style.display = 'block';
      }
    });

    // Wait for fade out to complete
    await currentAnimationRef.current?.finished;

    // Skip to new time
    video.currentTime = skipToTime;

    // Small delay to ensure the skip has completed
    await new Promise(resolve => setTimeout(resolve, 50));

    // Fade in
    if (isAnimatingRef.current) { // Check if we haven't started a new transition
      currentAnimationRef.current = anime({
        targets: fadeOverlayRef.current,
        opacity: [{ value: 1 }, { value: 0 }],
        duration: transitionTime * 1000,
        easing: 'easeInOutQuad',
        complete: () => {
          if (fadeOverlayRef.current) {
            fadeOverlayRef.current.style.display = 'none';
          }
          isAnimatingRef.current = false;
        }
      });
    }
  };

  const handleTimeUpdate = () => {
    if (!videoRef.current || !fadeOverlayRef.current) return;
    const video = videoRef.current;
    const currentTime = video.currentTime;
  
    if (censorData.length === 0 || !isCensorEnabled) return;
    let shouldMute = false;
    let shouldSkip = false;
    let skipToTime = 0;
  
    for (const segment of censorData) {
      const isWithinSegment = currentTime >= segment.start && currentTime < segment.end;
  
      if (!isWithinSegment) continue;

      if (
        censorFilters.some((filter, index) =>
          filter.checked && (
            segment.detectedFilters.some((detectedFilter) => detectedFilter.censorId === filter.censorId))
        ) ||
        customFilters.some((filter, index) =>
          filter.checked && filter.removeVideo && segment.detectedFilters.some((detectedFilter) => detectedFilter.censorId === filter.censorId))
        )
       {
        shouldSkip = true;
        skipToTime = segment.end;
        break;
      }
  
      if (
        ((censorFilters.some((filter, index) =>
        filter.checked && filter.muteAudio && segment.detectedFilters.some((detectedFilter) => detectedFilter.censorId === filter.censorId)))) ||
        customFilters.some((filter, index) =>
          filter.checked && filter.muteAudio && segment.detectedFilters.some((detectedFilter) => detectedFilter.censorId === filter.censorId))
      ) {
        shouldMute = true;
      }
    }
  
    video.muted = shouldMute;
  
    if (shouldSkip && !video.seeking && !isAnimatingRef.current) {
      fadeTransition(skipToTime);
    }
  };

  

  const handleCheckboxChange = (
    setter: React.Dispatch<React.SetStateAction<boolean>>
  ) => {
    return (e: React.ChangeEvent<HTMLInputElement>) => {
      setter(e.target.checked);
    };
  };

  const handleAnalysis = async () => {
    if (!videoFile && !videoUrl) {
      console.error(""No video available for processing."");
      setLogs((prevLogs) => [...prevLogs, ""Please select a video...""]);
      return;
    }
    setIsAnalysing(true);
    setLogs((prevLogs) => [...prevLogs, ""Starting file analysis...""]);

    
    const filePath = videoUrl;
    
    const bodyData = {
      projectId,
      filePath,
      mimeType: videoType ?? (videoFile ? videoFile.type : ""video/mp4""),
      censorFilters: censorFilters,
      customFilters: customFilters.map((filter) => ({
        name: filter.label,
        checked: filter.checked,
        muteAudio: filter.muteAudio,
        removeVideo: filter.removeVideo,
        intensity: filter.intensity,
      })),
    };

    try {
      console.log(""POST to Gemini API.."");
      const res = await fetch(""/api/gemini"", {
        method: ""POST"",
        headers: {
          ""Content-Type"": ""application/json"",
        },
        body: JSON.stringify(bodyData),
      });
      setLogs((prevLogs) => [...prevLogs, ""File uploaded. Processing...""]);
      const data = await res.json();

      // Log the entire response to understand its structure
      console.log(""Full API response:"", data);

      // Safely access the response data

      console.log(""Full API response:"", data);
      const responseText =
        data?.response?.candidates?.[0]?.content?.parts?.[0]?.text;

      if (responseText) {
        try {
          const parsedResponse = JSON.parse(responseText);
          console.log(""Parsed response:"", parsedResponse);

          if (parsedResponse.toCensor) {
            setCensorData(parsedResponse.toCensor);
            setLogs((prevLogs) => [...prevLogs, ""Processing complete.""]);
            handleSaveProject();
            console.log(""CensorData: "", parsedResponse.toCensor);
            setActiveTab(""export""); // Switch to export tab after analysis
          } else {
            console.error(""toCensor array not found in the parsed response"");
            setLogs((prevLogs) => [
              ...prevLogs,
              ""Error: toCensor data not found in response"",
            ]);
          }
          setIsAnalysing(false);
          if(modeExpress){
            setExpressStep(2);
          }
        } catch (parseError) {
          console.error(""Error parsing response:"", parseError);
          setIsAnalysing(false);
          setLogs((prevLogs) => [...prevLogs, ""Error parsing API response""]);
        }
      } else {
        console.error(""Expected response structure not found"");
        setIsAnalysing(false);
        setLogs((prevLogs) => [
          ...prevLogs,
          ""Error: Unexpected API response structure"",
        ]);
      }
    } catch (error) {
      console.error(""API request error:"", error);
      setIsAnalysing(false);
      setLogs((prevLogs) => [
        ...prevLogs,
        ""An error occurred during processing."",
      ]);
    }
  };

  const handleExport = async () => {
    if (!videoUrl) {
        console.error(""No video URL available for exporting."");
        setLogs((prevLogs) => [...prevLogs, ""Please select a video to export...""]);
        return;
    }
    let imgFilter = imageFilterStyle;
    setIsExporting(true);
    setLogs((prevLogs) => [...prevLogs, ""Starting export...""]);
    setUploadingToServer(true);

    if (!showImageFilter) {
        imgFilter = """";
    }

    const exportData = {
        fileUrl: videoUrl,
        censorData: JSON.stringify(censorData),
        censorFilters,
        customFilters,
        exportFileName,
        exportFormat,
        videoOrientation,
        imgFilter: imageFilterStyle,
        transitionTime,
    };
    console.log(""imageFilterS"", imageFilterStyle);
    try {
        console.log(""Sending export request..."");
        const response = await fetch(`${process.env.NEXT_PUBLIC_PYTHON_SERVER_URL}/api/export`, {
            method: ""POST"",
            headers: {
                'Content-Type': 'application/json',
            },
            body: JSON.stringify(exportData)
        });

        console.log(""Export response status:"", response.status);
        if (!response.ok) {
            throw new Error(`HTTP error! status: ${response.status}`);
        }

        const result = await response.json();
        console.log(""Export result:"", result);

        if (result.status === 'success') {
            setLogs((prevLogs) => [...prevLogs, `Export complete. Preparing download... ${result.file}`]);
           
            
            console.log(""Initiating download..."");
            const downloadUrl = `${process.env.NEXT_PUBLIC_PYTHON_SERVER_URL}/api/download/${result.file}`;
            console.log(""Download URL:"", downloadUrl);
            setVideoDownloadURL(downloadUrl);
            
            const exportedFileResponse = await fetch(downloadUrl);
            
            console.log(""Download response status:"", exportedFileResponse.status);
            if (exportedFileResponse.ok) {
                const blob = await exportedFileResponse.blob();
                console.log(""Blob size:"", blob.size);
                const url = window.URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.style.display = 'none';
                a.href = url;
                a.download = result.file;
                document.body.appendChild(a);
                a.click();
                window.URL.revokeObjectURL(url);
                setLogs((prevLogs) => [...prevLogs, ""Export complete. File downloaded.""]);
                handleSaveProject();
            } else {
                console.error(""Download response not OK:"", await exportedFileResponse.text());
                throw new Error(`Download failed. Status: ${exportedFileResponse.status}`);
            }
            setIsExporting(false);
        } else {
          setIsExporting(false);
          throw new Error(result.message || 'Export failed');
            
        }
    } catch (error) {
      setIsExporting(false);
        console.error(""Export/download error:"", error);
        setLogs((prevLogs) => [...prevLogs, `Export/download failed. Please try again: ${error}`]);
    } finally {
      setIsExporting(false);
      setUploadingToServer(false);
    }
};

  const handleFileChange = async (files: File[]) => {
    const file = files?.[0];
    if (file) {
      setUploadType(""file"");
      setVideoFile(file);
    } else {
      console.error(""No file selected."");
    }
  };


// Wrap handleUpload with useCallback
const handleUpload = 
  async (input: string, resolution?: string, accessToken?: string) => {
    setIsUploading(true);
    setLogs((prevLogs) => [...prevLogs, ""Starting upload...""]);

    try {
      let formData = new FormData();

      switch (uploadType) {
        case ""file"":
          if (!videoFile) {
            setLogs((prevLogs) => [...prevLogs, ""Please select a file...""]);
            throw new Error(""No file selected"");
          }
          formData.append(""file"", videoFile);
          break;
        case ""url"":
          formData.append(""directUrl"", input);
          break;
        case ""youtube"":
          formData.append(""youtubeUrl"", input);
          formData.append(""resolution"", resolution || ""720"");
          break;
        case ""drive"":
          if (accessToken) {
            formData.append(""driveFileId"", input);
            formData.append(""accessToken"", accessToken);
          } else {
            throw new Error(""No accessToken"");
          }
          break;
        case ""dropbox"":
          formData.append(""dropboxUrl"", input);
          break;
      }

      if (projectId) {
        formData.append(""projectId"", projectId);
      }

      const response = await fetch(`${process.env.NEXT_PUBLIC_PYTHON_SERVER_URL}/api/upload`, {
        method: ""POST"",
        body: formData,
      });

      if (response.ok) {
        const data = await response.json();
        setProjectId(data.projectId);
        setThumbnails([]);
        setThumbnails(data.thumbnails);
        setVideoUrl(`${process.env.NEXT_PUBLIC_PYTHON_SERVER_URL}${data.videoUrl}`);
        setVideoName(data.videoName);
        setVideoType(data.fileType);
        setLogs((prevLogs) => [...prevLogs, ""Upload successful""]);
        setReloadPlayer((prev) => prev + 1);
        setActiveTab(""censor"");
        if(modeExpress){
          setExpressStep(1);
        }
      } else {
        throw new Error(""Upload failed"");
      }
    } catch (error) {
      console.error(""Upload failed:"", error);
      setLogs((prevLogs) => [...prevLogs, `Upload failed: ${error}`]);
    } finally{
      setIsUploading(false);
    }
  }
  
;


  const handleSaveProject = useCallback(async () => {
    if (!videoFile && !videoUrl) {
      setIsSaving(false);
      setLogs((prevLogs) => [
        ...prevLogs,
        ""Cannot save: No video has been loaded."",
      ]);
      toast({
        title: ""Save failed"",
        description: ""Please load a video before saving the project."",
        variant: ""destructive"",
      });
      return;
    }

    const projectData = {
      id: projectId,
      name: projectName,
      censorFilters,
      imageFilterStyle,
      videoEffectId,
      transitionTime,
      customFilters,
      showImageFilter,
      transcriptUrl,
      isTranscriptEnabled: transcriptEnabled,
      transcriptLanguage,
      translateToLanguage,
      transcriptPrompt,
      showVideoEffect,
      videoMetaData: {
        url: videoUrl,
        name: videoName,
        type: videoType,
        storageURL: videoStorageURL,
        downloadURL: videoDownloadURL,
        toCensorData: censorData,
      },
    };

    try {
      setIsSaving(true);
      const response = await fetch(""/api/project/save"", {
        method: ""POST"",
        headers: {
          ""Content-Type"": ""application/json"",
        },
        body: JSON.stringify(projectData),
      });

      if (response.ok) {
        const data = await response.json();
        
        setLogs((prevLogs) => [...prevLogs, ""Project saved successfully.""]);
        setProjectSaved(true);
        toast({
          title: ""Success"",
          description: ""Project saved successfully."",
        });
      } else {
        throw new Error(""Failed to save project"");
      }
    } catch (error) {
      console.error(""Save project error:"", error);
      setLogs((prevLogs) => [...prevLogs, ""Failed to save project.""]);
      toast({
        title: ""Save failed"",
        description: ""An error occurred while saving the project."",
        variant: ""destructive"",
      });
    } finally {
      setIsSaving(false);
    }
  }, [videoFile, videoUrl, projectId, projectName, censorFilters, imageFilterStyle, transitionTime, customFilters, videoName, videoType, videoStorageURL, videoDownloadURL, censorData, transcriptUrl, transcriptEnabled,"," toast]);

  const generateTranscript = async (transcriptLanguage: string) => {
    if (!videoUrl || !transcriptEnabled) return;
    try {
        setTranscriptInProgress(true);
        setLogs((prevLogs) => [...prevLogs, ""Generating transcript...""]);

        // if (!projectId) {
        //     await handleSaveProject();
        // }
        const payload = {
            fileUrl: videoUrl,
            language: transcriptLanguage,
            translate: translateToLanguage !== '' ? translateToLanguage : false,
            prompt: transcriptPrompt
        };

        const response = await fetch(`${process.env.NEXT_PUBLIC_PYTHON_SERVER_URL}/api/transcript`, {
            method: ""POST"",
            headers: {
                'Content-Type': 'application/json'
            },
            body: JSON.stringify(payload),
        });
        if (response.ok) {
            const data = await response.json();
            console.log(""srtFile "", data.srtFile)
            setTranscriptUrl(data.srtFile);
            setTranscriptGenerated(true);
            handleSaveProject();
            setLogs((prevLogs) => [...prevLogs, ""Transcript generated successfully.""]);
            setTranscriptInProgress(false);
        } else {
            setLogs((prevLogs) => [...prevLogs, ""Failed to generate transcript.""]);
            setTranscriptInProgress(false);
            throw new Error(""Failed to generate transcript"");
        }
    } catch (error) {
        setLogs((prevLogs) => [...prevLogs, ""Failed to generate transcript.""]);
        console.error(""Failed to generate transcript:"", error);
    } finally {
        setTranscriptInProgress(false);
    }
};


  const toggleMobileExpand = (value: string) => {
    setExpandedMobileMenuItem((prev) => (prev === value ? null : value));
  };

  return {
    censorData,
    setCensorData,
    videoFile,
    setVideoFile,
    videoRef,
    logs,
    setLogs,
    uploadingToServer,
    setUploadingToServer,
    fileReady,
    setFileReady,
    censorFilters,
    setCensorFilters,
    removeNudity,
    setRemoveNudity,
    removeExplicit,
    setRemoveExplicit,
    customFilters,
    setCustomFilters,
    newFilterInput,
    setNewFilterInput,
    showNewFilterInput,
    setShowNewFilterInput,
    videoUrl,
    setVideoUrl,
    uploadType,
    setUploadType,
    urlInput,
    setUrlInput,
    youtubeInput,
    setYoutubeInput,
    driveInput,
    setDriveInput,
    activeTab,
    setActiveTab,
    newFilterInputRef,
    projectId,
    setProjectId,
    projectName,
    setProjectName,
    videoAspectRatio,
    setVideoAspectRatio,
    exportFileName,
    setExportFileName,
    exportFormat,
    setExportFormat,
    videoOrientation,
    setVideoOrientation,
    thumbnails,
    setThumbnails,
    projectSaved,
    setProjectSaved,
    showSubtitles,
    setShowSubtitles,
    subtitleSettings,
    setSubtitleSettings,
    showImageFilter,
    setShowImageFilter,
    imageFilterStyle,
    setImageFilterStyle,
    videoName,
    setVideoName,
    videoType,
    setVideoType,
    videoStorageURL,
    setVideoStorageURL,
    videoDownloadURL,
    setVideoDownloadURL,
    uploadProgress,
    setUploadProgress,
    analyzeProgress,
    setAnalyzeProgress,
    exportProgress,
    setExportProgress,
    isExporting,
    setIsExporting,
    transitionTime,
    setTransitionTime,
    panelSize,
    setPanelSize,
    isMobile,
    isTablet,
    isDesktop,
    expandedMobileMenuItem,
    setExpandedMobileMenuItem,
    isLoading,
    setIsLoading,
    toast,
    handleResize,
    handleAddCustomFilter,
    handleNewFilterChange,
    handleNewFilterSubmit,
    handleCustomFilterChange,
    handleRemoveCustomFilter,
    handleTimelineClick,
    handleTimeUpdate,
    handleCheckboxChange,
    handleUpload,
    handleFileChange,
    isAnalysing,
    handleExport,
    handleAnalysis,
    handleSaveProject,
    toggleMobileExpand,
    canvasRef,
    playerCurrentTime,
    setPlayerCurrentTime,
    reloadPlayer,
    modeExpress,
    setModeExpress,
    expressStep,
    setExpressStep,
    transcriptLanguage,
    setTranscriptLanguage,
    transcriptEnabled,
    setTranscriptEnabled,
    transcriptGenerated,
    setTranscriptGenerated,
    setTranscriptPrompt,
    transcriptPrompt,
    transcriptUrl,
    setTranscriptUrl,
    translateToLanguage,
    setTranslateToLanguage,
    generateTranscript,
    setTranscriptInProgress,
    transcriptInProgress,
    isUploading,
    setIsUploading,
    isUploadingToServer,
    setIsUploadingToServer,
    isCensorEnabled,
    setIsCensorEnabled,
    isFadingIn,
    isFadingOut,
    fadeOpacity,
    fadeOverlayRef,
    currentAnimationRef,
    isAnimatingRef,
    showVideoEffect,
    setShowVideoEffect,
    videoEffectId,
    setVideoEffectId,
    handleAddFilter,
    handleCensorFilterChange,
    handleIsCensorEnabled,
    handleRemoveCensorFilter,
    isSaving,
    setIsSaving,
  };
};

export default useVideoEditor;",llama-3.1-70b-instruct,gpt-4o-2024-08-06,0.0,"  videoType: string | null;
  setVideoType: React.Dispatch<React.SetStateAction<string | null>>;
  videoStorageURL: string | null;
  setVideoStorageURL: React.Dispatch<React.SetStateAction<string | null>>;
  videoDownloadURL: string | null;
  setVideoDownloadURL: React.Dispatch<React.SetStateAction<string | null>>;
  uploadProgress: number;
  setUploadProgress: React.Dispatch<React.SetStateAction<number>>;
  analyzeProgress: number;
  setAnalyzeProgress: React.Dispatch<React.SetStateAction<number>>;
  exportProgress: number;
  setExportProgress: React.Dispatch<React.SetStateAction<number>>;
  isAnalysing: boolean;
  transitionTime: number;
  setTransitionTime: React.Dispatch<React.SetStateAction<number>>;
  panelSize: number;
  setPanelSize: React.Dispatch<React.SetStateAction<number>>;
  isMobile: boolean;
  isTablet: boolean;
  isDesktop: boolean","  transcriptPrompt, showVideoEffect, videoEffectId, handleAddFilter, handleCensorFilterChange, handleIsCensorEnabled, handleRemoveCensorFilter, isSaving, setIsSaving,"
"import connectDB from '@/config/db';
import Property from '@/models/Property';

// GET /api/properties/search
export const GET = async (request) => {
  try {
    await connectDB();

    const { searchParams } = new URL(request.url);
    const location = searchParams.get('location');
    const propertyType = searchParams.get('propertyType');

    const locationPattern = new RegExp(location, 'i');  // ","

    // Match location pattern against database fields
    let query = {
      $or: [
        { name: locationPattern },
        { description: locationPattern },
        { 'location.street': locationPattern },
        { 'location.city': locationPattern },
        { 'location.state': locationPattern },
        { 'location.zipcode': locationPattern },
      ],
    };

    // Only check for property if its not 'All'
    if (propertyType && propertyType !== 'All') {
      const typePattern = new RegExp(propertyType, 'i');
      query.type = typePattern;
    }

    const properties = await Property.find(query);

    return new Response(JSON.stringify(properties), {
      status: 200,
    });
  } catch (error) {
    console.log(error);
    return new Response('Something went wrong', { status: 500 });
  }
};
",gpt-4o-2024-08-06,gemini-1.5-pro-002,0.0,"Create a regex pattern for location, case insensitive",Case-insensitive search
"#include <iostream>

class StringView {
  public:
  const char* str;
  size_t size;

  StringView() : str(nullptr), size(0) {}
  StringView(const char* str) : str(str), size(sizeof(str)) {}
  StringView(const char* str, size_t size) : str(str), size(size) {}

  ","operator[](const size_t index) {
    return *(data + index);
  }

};

int main() {
  std::cout << ""Hello, world!"" << std::endl;
  return 0;
}",gemini-1.5-pro-002,llama-3.1-405b-instruct,0.0,"char operator[](const size_t index) {
    return *(str + index);
  }

  char ","size_t length() const {
    return size;
  }

  const char* data() const {
    return str;
  }

  char"
"import java.util.*;

public class binarySearchTree {
    static class Node {
        int data; 
        Node left;
        Node right;
        
        Node(int data){
            this.data = data;
            left = null;
            right = null;
        }
    }

    public static Node insert(Node root, int value){
        if(root == null){
            return new Node(value);
        }
        if(value < root.data){
            root.left = insert(root.left, value);
        } else {
            root.right = insert(root.right, value);
        }
        return root;
    }

    public static boolean search(Node root, int key){
        if(root == null){
            return false;
        }
        if(root.data == key){
            return true;
        }
        if(key < root.data){
            return search(root.left, key);
        } else {
            return search(root.right, key);
        }
    }
    


    public void inOrder(Node root){
        if(root != null){
            inOrder(root.left);
            System.out.print(root.data + "" "");
            inOrder(root.right);
        }
    } 
    public static Node delete(Node root, int val){
        if(root == null){
            return null;
        }

        if(val < root.data){
            root.left = delete(root.left, val);
        } else if(val > root.data){
            root.right = delete(root.right, val);
        } else { //val == root.data
            //case 1: leaf node
            if(root.left == null && root.right == null){
                return null;
            }

            //case 2: single child
            if(root.left == null){
                return root.right;
            }
            if(root.right == null){
                return root.left;
            }

            //case 3: both children
            Node IS = findInorderSuccessor(root.right);
            root.data = IS.data;
            root.right = delete(root.right, IS.data);
        }
        return root;
    }

    public static Node findInorderSuccessor(Node root){
        while(root.left != null){
            root = root.left;
        }
        return root;
    }
     
    public static void printInRange(Node root, int k1, int k2){
        if(root == null){
            return;
        }
        if(root.data >= k1 && root.data <= k2){
            printInRange(root.left, k1, k2);
            System.out.print(root.data + "" "");
            printInRange(root.right, k1, k2);
        } else if(root.data < k1){
            printInRange(root.right, k1, k2);
        } else {
            printInRange(root.left, k1, k2);
        }
    }

    public static void printRoot2Leaf(Node root, ArrayList<Integer> path){
        if(root == null){
            return;
        }
        path.add(root.data);
        if(root.left == null && root.right == null){
            System.out.println(path);
        }
        printRoot2Leaf(root.left, path);
        printRoot2Leaf(root.right, path);
        path.remove(path.size() - 1);
    }

    public static boolean isValidBST(Node root, Node min, Node max){
        if(root == null){
             return true;
         }
         if(min != null && root.data <= min.data){
             return false;
         } else if(max != null && root.data >= max.data){
             return false;
         }
         return isValidBST(root.left, min, root) && isValidBST(root.right, root, max);
    }

    public static Node createMirror(Node root){
        if(root == null){
            return null;
        }
        Node leftMirror = createMirror(root.left);
        Node rightMirror = createMirror(root.right);
        
        root.left = rightMirror;
        root.right = leftMirror;
        
        return root;
    }

    public static Node buildBalancedBST(ArrayList<Integer> arr, int start, int end) {
        if (start > end) {
            return null;
        }
        
        int mid = (start + end) / 2;
        Node root = new Node(arr.get(mid));
        
        root.left = buildBalancedBST(arr, start, mid - 1);
        root.right = buildBalancedBST(arr, mid + 1, end);
        
        return root;
    }

    static class Info{
        boolean isBST;
        int size;
        int min;
        int max;

        Info(boolean isBST, int size, int min, int max){
            this.isBST = isBST;
            this.size = size;
            this.min = min;
            this.max = max;
        }
    }

    ","

    public static void main(String args[]){
        int values[] = { 8, 5, 3, 1, 4, 6, 10, 11, 14 };
        Node root = null;

        for(int value : values){
            root = insert(root, value);
        }
        printTree2(root);

        // if(search(root, 6)){
        //     System.out.println(""Found"");
        // } else {
        //     System.out.println(""Not Found"");
        // }

        // root = delete(root, 5);
        // printTree2(root);
        // printInRange(root, 1, 10);
        // System.out.println();
        // printRoot2Leaf(root, new ArrayList<>());
        // if(isValidBST(root, null, null)){
        //     System.out.println(""Valid"");
        // }else{
        //     System.out.println(""Not valid"");
        // }
        // createMirror(root);
        // printTree2(root);

        // Create a balanced BST from sorted array
        // ArrayList<Integer> sortedArr = new ArrayList<>(Arrays.asList(1, 2, 3, 4, 5, 6, 7, 8, 9));

        // Node balancedRoot = buildBalancedBST(sortedArr, 0, sortedArr.size() - 1);
        // System.out.println(""Balanced BST:"");
        // printTree2(balancedRoot);

        // Create BST to Balanced BST
        // Convert BST to sorted array
        ArrayList<Integer> sortedArr2 = new ArrayList<>();
        printTree3(root, sortedArr2);
        // System.out.println(sortedArr2);
        
        // Convert sorted array to balanced BST
        Node balancedRoot2 = buildBalancedBST(sortedArr2, 0, sortedArr2.size() - 1);
        System.out.println(""Balanced BST from original BST:"");
        printTree2(balancedRoot2);
    }

















    // Method 1: Simple tree printing (Inorder traversal)
    public static void printTree(Node root){
        if(root == null){
            return;
        }
        printTree(root.left);
        System.out.print(root.data + "" "");
        printTree(root.right);
        
    }
    public static void printTree3(Node root,ArrayList<Integer> arr){
        if(root == null){
            return;
        }
        printTree3(root.left, arr);
        arr.add(root.data);
        // System.out.print(root.data + "" "");
        printTree3(root.right, arr);
        
    }
    













    // Method 2: More visually aligned tree printing
    static void printTree2(Node root) {
        int maxLevel = getMaxLevel(root);
        printNodeInternal(Collections.singletonList(root), 1, maxLevel);
    }

    private static void printNodeInternal(List<Node> nodes, int level, int maxLevel) {
        if (nodes.isEmpty() || isAllElementsNull(nodes))
            return;

        int floor = maxLevel - level;
        int edgeLines = (int) Math.pow(2, (Math.max(floor - 1, 0)));
        int firstSpaces = (int) Math.pow(2, (floor)) - 1;
        int betweenSpaces = (int) Math.pow(2, (floor + 1)) - 1;

        printWhitespaces(firstSpaces);

        List<Node> newNodes = new ArrayList<>();
        for (Node node : nodes) {
            if (node != null) {
                System.out.print(node.data);
                newNodes.add(node.left);
                newNodes.add(node.right);
            } else {
                newNodes.add(null);
                newNodes.add(null);
                System.out.print("" "");
            }
            printWhitespaces(betweenSpaces);
        }
        System.out.println();

        for (int i = 1; i <= edgeLines; i++) {
            for (Node node : nodes) {
                printWhitespaces(firstSpaces - i);
                if (node == null) {
                    printWhitespaces(edgeLines + edgeLines + i + 1);
                    continue;
                }

                if (node.left != null)
                    System.out.print(""/"");
                else
                    printWhitespaces(1);

                printWhitespaces(i + i - 1);

                if (node.right != null)
                    System.out.print(""\\"");
                else
                    printWhitespaces(1);

                printWhitespaces(edgeLines + edgeLines - i);
            }
            System.out.println();
        }

        printNodeInternal(newNodes, level + 1, maxLevel);
    }

    private static void printWhitespaces(int count) {
        for (int i = 0; i < count; i++)
            System.out.print("" "");
    }

    private static int getMaxLevel(Node node) {
        if (node == null)
            return 0;
        return Math.max(getMaxLevel(node.left), getMaxLevel(node.right)) + 1;
    }

    private static boolean isAllElementsNull(List<Node> list) {
        for (Object object : list) {
            if (object != null)
                return false;
        }
        return true;
    }
}


",codestral-2405,claude-3-5-sonnet-20241022,1.0,"public static Info largestBST(Node root){
        if(root == null){
            return new Info(true, 0, Integer.MAX_VALUE, Integer.MIN_VALUE);
        }
        Info leftInfo = largestBST(root.left);
        Info rightInfo = largestBST(root.right);","public static Info largestBSTinBT(Node root){
        if(root == null){
            return new Info(true, 0, Integer.MAX_VALUE, Integer.MIN_VALUE);
        }
        Info leftInfo = largestBSTinBT(root.left);
        Info rightInfo = largestBSTinBT(root.right);
        int size = leftInfo.size + rightInfo.size + 1;
        int min = Math.min(root.data, Math.min(leftInfo.min, rightInfo.min));
        int max = Math.max(root.data, Math.max(leftInfo.max, rightInfo.max));
        
        if(root.data <= leftInfo.max || root.data >= rightInfo.min){
            return new Info(false, size, min, max);
        }
        if(leftInfo.isBST && rightInfo.isBST){
            return new Info(true, size, min, max);
        }
        return new Info(false, size, min, max);
    "
"import numpy as np
import cv2
import os

from desmume.emulator import DeSmuME, SCREEN_PIXEL_SIZE, SCREEN_PIXEL_SIZE_BOTH, SCREEN_WIDTH, SCREEN_HEIGHT, SCREEN_HEIGHT_BOTH
from desmume.controls import Keys, keymask

ROM_FILE = os.path.join('ROM', 'Pokemon - Platinum.nds')
SAVESTATE_FILES = [
    os.path.join('ROM', 'Pokemon - Platinum.ds1')
]

CYCLES_PER_STEP = 60 # the game goes at 60 FPS, so this means each step will last a total of 1 second
CYCLES_PER_ACTION = 9 # this means we hold down a button press for 9 frames, or 150 ms

class PokemonEnv():
    """"""
    Creates an environment to run the Pokemon Platinum. 
    Note: while it does have many similarities to the gym spec, it is not compatible (specifically due to changes w/ how rendering works)
    """"""

    button_to_key = {
        'A': Keys.KEY_A,
        'B': Keys.KEY_B,
        'X': Keys.KEY_X,
        'Y': Keys.KEY_Y,
        'UP': Keys.KEY_UP,
        'DOWN': Keys.KEY_DOWN,
        'LEFT': Keys.KEY_LEFT,
        'RIGHT': Keys.KEY_RIGHT,
        'START': Keys.KEY_START,
        'SELECT': Keys.KEY_SELECT,
        'L': Keys.KEY_L,
        'R': Keys.KEY_R
    }


    def __init__(
            self, 
            include_bottom_screen=False,
            rom_file=ROM_FILE, 
            savestate_files=SAVESTATE_FILES, 
        ):
        
        self.emu = DeSmuME()
        self.emu.volume_set(0) # even headless, desmume makes noise

        self.emu.open(rom_file)

        self.savestate_files = savestate_files

        # TODO: this gives us a starting point for the LLM, gotta figure out some other save states and points to work with
        self.load_savestate(self.savestate_files[0])

        self.include_botton_screen = include_bottom_screen

    def load_savestate(self, savestate_file):
        self.emu.savestate.load_file(savestate_file)

    def step(self, action: str | None):
        
        if action and action not in self.button_to_key:
            raise ValueError(f""Invalid action: {action}, expected one of: {self.button_to_key.keys()}"")

        self._act(action)

        return self.get_state()

    def get_state(self):
        screen = self._get_screen()
        
        if not self.include_botton_screen:
            screen = screen[:SCREEN_HEIGHT]

        return screen
        
    def reset(self):
        self.load_savestate(self.savestate_files[0])
        return self.get_state()

    def _get_screen(self):
        # see https://py-desmume.readthedocs.io/en/latest/quick_start.html#custom-drawing
        screen_buffer = self.emu.display_buffer_as_rgbx()
        screen_pixels = np.frombuffer(screen_buffer, dtype=np.uint8)

        screen = screen_pixels[:SCREEN_PIXEL_SIZE_BOTH * 4] 
        screen = screen.reshape((SCREEN_HEIGHT_BOTH, SCREEN_WIDTH, 4))[..., :3] # drop the alpha channel

        return screen

    def _act(self, action: str | None):
        # it's just easier to clear all of the keys first and then set the ones we want instead of trying to figure out which ones are already set
        self.emu.input.keypad_rm_key(Keys.NO_KEY_SET)

        if action: 
            action = action.strip().upper()

            self.emu.input.keypad_add_key(keymask(self.button_to_key[action]))


class PokemonClient:
    """"""
    This is a wrapper around the Pokemon env that handles some things, in particular holding down a button for long enough for an action to complete
    (since you need to hold the D-pad or else it will only rotate the character instead of moving the chatacter)
    """"""

    def __init__(
        self, 
        render_screen=False, 
        include_bottom_screen=False,
        rom_file=ROM_FILE, 
        savestate_files=SAVESTATE_FILES, 
        cycles_per_step=CYCLES_PER_STEP, 
        cycles_per_action=CYCLES_PER_ACTION
    ):
        self.env = PokemonEnv(
            include_bottom_screen=include_bottom_screen,
            rom_file=rom_file,
            savestate_files=savestate_files,
        )
        
        if cycles_per_step <= ","
        
        self.render_screen = render_screen
        self.cycles_per_step = cycles_per_step
        self.cycles_per_action = cycles_per_action

    def step(self, actions: str | list[str]):
        if isinstance(actions, str):
            actions = [actions]

        for action in actions:
            self._act(action)

        for _ in range(self.cycles_per_step - self.cycles_per_action * len(actions)):
            self._cycle()

        return self.get_state()

    def reset(self):
        return self.env.reset()
    
    def _act(self, action: str):
        for _ in range(self.cycles_per_action):
            self.env.step(action)
            self._cycle()

    def _cycle(self):
        self.env.step(None)

        if self.render_screen:
            self._render()
        
    def _render(self):
        frame = self.env.get_state()

        # for display purposes, I want the screen to be 2x bigger
        frame = cv2.resize(frame, (frame.shape[1] * 2, frame.shape[0] * 2), interpolation=cv2.INTER_NEAREST)

        cv2.imshow('Pokemon Platinum', frame)
        cv2.waitKey(3)


if __name__ == '__main__':
    env = PokemonClient(render_screen=True, include_bottom_screen=False)
    env.reset()

    while True:
        env.step('RIGHT')


""""""
Here is my current environment to play a Pokemon on the desmume emulator using Python, however, it's gotten a little too coupled for my liking. Specifically, I'm forcing it to take a # of cycles each time I take an action, and then the `render` has to be done each time there and it's honestly really awkward. However, it does offer a convenient interface for a different application, so I don't want to remove that functionality, so here's what I'd like:

I want you to refactor this into two classes. The first class should be called PokemonEnv, but it'll be the 'raw' Pokemon environment. Same public functions, but 1 step = 1 cycle and it accepts only a single action. Then, there is the second class, idk what to call it and whether it should just be a wrapper or subclass or whatever. That's your choice (although before deciding, you should evaluate which one is the better option). This second class should have the current class' functionality and handle the longer input presses + step cycles. 

In all of this, you are free to rename the private functions/variables.

""""""",codestral-2405,claude-3-5-sonnet-20241022,1.0,"0 or cycles_per_action <= 0 or cycles_per_step < cycles_per_action:
            raise ValueError(""cycles_per_step and cycles_per_action must be positive and cycles_per_step must be greater than cycles_per_action"")

        self.render_screen = render_screen
        self.cycles_per_step = cycles_per_step
        self.cycles_per_action = cycles_per_action

    def step(self, actions: str | list[str]):
        if isinstance(actions, str):
            actions = [actions]

        for action in actions:
            self._act(action)

        for _ in range(self.cycles_per_step - self.cycles_per_action * len(actions)):
            self._cycle

        return self.get_state

    def reset(self):
        return self.env.reset","cycles_per_action:
            raise ValueError(f""cycles_per_step ({cycles_per_step}) must be greater than cycles_per_action ({cycles_per_action})"")"
"\documentclass{article}
\title{Monitoring cold plasma particle coating by fluorescence spectroscopy as Process Analytical Tool}
\author{Names and affiliations}
\date{\today}


\begin{document}
\maketitle

\begin{abstract}
Short introduction to subject of the paper \ldots 
\end{abstract}

\section{Introduction}\label{sec:intro}

\begin{itemize}
    \item Plasma
    \item Plasma applications
    \item Coating
    \item Microscopy
    \item Microscopy challenge
    \item Fluorescence benefits (fast)
    \item Fluorescence challenges (not much info)
    \item objectives:
    \item Developing a quicker method to know if coating was applied correctly.
    \item Ideally quantify thickness
    \item Steps towards soft sensor
\end{itemize}

\section{Materials and Methods}\label{sec:matmet}
\begin{itemize}
    \item Experimental setup [partix reactor, experimental conditions, sampling, etc.] [‘Training’ experiment, ‘Test’ experiment 1, 2]
    \item TEM
    \item Fluorescence
    \item Data analysis [error definition, PLS model, hyperparameter tuning, CV]
\end{itemize}
\section{Results and Discussion}\label{sec:resdis}

\begin{itemize}
\item TEM
\item fluo measurements and PLS
\item ","
\end{itemize}
\section{Conclusions}\label{sec:conc}

\end{document}


RESULTS AND DISCUSSION
•	TEM measurements
•	Fluorescence measurements and PLS model
o	Data, training, and CV
o	Predictivity of the model against other experiments
CONCLUSION
•	Hopefully, that fluorescence relates 1 to 1 with TEM.
",deepseek-coder-fim,llama-3.1-70b-instruct,0.0,Predictivity of the model against other experiments,"   •	TEM measurements
    •	Fluorescence measurements and PLS model
    o	Data, training, and CV
    o	Predictivity of the model against other experiments"
"import uuid
from typing import Literal, TypedDict

from langchain_core.language_models import BaseChatModel
from langchain_core.messages import AIMessage, HumanMessage
from langchain_core.runnables import RunnableConfig
from langgraph.checkpoint.memory import MemorySaver
from langgraph.constants import END, START
from langgraph.graph import MessagesState, StateGraph
from langgraph.types import Command, interrupt

from .prompt import (
    INIT_MESSAGE,
    create_paper_initialize_prompt,
    create_paper_update_prompt,
)
from .schema import PaperIntro


class AgentState(MessagesState):
    # model: BaseChatModel
    paper: PaperIntro


def check_paper_complete(paper: PaperIntro):
    if not paper.problem_definition:
        return ""Can you elaborate problem definition?""
    if not paper.research_statement:
        return ""Can you elaborate research questions?""
    if not paper.objectives:
        return ""Can you elaborate objectives?""

    return ""done""


def init_paper(state: AgentState, config: RunnableConfig):
    # Human Input

    paper = PaperIntro()
    messages = []
    INIT_PAPER_PROMPT = create_paper_initialize_prompt(paper, messages)
    print(""interrupting - init"")
    user_input = interrupt(INIT_MESSAGE)
    print(""interrupting -"", user_input)
    llm = config[""configurable""].get(""model"")
    runnable = INIT_PAPER_PROMPT | llm.with_structured_output(PaperIntro)
    paper = runnable.invoke({""input"": user_input})

    messages.extend(
        [
            (""assistant"", INIT_MESSAGE),
            (""user"", user_input),
        ]
    )
    return Command(
        update={
            ""paper"": paper,
            ""messages"": messages,
        },
        goto=""process_paper"",
    )


def update_paper(state: AgentState, config: RunnableConfig):
    messages = state.get(""messages"")
    paper_message = messages[-1][1]

    print(""interrupting - update"")
    # Human Input
    user_input = interrupt(paper_message)

    paper = state.get(""paper"")
    CONSTRUCT_PAPER_PROMPT = create_paper_update_prompt(
        paper=paper,
        messages=messages,
    )
    llm = config[""configurable""].get(""model"")
    runnable = CONSTRUCT_PAPER_PROMPT | llm.with_structured_output(PaperIntro)
    paper = runnable.invoke({""input"": user_input, ""question"": paper_message})

    return Command(update= {
        ""paper"": paper,
        ""messages"": [
            (""assistant"", paper_message),
            (""user"", user_input),
        ],
    }, goto=""","""


def process_paper(
    state: AgentState, config: RunnableConfig
) -> Command[Literal[""init_paper"", ""update_paper"", ""update_title""]]:
    paper = state.get(""paper"")
    if paper is None:
        return Command(goto=""init_paper"")

    # messages = state.get(""messages"")
    paper_message = check_paper_complete(paper)
    print(""Check -"", PaperIntro)
    if paper_message != ""done"":
        return Command(
            update={
                ""messages"": [
                    (""assistant"", paper_message),
                ]
            },
            goto=""update_paper"",
        )

    return Command(update={""messages"": [(""assistant"", ""DONE"")]}, goto=""update_title"")


def update_title(state: AgentState, config: RunnableConfig):
    paper = state[""paper""]
    llm = config[""configurable""].get(""model"")

    return {
        ""paper"": paper,
    }


def generate_outline(state: AgentState, config: RunnableConfig):
    paper = state[""paper""]
    llm = config[""configurable""].get(""model"")

    return {
        ""paper"": paper,
    }


def create_introduction_graph(llm: BaseChatModel, checkpointer=None):
    graph_builder = StateGraph(AgentState)
    graph_builder.add_node(""process_paper"", process_paper)
    # graph_builder.add_node(""human"", human_input)
    graph_builder.add_node(""init_paper"", init_paper)
    graph_builder.add_node(""update_paper"", update_paper)
    graph_builder.add_node(""update_title"", update_title)
    graph_builder.add_node(""generate_outline"", generate_outline)

    graph_builder.add_edge(START, ""process_paper"")
    # graph_builder.add_edge(""agent"", ""human"")
    graph_builder.add_edge(""init_paper"", ""process_paper"")
    graph_builder.add_edge(""update_paper"", ""process_paper"")
    graph_builder.add_edge(""process_paper"", ""update_title"")
    graph_builder.add_edge(""update_title"", ""generate_outline"")

    graph_builder.add_edge(""generate_outline"", END)

    if checkpointer is None:
        checkpointer = MemorySaver()

    graph = graph_builder.compile(checkpointer=checkpointer)
    return graph
",codestral-2405,gemini-1.5-flash-002,0.0,"process_paper"")","process_paper"")
    }"
"public class mergeSort {
    public static void mergeSort(int[] arr, int si, int ei){
        int mid = si + (ei - si)/2;
        mergeSort(arr, si, mid);
        mergeSort(arr, mid + 1, ei);
        ","
    }
    public static void main(String args[]){
        int[] arr = {1, 5, 8, 2, 9, 9, 2, 5, 3, 0};
        
    }
}
",gemini-1.5-pro-002,deepseek-coder-fim,0.0,"merge(arr, si, mid, ei);
    }
    public static void merge(int[] arr, int si, int mid, int ei){","merge(arr, si, ei, mid);"
"import java.util.*;

public class traversals {
    static class Node {
        int data;
        Node left;
        Node right;

        Node(int data) {
            this.data = data;
            this.left = null;
            this.right = null;
        }
    }

    public static void preOrder(Node root) {
        if (root == null) {
            // System.out.print(""-1 "");
            return;
        }
        System.out.print(root.data + "" "");
        preOrder(root.left);
        preOrder(root.right);
    }

    public static void inOrder(Node root) {
        if (root == null) {
            // System.out.print(""-1 "");
            return;
        }
        inOrder(root.left);
        System.out.print(root.data + "" "");
        inOrder(root.right);
    }

    public static void postOrder(Node root) {
        if (root == null) {
            // System.out.print(""-1 "");
            return;
        }
        postOrder(root.left);
        postOrder(root.right);
        System.out.print(root.data + "" "");
    }

    public static void leverOrder(Node root) {
        if (root == null) {
            return;
        }
        Queue<Node> queue = new LinkedList<Node>();
        queue.add(root);
        queue.add(null);
        while (!queue.isEmpty()) {
            Node temp = queue.remove();
            if (temp == null) {
                System.out.println();
                if (!queue.isEmpty()) {
                    queue.add(null);
                }
            } else {
                System.out.print(temp.data + "" "");
                if (temp.left != null) {
                    queue.add(temp.left);
                }
                if (temp.right != null) {
                    queue.add(temp.right);
                }
            }
        }
    }

    // public static void leverOrder(Node root){
    // if(root == null){
    // return;
    // }
    // Queue<Node> queue = new LinkedList<Node>();
    // queue.add(root);
    // while(!queue.isEmpty()){
    // Node temp = queue.remove();
    // System.out.print(temp.data + "" "");
    // if(temp.left != null){
    // queue.add(temp.left);
    // }
    // if(temp.right != null){
    // queue.add(temp.right);
    // }
    // }
    // }

    public static int height(Node root) {
        if (root == null) {
            return 0;
        }
        int lh = height(root.left);
        int rh = height(root.right);
        return Math.max(lh, rh) + 1;
    }

    public static int count(Node root) {
        if (root == null) {
            return 0;
        }
        int leftCount = count(root.left);
        int rightCount = count(root.right);
        return leftCount + rightCount + 1;
    }

    public static int sumOfNodes(Node root) {
        if (root == null) {
            return 0;
        }
        int leftSum = sumOfNodes(root.left);
        int rightSum = sumOfNodes(root.right);
        return leftSum + rightSum + root.data;
    }

    public static int diameter(Node root) { // O(n^2);
        if (root == null) {
            return 0;
        }
        int leftDiameter = diameter(root.left);
        int rightDiameter = diameter(root.right);
        int leftHeight = height(root.left);
        int rightHeight = height(root.right);
        int selfDiameter = leftHeight + rightHeight + 1;
        return Math.max(selfDiameter, Math.max(leftDiameter, rightDiameter));
    }

    static class Info {
        int dia;
        int height;

        Info(int dia, int height) {
            this.dia = dia;
            this.height = height;
        }
    }

    public static Info diameter2(Node root) { // O(n);
        if (root == null) {
            return new Info(0, 0);
        }
        Info leftInfo = diameter2(root.left);
        Info rightInfo = diameter2(root.right);

        int diam = Math.max(Math.max(leftInfo.dia, rightInfo.dia), leftInfo.height + rightInfo.height + 1);
        int ht = Math.max(leftInfo.height, rightInfo.height) + 1;

        return new Info(diam, ht);
    }

    public static boolean isSubTree(Node root, Node subRoot) {
        if (root == null) {
            return false;
        }
        if (areIdentical(root, subRoot)) {
            return true;
        }
        return isSubTree(root.left, subRoot) || isSubTree(root.right, subRoot);
    }

    public static boolean areIdentical(Node root, Node subRoot) {
        if (root == null && subRoot == null) {
            return true;
        }
        if (root == null || subRoot == null) {
            return false;
        }
        return (root.data == subRoot.data && areIdentical(root.left, subRoot.left)
                && areIdentical(root.right, subRoot.right));
    }

    public static boolean isIdentical(Node root, Node subRoot) {
        if (root == null && subRoot == null) {
            return true;
        } else if (root == null || subRoot == null || root.data != subRoot.data) {
            return false;
        }
        if (!isIdentical(root.left, subRoot.left)) {
            return false;
        }
        if (!isIdentical(root.right, subRoot.right)) {
            return false;
        }
        return true;
    }

    static class Info2 {
        Node node;
        int hd;

        Info2(Node node, int hd) {
            this.node = node;
            this.hd = hd;
        }
    }

    public static void topView(Node root) {
        // Lever Order
        Queue<Info2> queue = new LinkedList<Info2>();
        HashMap<Integer, Node> map = new HashMap<>();

        int min = 0, max = 0;
        queue.add(new Info2(root, 0));
        queue.add(null);
        while (!queue.isEmpty()) {
            Info2 temp = queue.remove();
            if (temp == null) {
                if (!queue.isEmpty()) {
                    queue.add(null);
                }
            } else {
                if (!map.containsKey(temp.hd)) { // first time hd is occuring.
                    map.put(temp.hd, temp.node);
                }
                if (temp.node.left != null) {
                    queue.add(new Info2(temp.node.left, temp.hd - 1));
                    min = Math.min(min, temp.hd - 1); // to see if we are going further left.
                }
                if (temp.node.right != null) {
                    queue.add(new Info2(temp.node.right, temp.hd + 1));
                    max = Math.max(max, temp.hd + 1); // to see if we are going further right.
                }
            }
        }

        for (int i = min; i <= max; i++) {
            System.out.print(map.get(i).data + "" "");
        }
        System.out.println();
    }

    public static void kthLevelIterative(Node root, int k) {
        // Lever Order
        Queue<Node> queue = new LinkedList<Node>();
        queue.add(root);
        queue.add(null);
        int level = 1;
        while (!queue.isEmpty()) {
            Node temp = queue.remove();
            if (temp == null) {
                level++;
                if (!queue.isEmpty()) {
                    queue.add(null);
                }
            } else {
                if (level == k) {
                    System.out.print(temp.data + "" "");
                }
                if (temp.left != null) {
                    queue.add(temp.left);
                }
                if (temp.right != null) {
                    queue.add(temp.right);
                }
            }
        }
        System.out.println();
    }

    public static void kthLeverRecursive(Node root, int level, int k){
        if (root == null) {
            return;
        }
        if (level == k) {
            System.out.print(root.data + "" "");
        }
        kthLeverRecursive(root.left, level + 1, k);
        kthLeverRecursive(root.right, level + 1, k);
    }

    // lowest common ancestor
    public static boolean getPath(Node root, int n, ArrayList<Node> path){
        if(root == null){
            return false;
        }
        path.add(root);

        if(root.data == n){
            return true;
        }

        boolean left = getPath(root.left, n, path);
        boolean right = getPath(root.right, n, path);
        if(left || right){
            return true;
        }
        
        path.remove(path.size() - 1);
        return false;
    }

    public static Node lca(Node root, int n1, int n2){
        ArrayList<Node> path1 = new ArrayList<>();
        ArrayList<Node> path2 = new ArrayList<>();
        getPath(root, n1, path1);
        getPath(root, n2, path2);

        //last common ancestor
        int i = 0;
        for(; i < path1.size() && i < path2.size(); i++){
            if(path1.get(i) != path2.get(i)){
                break;
            }
        }
        // last equal node -> i - 1;
        Node lca = path1.get(i-1);
        return lca;
    }

    public static Node lca2(Node root, int n1, int n2){
        if(root == null || root.data == n1 || root.data == n2){
            return root;
        }
        Node leftLCA = lca2(root.left, n1, n2);
        Node rightLCA = lca2(root.right, n1, n2);

        //leftLCA = val rightLCA = null
        if(rightLCA == null){
            return leftLCA;
        }
        if(leftLCA == null){
            return rightLCA;
        }

        return root;
    }

    public static void main(String args[]) {
        Node root = new Node(1);
        root.left = new Node(2);
        root.right = new Node(3);
        root.left.left = new Node(4);
        root.left.right = new Node(5);
        root.right.left = new Node(6);
        root.right.right = new Node(7);

        // System.out.println(""Preorder traversal:"");
        // preOrder(root);
        // System.out.println();
        // System.out.println(""Inorder traversal:"");
        // inOrder(root);
        // System.out.println();
        // System.out.println(""Postorder traversal:"");
        // postOrder(root);
        // System.out.println();
        // System.out.println(""LeverOrder traversal:"");
        // leverOrder(root);
        // System.out.print(""Height of the tree is: "");
        // System.out.println(height(root));
        // System.out.print(""Count of the tree is: "");
        // System.out.println(count(root));
        // System.out.print(""Sum of nodes in the tree is: "");
        // System.out.println(sumOfNodes(root));
        // System.out.print(""Diameter of the tree is: "");
        // System.out.println(diameter(root));
        // System.out.print(""Diameter of the tree is: "");
        // System.out.println(diameter2(root).dia);
        // Node subRoot = new Node(2);
        // subRoot.left = new Node(4);
        // subRoot.right = new Node(5);
        // System.out.print(""Is subtree: "");
        // System.out.println(isSubTree(root, subRoot));
        // System.out.println(""Top view of the tree is: "");
        // topView(root);
        printTree2(root);

        kthLevelIterative(root, 3);
        kthLeverRecursive(root, 1, 3);
        System.out.println();
        Node lca2 = lca(root, 4, 6);
        System.out.println(""LCA is: "" + lca2.data);
        ","
    }

    

    // Method 1: Simple but less visually aligned printing
    static void printTree1(Node root, String indent, String prefix) {
        if (root == null)
            return;

        System.out.println(indent + prefix + root.data);
        printTree1(root.left, indent + ""   "", ""L:"");
        printTree1(root.right, indent + ""   "", ""R:"");
    }

    // Method 2: More visually aligned tree printing
    static void printTree2(Node root) {
        int maxLevel = getMaxLevel(root);
        printNodeInternal(Collections.singletonList(root), 1, maxLevel);
    }

    private static void printNodeInternal(List<Node> nodes, int level, int maxLevel) {
        if (nodes.isEmpty() || isAllElementsNull(nodes))
            return;

        int floor = maxLevel - level;
        int edgeLines = (int) Math.pow(2, (Math.max(floor - 1, 0)));
        int firstSpaces = (int) Math.pow(2, (floor)) - 1;
        int betweenSpaces = (int) Math.pow(2, (floor + 1)) - 1;

        printWhitespaces(firstSpaces);

        List<Node> newNodes = new ArrayList<>();
        for (Node node : nodes) {
            if (node != null) {
                System.out.print(node.data);
                newNodes.add(node.left);
                newNodes.add(node.right);
            } else {
                newNodes.add(null);
                newNodes.add(null);
                System.out.print("" "");
            }
            printWhitespaces(betweenSpaces);
        }
        System.out.println();

        for (int i = 1; i <= edgeLines; i++) {
            for (Node node : nodes) {
                printWhitespaces(firstSpaces - i);
                if (node == null) {
                    printWhitespaces(edgeLines + edgeLines + i + 1);
                    continue;
                }

                if (node.left != null)
                    System.out.print(""/"");
                else
                    printWhitespaces(1);

                printWhitespaces(i + i - 1);

                if (node.right != null)
                    System.out.print(""\\"");
                else
                    printWhitespaces(1);

                printWhitespaces(edgeLines + edgeLines - i);
            }
            System.out.println();
        }

        printNodeInternal(newNodes, level + 1, maxLevel);
    }

    private static void printWhitespaces(int count) {
        for (int i = 0; i < count; i++)
            System.out.print("" "");
    }

    private static int getMaxLevel(Node node) {
        if (node == null)
            return 0;
        return Math.max(getMaxLevel(node.left), getMaxLevel(node.right)) + 1;
    }

    private static boolean isAllElementsNull(List<Node> list) {
        for (Object object : list) {
            if (object != null)
                return false;
        }
        return true;
    }
}
",claude-3-5-sonnet-20240620,gemini-1.5-flash-002,1.0,"Node lca2 = lca(root, 4, 6);
        System.out.println(""LCA is: "" + lca2.data);

        // Method 1: Simple but less visually aligned printing
        System.out.println(""Tree structure (Method 1):"");
        printTree1(root, """", """");

        // Method 2: More visually aligned tree printing
        System.out.println(""
Tree structure (Method 2):"");
        printTree2(root);
    }

    static void printTree1(Node root, String indent, String prefix) {
        if (root == null)
            return;

        System.out.println(indent + prefix + root.data);
        printTree1(root.left, indent + ""   "", ""L:"");
        printTree1(root.right, indent + ""   "", ""R:"");","Node lca2 = lca2(root, 4, 6);
        System.out.println(""LCA is: "" + lca2.data);
        printTree1(root,"""","" "");"
"use std::collections::{BTreeMap, BTreeSet};

use crate::utils::input;

pub(crate) fn run(part: u32) {
    let input = input::read_file(""inputs/day16.txt"");

    match part {
        1 => part1(&input),
        2 => part2(&input),
        _ => println!(""Invalid part""),
    }
}

fn part1(input: &str) {
    let grid = input
        .lines()
        .map(|line| line.chars().collect::<Vec<_>>())
        .collect::<Vec<_>>();

    let start = grid
        .iter()
        .flatten()
        .enumerate()
        .find(|x| *x.1 == 'S')
        .map(|(idx, _char)| idx)
        .unwrap() as isize;

    let start = (start / grid.len() as isize, start % grid.len() as isize);

    let end = grid
        .iter()
        .flatten()
        .enumerate()
        .find(|x| *x.1 == 'E')
        .map(|(idx, _char)| idx)
        .unwrap() as isize;

    let end = (end / grid.len() as isize, end % grid.len() as isize);

    let mut queue = BTreeSet::new();
    let mut dist = BTreeMap::new();

    queue.insert((0, start, 0, -1));
    dist.insert((start, 0, -1), 0);

    while let Some(top) = queue.pop_first() {
        let (cur_dist, (vertex_x, vertex_y), direction_x, direction_y) = top;

        if (vertex_x, vertex_y) == end {
            break;
        }

        let (new_x, new_y) = (vertex_x + direction_x, vertex_y + direction_y);

        if new_x >= 0 && new_x < grid.len() as isize && new_y >= 0 && new_y < grid.len() as isize {
            let new_dist = cur_dist + 1;
            let new_key = ((new_x, new_y), direction_x, direction_y);

            if !dist.contains_key(&new_key) || new_dist < *dist.get(&new_key).unwrap() {
                dist.remove(&new_key);
                dist.insert(new_key, new_dist);
                queue.insert((new_dist, (new_x, new_y), direction_x, direction_y));
            }
        }

        for new_dir in [(0, 1), (0, -1), (1, 0), (-1, 0)] {
            if new_dir == (direction_x, direction_y) {
                continue;
            }

            ","
        }
    }
}

fn part2(input: &str) {}
",llama-3.1-405b-instruct,codestral-2405,0.0,"let new_dist = cur_dist + 1;
            let new_key = ((vertex_x, vertex_y), new_dir.0, new_dir.1);

            if !dist.contains_key(&new_key) || new_dist < *dist.get(&new_key).unwrap() {
                dist.remove(&new_key);
                dist.insert(new_key, new_dist);
                queue.insert((new_dist, (vertex_x, vertex_y), new_dir.0, new_dir.1));
            ","let (new_x, new_y) = (vertex_x + new_dir.0, vertex_y + new_dir.1);"
"from typing import List
from fastapi import APIRouter, Depends, HTTPException, status
from sqlalchemy.orm import Session

from api.groups.models import Group
from db.session import get_db
from .models import Role
from .schemas import RoleUpdate, RoleCreate, RoleResponse
from api.users.models import User
from core.security import get_current_user

router = APIRouter()

@router.post(""/"", response_model=RoleResponse)
def create_mod(role: RoleCreate, db: Session = Depends(get_db), user: User = Depends(get_current_user)):
    # add check is exist
    if not db.query(Group).find(role.group_id):
        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail=""Group not found"") 
    group_name","
    if db.query(Role).filter(Role.name == (role.name+""-""+group_name) and Role.group_id == role.group_id):
        raise HTTPException(status_code=status.HTTP_400_BAD_REQUEST, detail=""Role with this name already exists""
    #add check is user a admin group or super admin
    if not user.is_admin or not db.query(Group).filter(Group.id == role.group_id, Group.admin_id == user.id).first():
        raise HTTPException(status_code=status.HTTP_403_FORBIDDEN, detail=""You don't have permission to create roles in this group""
    new_role = Role(name=role.name, description=role.description)
    db.add(new_role)
    db.commit()
    db.refresh(new_role)
    return new_role

@router.get(""/{group_id}"", response_model=List[RoleResponse])
def get_all_roles(group_id: str, db: Session = Depends(get_db), user: User = Depends(get_current_user)):
    roles = db.query(Role).filter(Role.group_id == group_id).all()
    if roles is None:
        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail=""Roles not found"")
    return roles

@router.get(""/{role_id}"", response_model=RoleResponse)
def get_role(group_id: str,role_id: str, db: Session = Depends(get_db), user: User = Depends(get_current_user)):
    mod = db.query(Role).filter(Role.id == role_id).first()
    if not mod:
        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail=""Role not found"")
    return mod

@router.put(""/{mod_id}"", response_model=RoleResponse)
def update_mod(mod_id: int, mod_update: RoleUpdate, db: Session = Depends(get_db), user: User = Depends(get_current_user)):
    mod = db.query(Role).filter(Role.id == mod_id).first()
    if not mod:
        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail=""Role not found"")
    if mod.user_id != user.id:
        raise HTTPException(status_code=status.HTTP_403_FORBIDDEN, detail=""You don't have permission to update this mod"")
    mod.name = mod_update.name
    mod.description = mod_update.description
    db.commit()
    db.refresh(mod)
    return mod

@router.delete(""/{mod_id}"", status_code=status.HTTP_204_NO_CONTENT)
def delete_mod(mod_id: int, db: Session = Depends(get_db), user: User = Depends(get_current_user)):
    mod = db.query(Role).filter(Role.id == mod_id).first()
    if not mod:
        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail=""Role not found"")
    if mod.user_id != user.id:
        raise HTTPException(status_code=status.HTTP_403_FORBIDDEN, detail=""You don't have permission to delete this mod"")
    db.delete(mod)
    db.commit()
",codestral-2405,gemini-1.5-pro-002,1.0," = db.query(Group).filter(Group.id == role.group_id).first().name
    # add check is exist role with this name in this group"," = db.query(Group).filter(Group.id == role.group_id).first().name
    #add ""-"" between role name and group name
    role.name = role.name + ""-"" + group_name"
"import React from 'react';
import PropTypes from 'prop-types';
import StarRatings from 'Shared/StarRatings';
import { complexRandomId } from 'Shared/utils/randomIds';
import { dataTrackParams } from 'Shared/analytics/analyticsGlobalEvents';
import { hasAccess } from 'Shared/utils/userAccessRules';
import { Helpers } from 'jh-common-core';
import LockIcon from 'SVG/lock-outline.svg';
import Tooltip from 'Shared/Tooltip';

const SimpleCells = (props) => {
  const { head, fund, t, userGroups, userFirmId, activeTab } = props;

  const getAlignmentClass = (alignment) => (['left', 'right'].indexOf(alignment) >= 0 ? alignment : 'center');
  const getColorClass = (itemColor, navNegative) => {
    if (itemColor) {
      if (navNegative) {
        return 'listingTable__td--green';
      }
      return 'listingTable__td--red';
    }
    return '';
  };

  const renderSubValue = (item) => {
    if (!item.subValue) return null;

    const subValue = typeof item.subValue === 'function' ? item.subValue(fund, t) : fund[item.subValue];

    if (!subValue) return null;

    return (
      <span className={`listingTable__tdSub ${getColorClass(item.color, fund.navNegative)}`}>
        {subValue}
      </span>
    );
  };

  const gatedDownload = (e, isAccessible) => {
    e.preventDefault();
    if (isAccessible) {
      window.location.href = e.currentTarget.href;
    } else {
      Helpers.CPSConnect.gatedAction();
    }
  }

  const renderDocument = (item) => {
    const isAccessible = hasAccess(userGroups, fund[item.access], userFirmId, fund.firmId);

    // Empty document
    if (!fund[item.type]) return '—';

    return (
      <a
        className=""listingTable__tdWrapper""
        href={isAccessible ? fund[item.url] : ''}
        onClick={(e) => gatedDownload(e, isAccessible)}
        data-track-type={dataTrackParams.global.types.linkClick}
        data-track-id={item.label}
      >
        <div className=""listingTable__downloadWrapper"">
          <span className=""listingTable__link"">{item.label}</span>
          <span className=""listingTable__tdSub"">
            {!isAccessible && <LockIcon className=""listingTable__tdSubIcon"" />}
            {`${fund[item.type]} - ${fund[item.size]}`}
          </span>
          {!isAccessible && <Tooltip text={t.tooltipRestrictedDoc} wrap={false} />}
        </div>
      </a>
    );
  };

  const renderDoubleCells = (item) => {

    // Only ren","
    if (!(fund.productType === 'ETF' || fund.productType === 'SMA')) {
      return null;
    }

    if (item.ETFperfTitle) {
      return (
        <div>
          <span className=""listingTable__tdSubETF"">{item.title1}</span>
          <span className=""listingTable__tdSubETF"">{item.title2}</span>
        </div>
      );
    }

    if (!item.ETFperfTitle) {
      if (item.stars) {
        return (
          <StarRatings
            rating={fund[item.stars]}
            extended={fund[item.starsHollow]}
            source=""fundListingSimpleCellETF""
          />
        );
      }

      if (activeTab === 'performance' && fund.productType === 'SMA') {
        return (
          <div>
            <span className=""listingTable__tdSubETF"">{fund[item.key] || '—'}</span>
            <span className=""listingTable__tdSubETF"">{fund[item.key2] || '—'}</span>
          </div>
        );
      }

      // Default 
      return (
        <div>
          {fund[item.key] && <span className=""listingTable__tdSubETF"">{fund[item.key]}</span>}
          {fund[item.key2] && <span className=""listingTable__tdSubETF"">{fund[item.key2]}</span>}
        </div>
      );
    }
  };


  return (
    <>
      {
        head.map((item, i) => i !== 0 && (
          <td
            key={complexRandomId('sc', 20, 10000, 2)}
            className={[
              'listingTable__td',
              `listingTable__td--${getAlignmentClass(item.alignment)}`,
              getColorClass(item.color, fund.navNegative)
            ].join(' ')}
            style={{ width: `${item.width}%` }}>
            {renderDoubleCells(item)}
            {/* {(fund.productType === 'ETF' || fund.productType === 'SMA') && item.ETFperfTitle && (
              <div>
                <span className=""listingTable__tdSubETF"">{item.title1}</span>
                <span className=""listingTable__tdSubETF"">{item.title2}</span>
              </div>
            )}
            {(fund.productType === 'ETF' || fund.productType === 'SMA') && !item.ETFperfTitle && (item.stars
              ? <StarRatings rating={fund[item.stars]} extended={fund[item.starsHollow]} source=""fundListingSimpleCellETF"" />
              : (
                <div>
                  {fund[item.key] && <span className=""listingTable__tdSubETF"">{fund[item.key]}</span>}
                  {fund[item.key2] && <span className=""listingTable__tdSubETF"">{fund[item.key2]}</span>}
                </div>
              )
            )} */}
            {(fund.productType !== 'ETF' && fund.productType !== 'SMA') && !item.ETFperfTitle && (item.stars
              ? <StarRatings rating={fund[item.stars]} extended={fund[item.starsHollow]} source=""fundListingSimpleCellNonETF"" />
              : fund[item.key] || '—'
            )}
            {item.isFactSheet ? renderDocument(item) : renderSubValue(item)}
          </td>
        ))
      }
    </>
  );
};

SimpleCells.propTypes = {
  head: PropTypes.arrayOf(PropTypes.shape()).isRequired,
  fund: PropTypes.shape().isRequired
};

export default SimpleCells;
",llama-3.1-70b-instruct,codestral-2405,0.0,der double cells for ETF and SMA products,edr for ETF and SMA products
"import {Router} from ""express""
const router = Router();
import {Avatar} from ""@repo/db/src/modules/avatar.moduls.js"" 
import {Element} from ""@repo/db/src/modules/Element.moduls.js"" 
import { asyncHandler } from ""../utils/asyncHandler"";
import { ApiError } from ""../utils/ApiError"";

const clearElement = asyncHandler(async(req, res) =>{
    const {imageUrl , width , height, isStatic} = req.body
})

if([imageUrl , width , height, isStatic].some((feild)=> feild?.trim() === """")){
    throw new ApiError","
}


export default router;",deepseek-coder-fim,codestral-2405,0.0,"(400, ""All feilds are required"")","(400, ""All fields are required"")

const foundAvatar = await Avatar.findById(req.params.id)
if(!foundAvatar) throw new ApiError(404, ""Avatar not found"")

const foundElement = await Element.findById(req.params.elementId)
if(!foundElement) throw new ApiError(404, ""Element not found"")

if(foundElement.avatar.toString() !== foundAvatar._id.toString()) throw new ApiError(400, ""Incorrect Avatar Id"")

if(foundElement.isStatic !== isStatic) throw new ApiError(400, ""Incorrect Element Id"")

foundElement.imageUrl = imageUrl
foundElement.width = width
foundElement.height = height

await foundElement.save()

return res.status(200).json(
    new ApiError(200, ""Element updated successfully"", foundElement)
)"
"import  numpy as np
import sklearn.datasets
x = np.array([1, 2, 3])
print(x)

#create synthetic data
from sklearn.datasets import make_blobs
X, y = make_blobs(n_samples=100, centers=2, random_state=0, cluster_std=0.60)

print(x)

# create synthetic data
from sklearn.datasets import make_blobs
X, y = make_blobs(n_samples=100, centers=2, random_state=0, cluster_std=0.60)

print(x)

# create synthetic data
from sklearn.datasets import make_blobs
X, y = make_blobs(n_samples=100, centers=2, random_state=0, cluster_std=0.60)

print(x)

# create synthetic data
from sklearn.datasets import make_blobs
X, y = make_blobs(n_samples=100, centers=2, random_state=0, cluster_std=0.60)
print(x)



#create synthetic data
from sklearn.datasets import make_blobs
X, y = make_blobs(n_samples=100, centers=2, random_state=0, cluster_std=0.60)

print(x)

# create synthetic data
from sklearn.datasets import make_blobs
X, y = make_blobs(n_samples=100, centers=2, random_state=0, cluster_std=0.60)
print(x)

# create synthetic data
from sklearn.datasets import make_blobs
X, y = make_blobs(n_samples=100, centers=2, random_state=0, cluster_std=0.60)
print(x)

# create synthetic data
from sklearn.datasets import make_blobs
X, y = make_blobs(n_samples=100, centers=2, random_state=0, cluster_std=0.60)
print(x)

# create synthetic data
from sklearn.datasets import make_blobs
X, y = make_blobs(n_samples=100, centers=2, random_state=0, cluster_std=0.60)
print(x)      
# create synthetic data
from sklearn.datasets import make_blobs
X, y = make_blobs(n_samples=100, centers=2, random_state=0, cluster_std=0.60)
print(x)





#more data
print(x for 
      print(x)      
#more data
print(x for 
      
      x in [1,2,3])
print(x)
#create synthetic data
from sklearn.datasets import make_blobs
X, y = make_blobs(n_samples=100, centers=2, random_state=0, cluster_std=0.60)
print(x)

# create synthetic data
from sklearn.datasets import make_blobs
X, y = make_blobs(n_samples=100, centers=2, random_state=0, cluster_std=0.60)
print(x)
      x in [1,2,3])
print(x)
#create synthetic data
from sklearn.datasets import make_blobs
X, y = make_blobs(n_samples=100, centers=2, random_state=0, cluster_std=0.60)
print(x)

# create synthetic data
from sklearn.datasets import make_blobs
X, y = make_blobs(n_samples=100, centers=2, random_state=0, cluster_std=0.60)
print(x)
      x in [1,2,3])
print(x)
#create synthetic data
from sklearn.datasets import make_blobs
X, y = make_blobs(n_samples=100, centers=2, random_state=0, cluster_std=0.60)
print(x)

# create synthetic data
from sklearn.datasets import make_blobs
X, y = make_blobs(n_samples=100, centers=2, random_state=0, cluster_std=0.60)
print(X)

# define the data
from sklearn.datasets import make_blobs
X, y = make_blobs(n_samples=100, centers=2, random_state=0, cluster_std=0.60)
print(x)

# create synthetic data
from sklearn.datasets import make_blobs
X, y = make_blobs(n_samples=100, centers=2, random_state=0, cluster_std=0.60)
print(X)

# define the data
      x in [1,2,3])
print(x)
#create synthetic data
from sklearn.datasets import make_blobs
X, y = make_blobs(n_samples=100, centers=2, random_state=0, cluster_std=0.60)
print(X)

# define the data
from sklearn.datasets import make_blobs
X, y = make_blobs(n_samples=100, centers=2, random_state=0, cluster_std=0.60)
print(x)

# create synthetic data
from sklearn.datasets import make_blobs
X, y = make_blobs(n_samples=100, centers=2, random_state=0, cluster_std=0.60)
print(X)

# define the data

        ","

#create synthetic data
from sklearn.datasets import make_blobs
X, y = make_blobs(n_samples=100, centers=2, random_state=0, cluster_std=0.60)
print(x)

# create synthetic data
from sklearn.datasets import make_blobs
X, y = make_blobs(n_samples=100, centers=2, random_state=0, cluster_std=0.60)
print(X)

# define the dat",qwen-2.5-coder-32b-instruct,gpt-4o-mini-2024-07-18,1.0,"print(x for 
      x in [1,2,3])
print(x)","x in [1,2,3])
print(x)
#create synthetic data
from sklearn.datasets import make_blobs
X, y = make_blobs(n_samples=100, centers=2, random_state=0, cluster_std=0.60)
print(X)

# define the data"
"from ipdb import set_trace


if a:
    set_trace()
",,gemini-1.5-pro-002,deepseek-coder-fim,1.0,"
if a:","
if b:
    set_trace()"
"import numpy as np
import torch
import torch.nn as nn
import torch.nn.functional as F
from torch.autograd import Variable
import torch.optim as optim
import torchvision
import torchvision.transforms as transforms
import matplotlib.pyplot as plt
import time

# create tempelate for torch project with dataloader and training loop and preprocessing of the data and loading csv dataset

",,llama-3.1-405b-instruct,qwen-2.5-coder-32b-instruct,1.0,"class Net(nn.Module):
    def __init__(self):
        super(Net, self).__init__()
        self.fc1 = nn.Linear(784, 128)
        self.fc2 = nn.Linear(128, 10)

    def forward(self, x):
        x = F.relu(self.fc1(x))","# Define a simple neural network
class SimpleNN(nn.Module):
    def __init__(self, input_size, hidden_size, num_classes):
        super(SimpleNN, self).__init__()
        self.fc1 = nn.Linear(input_size, hidden_size)
        self.relu = nn.ReLU()
        self.fc2 = nn.Linear(hidden_size, num_classes)"
"import os 
import pgzrun

Pages = os.listdir(""image"")
def quitar_elemento_de_lista(lista):
    """"""Quita un elemento de cada string en una lista.""""""
    return [s.replace("".jpg"", """") for s in lista]

Pages = quitar_elemento_de_lista(Pages)


def create_pages(Pages):
    Manga = []
    for i in range(len(Pages)):
        Manga.append(Pages[i])
    return Manga

Manga = create_pages(Pages)
def draw():","

        
",gpt-4o-mini-2024-07-18,qwen-2.5-coder-32b-instruct,0.0,    pass,"    screen.clear()
    for i, page in enumerate(Manga):
        screen.blit(page, (0, i * HEIGHT))"
"<biblioteca>
    <inventario>
        <libro1>    
            <titulo>         </titulo>
            ","
        </libro1>

    </inventario>
</biblioteca>


<biblioteca>
    <inventario>
        <libro>
            <!-- Detalles del libro aquí -->
        </libro>
    </inventario>
</biblioteca>
",gemini-1.5-pro-002,gpt-4o-2024-08-06,0.0,"<autor>          </autor>
            <isbn>           </isbn",</titulo
"import math
import random
from enum import Enum
from typing import ClassVar

from pydantic import BaseModel, Field

from simulation.map import Map


class People(BaseModel):
    class Sentiment(Enum):
        NEUTRAL = 0
        POSITIVE = 1
        NEGATIVE = 2

    id: int = Field(..., description=""people id"")
    x: float = Field(..., description=""Global x position"")
    y: float = Field(..., description=""Global y position"")
    eye_gazing_angle: float = Field(0.0, description=""Eye gazing direction as degrees"")
    is_taking_photo: bool = Field(
        False, description=""Boolean for if the person is currently taking a photo""
    )
    is_waving: bool = Field(
        False, description=""Boolean for if the person is currently waving""
    )
    sentiment: Sentiment = Field(Sentiment.NEUTRAL, description=""Person's sentiment"")
    is_activate: bool = Field(True, description=""People's activation status"")
    attention_score: float = Field(0.0, description=""cumulative attention score"")
    behavior: str = Field("""", description=""behavior at current timestamp"")
    behaviorIndex: int = Field(0, description=""The index for current behavior"")
    behaviorList: list[str] = Field(
        [], description=""Behaviors that people need to execute""
    )
    direction: float = Field(0, description=""Eye Gaze direction"")
    storesList: list[int] = Field([], description=""Stores to be visited"")
    storeIndex: int = Field(0, description=""The current index of visiting stores"")

    taking_photo_history: list = Field(
        [0, 0],
        description=""First represent number of behavior happened, the second represents the number of data in history, reset after countting as one behavior"",
    )
    eye_gazing_history: list = []
    sentiment_history: list = []
    # constant variables
    BEHAVIOR_PROBABILITY: ClassVar[dict[str, float]] = {
        ""visitStore"": 0.5,
        ""takingPhoto"": 0.2,
        ""visitAttraction"": 0.3,
    }

    speed: ClassVar[float] = 10  # pixel per frame
    """"""
    DESTINATION: stores, entrance
    BEHAVIOR_TYPE: photoTaking, resting

    taking_photo_history = []
    eye_gazing_history = []
    sentiment_history = []

    move(): function to set the moving direction according to destination and behavior type

    """"""

    def setBehavior(self):
        # create weighted array based on behavior probability table
        self.behaviorIndex = 0
        weightedBehavior = []
        for behavior in self.BEHAVIOR_PROBABILITY:
            weight = int(self.BEHAVIOR_PROBABILITY[behavior] * 10)
            for i in range(weight):
                weightedBehavior.append(behavior)

        # shuffle the behaivor list
        random.shuffle(weightedBehavior)
        # set number of behavior with a random number from 0 to 10.
        numBehavior = random.randint(0, 10)
        self.behaviorList = weightedBehavior[:6]

        numStoreToVisit = random.randint(0, 10)
        totalNumStores = len(Map.STORES)
        storeIndices = [i for i in range(totalNumStores)]
        for i in range(numStoreToVisit):
            selectedStore = random.choice(storeIndices)
            self.storesList.append(selectedStore)
            storeIndices.remove(selectedStore)

    def move(self, robotState):
        """"""
        destination: define the path and movement direction

        """"""
        self.check_bounds()
        self.execuate()  # change position for people
        self.updateGazeDirection(robotState)  # update eye gazing direction
        self.updateSentiment()  # update sentiment
        self.reportScore(robotState)  # report attention score

    # <--------------------------------- update position information ---------------------------------->

    def execuate(self):
        # check if people are done all behaviors
        if self.behaviorIndex >= len(self.behaviorList):
            self.exit()
            return

        self.behavior = self.behaviorList[self.behaviorIndex]

        if self.behavior == ""visitStore"":
            self.is_taking_photo = False
            self.visitStores()
        elif self.behavior == ""takingPhoto"":
            self.is_taking_photo = True
            self.behaviorIndex += 1
        else:
            self.is_taking_photo = False
            self.visitAttraction()

        return

    # <--------------------------------------- update state ----------------------------------->
    def updateGazeDirection(self, robotState=None):
        minGazeOffset = -45
        maxGazeOffset = 45
        gazeChangeSpeed = 0.005
        targetAngle = 0

        realignChange = random.uniform(0, 1)
        if realignChange < 0.6:
            targetAngle = 0
        elif realignChange < 0.9:
            targetAngle = random.randint(minGazeOffset, maxGazeOffset)
        else:
            ran = random.uniform(0, 1)
            if ran > 0.5:
                targetAngle = random.randint(-180, -45)
            else:
                targetAngle = random.randint(45, 180)
        self.eye_gazing_angle = abs(targetAngle)
        return

    def updateSentiment(self):
        prob = random.uniform(0, 1)
        if self.sentiment == self.Sentiment.POSITIVE:
            if prob < 0.8:
                self.sentiment = self.Sentiment.POSITIVE
            elif prob < 0.95:
                self.sentiment = self.Sentiment.NEUTRAL
            else:
                self.sentiment = self.Sentiment.NEGATIVE

        elif self.sentiment == self.Sentiment.NEUTRAL:
            if prob < 0.6:
                self.sentiment = self.Sentiment.POSITIVE
            elif prob < 0.8:
                self.sentiment = self.Sentiment.NEUTRAL
            else:
                self.sentiment = self.Sentiment.NEGATIVE
        else:
            if prob < 0.7:
                self.sentiment = self.Sentiment.POSITIVE
            elif prob < 0.9:
                self.sentiment = self.Sentiment.NEUTRAL
            else:
                self.sentiment = self.Sentiment.NEGATIVE

        return

    def reportScore(self, robotState):
        # record taking photo data and update attention score
        if self.is_taking_photo:
            self.taking_photo_history.append(1)
            self.attention_score += 10
        else:
            self.taking_photo_history.append(0)

        # record eye gazing data and update attention score
        if self.isGazeTowardsRobot(robotState) == 1:
            self.eye_gazing_history.append(1)
            self.attention_score += 10
        elif self.isGazeTowardsRobot(robotState) == 2:
            self.eye_gazing_history.append(2)
            self.attention_score += 1
        else:
            self.eye_gazing_history.append(0)

        return

    def isGazeTowardsRobot(self, robotState):
        global_eye_gaze = self.direction + self.eye_gazing_angle

        angleToRobot = (
            math.atan2(robotState.y - self.y, robotState.x - self.x) * 180
        )  # degree

        if global_eye_gaze > angleToRobot - 30 or global_eye_gaze < angleToRobot + 30:
            return 1
        elif global_eye_gaze > angleToRobot - 90 or global_eye_gaze < angleToRobot + 90:
            return 2
        else:
            return 0

    def exit(self):
        target = Map.ENTRANCES[1]
        direction = math.atan2(target[""y""] - self.y, target[""x""] - self.x)
        self.direction = direction
        self.x += self.speed * math.cos(self.direction)
        self.y += self.speed * math.sin(self.direction)

        # remove current people if they reach the final target position
        distanceToTarget = math.hypot(target[""x""] - self.x, target[""y""] - self.y)
        if distanceToTarget < 5:
            self.is_activate = False
            self.reactivate()

        return

    def reactivate(self):
        self.x = 0
        self.y = 300
        self.is_activate = True
        self.eye_gazing_angle = 0
        self.is_taking_photo = False
        self.attention_score = 0
        self.behaviorIndex = 0
        self.behaviorList = []
        self.direction = 0
        self.storesList = []
        self.storeIndex = 0
        self.taking_photo_history = [0, 0]
        self.setBehavior()

    # <------------------------------------------ behavior motion setting ------------------------------->
    def visitStores(self):
        if self.storesList and self.storeIndex < len(self.storesList):
            target = Map.STORES[self.storesList[self.storeIndex]]
            direction = math.atan2(target[""y""] - self.y, target[""x""] - self.x)
            self.direction = direction
            self.x += self.speed * math.cos(direction)
            self.y += self.speed * math.sin(direction)

            # remove movement to next store or next behavior
            distanceToTarget = math.hypot(target[""x""] - self.x, target[""y""] - self.y)
            if distanceToTarget < 5:
                self.storeIndex += 1
                if self.storeIndex >= len(self.storesList):
                    self.behaviorIndex = self.behaviorIndex + 1
        if self.storeIndex >= len(self.storesList):
            self.behaviorIndex = self.behaviorIndex + 1

        return

    def visitAttraction(self):
        target = Map.ATTRACTIONS[0]

        direction = math.atan2(target[""y""] - self.y, target[""x""] - self.x)
        self.direction = direction
        self.x += self.speed * math.cos(direction)
        self.y += self.speed * math.sin(direction)

        # remove movement to next behavior
        distanceToTarget = math.hypot(target[""x""] - self.x, target[""y""] - self.y)
        if distanceToTarget < 10:
            self.behaviorIndex += 1
        if self.behaviorIndex >= len(self.behaviorList):
            self.exit()
        return

    def takePhotoAtPoint(self):
        self.is_taking_photo = True
        return

    def check_bounds(self):
        # Bounce off the left or right edge
        if self.x <= 0 or self.x >= 800:
            direction = math.pi - self.direction
            self.update_direction(direction)
            self.x = max(0, min(self.x, 800))

        # Bounce off the top or bottom edge
        if self.y <= 0 or self.y >= 600:
            direction = -self.direction
            self.update_direction(direction)
            self.y = max(0, min(self.y, 600))

    @classmethod
    def update_direction(cls, value):
        cls.direction = value
    
    def __repr__(self):
        return ","
",claude-3-5-sonnet-20241022,gpt-4o-mini-2024-07-18,0.0,"f""People(id={self.id}, x={self.x}, y={self.y}, eye_gazing_angle={self.eye_gazing_angle}, is_taking_photo={self.is_taking_photo}, is_waving={self.is_waving}, sentiment={self.sentiment}, is_activate={self.is_activate}, attention_score={self.attention_score}, behavior={self.behavior}, behaviorIndex={self.behaviorIndex}, behaviorList={self.behaviorList}, direction={self.direction}, storesList={self.storesList}, storeIndex={self.storeIndex})""","f""People(id={self.id}, x={self.x}, y={self.y}, eye_gazing_angle={self.eye_gazing_angle}, is_taking_photo={self.is_taking_photo}, is_waving={self.is_waving}, sentiment={self.sentiment}, is_activate={self.is_activate}, attention_score={self.attention_score}, behavior={self.behavior}, behaviorIndex={self.behaviorIndex}, behaviorList={self.behaviorList}, direction={self.direction}, storesList={self.storesList}, storeIndex={self.storeIndex}, taking_photo_history={self.taking_photo_history}, eye_gazing_history={self.eye_gazing_history}, sentiment_history={self.sentiment_history})"""
"//Write html page wich connects to google gemini ai API
<!DOCTYPE html>
<html lang=""en"">
<head>
    <meta charset=""UTF-8"">
    <meta name=""viewport"" content=""width=device-width, initial-scale=1.0"">
    <title>Google Gemini AI API</title>
</head>
<body>
    <h1>Connect to Google Gemini AI API</h1>
    <script>
        async function connectToGemini() {
            const apiUrl = 'https://gemini.googleapis.com/v1/some-endpoint'; // Replace with actual endpoint
            const apiKey = 'YOUR_API_KEY'; // Replace with your API key

            try {
                const response = await fetch(apiUrl, {
                    method: 'GET',
                    headers: {
                        'Authorization': `Bearer ${apiKey}`,
                        'Content-Type': 'application/json'",,codestral-2405,gemini-1.5-flash-002,0.0,"
                    }));

                if (response.ok) {
                    const data = await response.json();
                    console.log(data);
                else {
                    console.error('Error:', response.statusText);
            catch (error) {
                console.error('Error:', error);
            }

        connectToGemini();
    </script
></body
></html","                    },
                });

                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }

                const data = await response.json();
                console.log('Gemini API response:', data);
            } catch (error) {
                console.error('Error connecting to Gemini API:', error);
            }
        }

        connectToGemini();
    </script>
</body>
</html>"
"public class doublyLL {
    public static class Node{
        int data;
        Node next;
        Node prev;

        public Node(int data) {
            this.data = data;
            this.next = null;
            this.prev = null;
        }
    }

    public static Node head;
    public static Node tail;
    public static int size;

    public void addFirst(int data){
        Node newNode = new Node(data);
        if (head == null) {
            head = newNode;
            tail = newNode;
        } else {
            newNode.next = head;
            head.prev = newNode;
            head = newNode;
        }
        size++;
    }

    public void addLast(int data){
        Node newNode = new Node(data);
        if (head == null) {
            head = newNode;
            tail = newNode;
        } else {
            tail.next = newNode;
            newNode.prev = tail;
            tail = newNode;
        }
        size++;
    }

    public void removeFirst(){
        if (head == null) {
            return;
        } else if (head == tail) {
            head = null;
            tail = null;
        } else {
            head = head.next;
            head.prev = null;
        }
        size--;
    }

    public void removeLast(){
        if (head == null) {
            return;
        } else if (head == tail) {
            head = null;
            tail = null;
        } else {
            tail = tail.prev;
            tail.next = null;
        }
        size--;
    }

    public void print(){
        Node temp = head;
        while(temp != null){
            System.out.print(temp.data + "" <-> "");
            temp = temp.next;
        }
        System.out.println(""null"");
    }

    public void reverse(){
        ","
    }

    public static void main(String args[]){
        doublyLL dll = new doublyLL();
        dll.addFirst(2);
        dll.addFirst(1);
        dll.addLast(3);
        dll.addLast(4);
        dll.print();
    }
}
",qwen-2.5-coder-32b-instruct,claude-3-5-sonnet-20241022,1.0,"Node current = head;
        Node temp = null;

        while (current != null) {
            temp = current.prev;
            current.prev = current.next;
            current.next = temp;
            current = current.prev;
        }

        if (temp != null) {
            head = temp.prev;
        ","Node curr = head;
        Node prev = null;
        Node next;

        while (curr != null) {
            next = curr.next;
            curr.next = prev;
            curr.prev = next;
            prev = curr;
            curr = next;
        }
        Node temp = head;
        head = tail;
        tail = temp;"
"import re
import random
import pyarrow as pa
import pyarrow.parquet as pq
import pandas as pd
from tqdm import tqdm
from itertools import repeat
from datasets import load_dataset, concatenate_datasets
from transformers import AutoTokenizer

from collections import defaultdict

a = defaultdict(dict)

a[pos][token] = prob

def adaptive_generate(input_text, temperature, num_tokens=100, max_retries=5, backspace_threshold=0.5):
    inputs = tokenizer(input_text, add_special_tokens=False, return_tensors=""pt"", padding=""max_length"", max_length=1024).to(""cuda"")
    input_ids = inputs.input_ids
    attention_mask = inputs.attention_mask
    added_text = """"
    positional_ids = torch.arange(input_ids.shape[1]).unsqueeze(0).to(""cuda"")
    
    total_tokens_added = 0    
    
    retries_at_position = defaultdict(int)
    tried_tokens_at_position = defaultdict(dict)
    
    while total_tokens_added < num_tokens:

        # Forward pass through the model to get logits
        output = model(input_ids=input_ids, attention_mask=attention_mask, position_ids=positional_ids)
        
        logits = output.logits[:, -1]

        with torch.no_grad():
            logits = dry_wrapper(input_ids.to('cpu'), logits.clone().to('cpu'))
        input_ids = input_ids.to(""cuda"")
        logits = logits.to(""cuda"")
        # Apply temperature scaling to the logits
        scaled_logits = logits / temperature
        
        tried_tokens = tried_tokens_at_position[total_tokens_added].keys()
        
        scaled_logits[0, tried_tokens] = float('-inf')        
        
        probs = F.softmax(scaled_logits, dim=-1)
        
        # Apply softmax to the scaled logits to get the probability distribution    

        chosen = torch.multinomial(probs, 1)[0][0].int()
        input_ids_temp = torch.cat([input_ids[:, 1:], torch.tensor([[chosen]]).cuda()], dim=1)
        attention_mask_temp = torch.cat([attention_mask[:, 1:], torch.tensor([[1]]).cuda()], dim=-1)
        positional_ids_temp = torch.cat([positional_ids[:, 1:], torch.tensor([[positional_ids[0, -1] + 1]]).to(""cuda"")], dim=-1)
        
        outputs_back = model(input_ids=input_ids_temp, attention_mask=attention_mask_temp, position_ids=positional_ids_temp)
        logits_back = output_back.logits[:, -1]
        
        probability_of_backspace = F.softmax(scaled_logits, dim=-1)[0, 3]
        
        if probability_of_backspace > backspace_threshold:
            retries_at_position[total_tokens_added] += 1
            tried_tokens_at_position[total_tokens_added][chosen] = probability_of_backspace
        elif (probability_of_backspace <= backspace_threshold or
              retries_at_position[total_tokens_added] == max_retries):
            min_backspace_prob_token = min(tried_tokens_at_position[total_tokens_added],
                                           key=tried_tokens_at_position[total_tokens_added].get)
            
            added_text += tokenizer.decode(chosen)
            input_ids = input_ids_temp
            ","
            
        # Sample the next token from the probability distribution
        
        # Add the chosen token to the generated text
        
        # Update the input_ids by appending the chosen token and removing the first token (shifting window)
        
        if last_chosen == 3:
            positional_ids = torch.cat([positional_ids[:, 1:], torch.tensor([[positional_ids[0, -1] - 1]]).to(""cuda"")], dim=-1)
        else:
            positional_ids = torch.cat([positional_ids[:, 1:], torch.tensor([[positional_ids[0, -1] + 1]]).to(""cuda"")], dim=-1)
    print(input_text + added_text)


tokenizer = AutoTokenizer.from_pretrained(""Lovre/small-tokenizer-16384"", local_files_only=False)
tokenizer.padding_side = ""left""

file_name = ""train-00006-of-00041.parquet""
# file_name = ""train-00000-of-00001.parquet""

# Simple Wikipedia
dataset = load_dataset('parquet', data_files=""../datasets/20231101.simple/train-00000-of-00001.parquet"", split='train')

# Simple Wikipedia QA
# quizzes_dataset = load_dataset('Lovre/simple-wikipedia-qa-448k', split='train')

# Wikipedia (English)
# dataset = load_dataset('parquet', data_files=f""../datasets/20231101.en/{file_name}"", split='train')

# print(dataset)

# For Wikipedia: clean up the dataset

def clean_text(example):
    split_pattern = re.compile(
        r""(Related pages\n|References\n|Related pages \n|References \n|\n\nRelated pages|\n\nReferences|== References|Related page\n|\n\nRelated page|Related page \n|\nSee also\n|\nOther websites|\nGallery)""
    )
    row_text = example[""text""]

    row_text = row_text.replace("" ()"", """")
    row_text = row_text.replace(""  "", "" "")

    lines = row_text.splitlines()
    lines = [line for line in lines if ""Wikisource"" not in line]

    # Join the lines back together
    cleaned_text = ""\n"".join(lines)

    # Split the text before any unwanted sections
    truncated_text = split_pattern.split(cleaned_text)[0]
    example[""text""] = truncated_text

    return example

def prepare_dataset(dataset):
    dataset = dataset.map(clean_text, batched=False)
    dataset = dataset.filter(
        lambda example: (
            ""list of"" not in example[""title""].lower()
            and ""football player"" not in example[""text""].lower()
            and ""football club"" not in example[""text""].lower()
        )
    )
    return dataset

dataset = prepare_dataset(dataset)

random_ix = random.randint(0, len(dataset))
print(dataset[""text""][random_ix])

# For Wikipedia QA: add a text field with the formatted question and choices

# def format_qa_sample(sample):
#     excerpt = sample['excerpt']
#     question = sample['question']
#     correct_choice = sample['correct']
#     wrong_choices = [sample['wrong1'], sample['wrong2'], sample['wrong3'], sample['wrong4'], sample['wrong5']]

#     selected_wrong_choices = random.sample(wrong_choices, 3)

#     all_choices = selected_wrong_choices + [correct_choice]
#     random.shuffle(all_choices)

#     labels = ['A', 'B', 'C', 'D']

#     correct_label = labels[all_choices.index(correct_choice)]

#     formatted_choices = ""\n"".join([f"" {label}) {choice}"" for label, choice in zip(labels, all_choices)])

#     # formatted_sample = f""{question}\n{formatted_choices}\nThe answer is {correct_label}""
#     formatted_sample = f""<PREFIX>{excerpt}\n\n{question}\n{formatted_choices}\nThe answer is</PREFIX> {correct_label}""
    
#     return {
#         ""text"": formatted_sample,
#         ""dataset"": 'wikipedia_qa'
#     }


# def token_length(examples):
#     input_ids = tokenizer(examples[""text""], truncation=False, padding=False).input_ids
#     return {
#         ""input_ids"": input_ids,
#         ""length"" : [len(ids) for ids in input_ids]
#     }
    
    
# quizzes_dataset = quizzes_dataset.map(format_qa_sample)
# quizzes_dataset = quizzes_dataset.map(token_length, batched=True)
# quizzes_dataset = quizzes_dataset.filter(lambda example: example[""length""] <= 1024)
# quizzes_dataset = quizzes_dataset.shuffle(seed=42)

# Analysis
# qa_dataset_df = pd.DataFrame(quizzes_dataset)

# min_token_count = qa_dataset_df[""length""].min()
# mean_token_count = qa_dataset_df[""length""].mean()
# max_token_count = qa_dataset_df[""length""].max()
# total_token_count = qa_dataset_df[""length""].sum()
# total_samples = qa_dataset_df.shape[0]

# print(f""Min token count: {min_token_count}"")
# print(f""Mean token count: {mean_token_count}"")
# print(f""Max token count: {max_token_count}"")
# print(f""Total token count: {total_token_count}"")
# print(f""Total samples: {total_samples}"")

# n = 1024
# # Count the number of samples above n token count
# samples_above_n = qa_dataset_df[qa_dataset_df[""length""] > n]
# count_above_n = samples_above_n.shape[0]

# # Get the text of samples above n token count
# texts_above_n = samples_above_n[""text""].tolist()

# print(f""Count of samples above {n} token count: {count_above_n}"")
# print(texts_above_n[3])
# # print(f""Texts in samples above {n} token count:"")
# # print('---------------------------------------------------------------------------------------------------')
# # for text in texts_above_n:
# #     print(text)
# #     print('---------------------------------------------------------------------------------------------------')

# dataset = concatenate_datasets([
#     dataset,
#     quizzes_dataset,
#     ])
# dataset = dataset.shuffle(seed=42)

def token_length(examples):
    input_ids = tokenizer(examples[""text""], truncation=False, padding=False).input_ids
    # Reverse the input ids
    # input_ids = [lst[::-1] for lst in input_ids]
    return {
        ""input_ids"": input_ids,
        ""length"" : [len(ids) for ids in input_ids]
    }

dataset = dataset.map(token_length, batched=True)
dataset_lens = dataset[""length""]

lens = {
    i: dataset_lens[i]
    for i in range(len(dataset_lens))
}
print(len(lens))

lens = {
    k: v
    for (k, v) in lens.items()
    if v > 20
}
print(len(lens))

modified_lens = dict()

keys_to_add_prefix = []
keys_to_modify = []
max_ctx = 1024
    
for key, value in lens.items():
    if value > max_ctx - 2:
        keys_to_modify.append(key)
    else:
        random_ctx = random.randint(8, max(8, value - 8))
        modified_lens[(key, -2, random_ctx)] = value + 2


for key in keys_to_modify:
    num_tokens = lens[key]
    first_prefix = random.randint(8, 1000)
    modified_lens[(key, 0, first_prefix)] = 1024
    general_prefix = random.randint(8, 256)
    # let's now compute the number of all remaining tokens
    R = num_tokens - 1022
    if R < 20:
        continue
    
    # in each context (except possibly the last) we'll put
    L = 1024 - general_prefix - 3
    # and in the last we'll put
    
    n_parts = (R // L) + 1
    if R % L < 20:
        skip_last = True
    else:
        skip_last = False
    
    for i in range(1, n_parts + 1):
        if i < n_parts:
            modified_lens[(key, i, general_prefix)] = 1024
        elif i == n_parts:
            if skip_last:
                continue
            modified_lens[(key, i, general_prefix, ""end"")] = general_prefix + (R % L) + 3
    
    
    
    
# # Modify the dictionary after iteration
# for key in keys_to_modify:
#     num_tokens = lens[key]
#     n_parts = 1 + ((num_tokens - 1) // max_ctx)
#     num_tokens = num_tokens - (num_tokens % n_parts)
#     in_each = num_tokens // n_parts
#     del lens[key]
#     for i in range(n_parts):
#         lens[(key, i)] = in_each


import bisect

def bin_packing_bfd_optimized(d, max_bin_size=1024):
    # Sort the dictionary items by values in descending order
    sorted_items = sorted(d.items(), key=lambda item: item[1], reverse=True)
    
    bins = []  # List of bins, each bin is a list of key-value pairs
    bin_remaining = []  # Sorted list of remaining capacities
    bin_indices = []  # Parallel list to keep track of bin indices
    
    for key, value in sorted_items:
        # Find the first bin that can accommodate the item
        index = bisect.bisect_left(bin_remaining, value)
        
        if index < len(bin_remaining):
            # Place the item in this bin
            bin_idx = bin_indices[index]
            bins[bin_idx].append((key, value))
            # Update remaining capacity
            new_remaining = bin_remaining[index] - value
            # Remove old remaining capacity
            del bin_remaining[index]
            del bin_indices[index]
            # Insert the new remaining capacity maintaining the sorted order
            bisect.insort(bin_remaining, new_remaining)
            bin_indices.insert(bisect.bisect_left(bin_remaining, new_remaining), bin_idx)
        else:
            # Create a new bin
            bins.append([(key, value)])
            remaining = max_bin_size - value
            # Insert the remaining capacity into the sorted list
            bisect.insort(bin_remaining, remaining)
            bin_indices.insert(bisect.bisect_left(bin_remaining, remaining), len(bins) - 1)
    
    return bins


bins = bin_packing_bfd_optimized(modified_lens)


# Define your batch size based on your memory constraints
batch_size = 10000

# output_file = f""../datasets/20231101.simple/packed/{file_name}""
output_file = f""../datasets/20231101.simple/packed_with_prefixes/{file_name}""

# Prepare the schema for the Parquet file
schema = pa.schema([
    ('input_ids', pa.list_(pa.int32())),
    ('document_ids', pa.list_(pa.int64())),
])

padding_idx = 2

computed_input_ids = dataset[""input_ids""]

# Initialize the Parquet writer
with pq.ParquetWriter(output_file, schema) as writer:
    batch_input_ids = []
    batch_document_ids = []
    batch_count = 0

    for packing in tqdm(bins):
        input_ids = []
        document_ids = []

        current_document_id = 1
        for doc in packing:
            doc_id = doc[0][0]
            doc_ixy = doc[0][1]
            # if doc_ixy == -1:
            #     random_ctx = doc[0][2]
            #     input_ids.extend(computed_input_ids[doc_id][:random_ctx])
            if doc_ixy == -2:
                random_ctx = doc[0][2]
                input_ids.extend([0] + computed_input_ids[doc_id][:random_ctx] + [1] + computed_input_ids[doc_id][random_ctx:])
                
            if doc_ixy == 0:
                first_prefix = doc[0][2]
                input_ids.extend([0] + computed_input_ids[doc_id][:first_prefix] + [1] + computed_input_ids[doc_id][first_prefix:1022])
            if doc_ixy > 0:
                general_prefix = doc[0][2]
                lens = 1024 - general_prefix - 3
                initial_chunk = computed_input_ids[doc_id][:general_prefix]
                leftover = computed_input_ids[doc_id][1022:]
                input_ids.extend([0] + initial_chunk + [2037, 1] + 
                                 leftover[lens*(doc_ixy-1):lens*(doc_ixy)])


            doc_len = doc[1]
            document_ids.extend(repeat(current_document_id, doc_len))
            current_document_id += 1

        # Append to batch
        batch_input_ids.append(input_ids)
        batch_document_ids.append(document_ids)
        batch_count += 1

        # If batch is full, write to Parquet and reset batch
        if batch_count >= batch_size:
            table = pa.Table.from_pydict({
                'input_ids': batch_input_ids,
                'document_ids': batch_document_ids,
            }, schema=schema)
            writer.write_table(table)
            batch_input_ids = []
            batch_document_ids = []
            batch_count = 0

    # Write any remaining data
    if batch_count > 0:
        table = pa.Table.from_pydict({
            'input_ids': batch_input_ids,
            'document_ids': batch_document_ids,
        }, schema=schema)
        writer.write_table(table)


dataset = load_dataset('parquet', data_files=output_file, split='train')
# print(dataset)

def token_length(examples):
    # Reverse the input ids
    # input_ids = [lst[::-1] for lst in input_ids]
    return {
        # ""input_ids"": input_ids,
        ""length"" : [len(ids) for ids in examples[""input_ids""]]
    }

dataset = dataset.map(token_length, batched=True)
print(max(dataset[""length""]))



for _ in range(5000):
    random_one = random.randint(0, len(dataset) -1)
    if len(dataset.select([random_one])[""input_ids""][0]) != sum((v[1] for v in bins[random_one])):
        print(len(dataset.select([random_one])[""input_ids""][0]))
        print(bins[random_one])
        print(sum((v[1] for v in bins[random_one])))
        # print(tokenizer.decode(dataset.select([random_one])[""input_ids""][0]))


print(dataset.select([random_one])[""document_ids""][0])


len(tokenizer(""""""<PREFIX>Alex K. Zettl (born Oct. 11, 1956) is an American experimental physicist, educator, and inventor.

He is a Professor of the Graduate School in Physics at the University of California, Berkeley, and a Senior Scientist at the Lawrence Berkeley National Laboratory. Zettl is a leading expert in the synthesis, characterization, and application of low dimensional materials. He has synthesized and studied new materials, notably those based on carbon, boron and nitrogen, and has made numerous inventions in the field of electronic materials and nano-electromechanical systems. Zettl and his research team were the first to synthesize boron nitride nanotubes, and created carbon nanotube chemical sensors. He and his team built the world's smallest synthetic electrically-powered rotational nanomotor, the smallest fully integrated FM radio receiver, a nanomechanical mass balance with single-atom sensitivity, voltage-controllable nanoscale relaxation oscillators, and a nanoscale thermal rectifier useful for phononic circuitry He and his team invented the nan...</PREFIX>"""""").input_ids)

948 - 246

bins[random_one]



len(dataset.select([random_one])[""document_ids""][0])",llama-3.1-405b-instruct,codestral-2405,0.0,"attention_mask = attention_mask_temp
        positional_ids = positional_ids_temp
        total_tokens_added += 1
        last_chosen = chosen
        retries_at_position[total_tokens_added] = 0
        tried_tokens_at_position[total_tokens_added] = {}
        if chosen == 3:
            added_text = added_text[:-1]
        else:","
            attention_mask = attention_mask_temp
            positional_ids = positional_ids_temp
            total_tokens_added += 1
            retries_at_position[total_tokens_added] = 0
            tried_tokens_at_position[total_tokens_added] = {}
            
            if min_backspace_prob_token is not None:
                tried_tokens_at_position[total_tokens_added][min_backspace_prob_token] = \
                    tried_tokens_at_position[total_tokens_added - 1][min_backspace_prob_token]"
"import { Elysia, t } from ""elysia"";
import { jwtConfig } from ""../utils/jwt.config"";
import BookingController from ""../controllers/BookingController"";

const bookingRoutes = new Elysia({ prefix: ""/api/v1/bookings"" })
  .derive(async ({ headers, jwt_auth }) => {
    const auth = headers[""authorization""];
    const token = auth && auth.startsWith(""Bearer "") ? auth.slice(7) : null;

    if (!token) {
      throw new Error(
        JSON.stringify({
          message: ""Unauthorized"",
          errors: [
            {
              type: ""AuthError"",
              path: [""authorization""],
              message: ""Token is missing"",
            },
          ],
        })
      );
    }
    console.log(token);

    try {
      const data = await jwt_auth.verify(token);
      console.log(data);

      return { userId: data?.id };
    } catch (error) {
      throw new Error(
        JSON.stringify({
          message: ""Unauthorized"",
          errors: [
            {
              type: ""AuthError"",
              path: [""authorization""],
              message: ""Invalid or expired token"",
            },
          ],
        })
      );
    }
  })
  .get(
    ""/"",
    async ({ request, query, userId }) => {
      const bookingController = new BookingController();
      return bookingController.getBookings({ ...query, userId });
    },
    {
      detail: {
        tags: [""Bookings""],
        summary: ""Get all bookings"",
        description:
          ""Retrieve a paginated list of bookings with optional filters"",
      },
      query: t.Object({
        page: t.Optional(t.Number({ minimum: 1 })),
        limit: t.Optional(t.Number({ minimum: 1, maximum: 100 })),
        status: t.Optional(t.String()),
        paymentStatus: t.Optional(t.String()),
        startDate: t.Optional(t.String()),
        endDate: t.Optional(t.String()),
        sortBy: t.Optional(t.String()),
        sortOrder: t.Optional(t.Union([t.Literal(""asc""), t.Literal(""desc"")])),
      }),
    }
  )
  .get(
    ""/:id"",
    async ({ request, params: { id }, userId }) => {
      const bookingController = new BookingController();
      return bookingController.getBookingById(id, userId);
    },
    {
      detail: {
        tags: [""Bookings""],
        summary: ""Get booking by ID"",
        description: ""Retrieve detailed information about a specific booking"",
      },
    }
  )
  .post(
    ""/"",
    async ({ request, body, userId }) => {
      const bookingController = new BookingController();
      return bookingController.createBooking({ ...body, userId });
    },
    {
      detail: {
        tags: [""Bookings""],
        summary: ""Create a new booking"",
        description: ""Create a new booking for hotel, vehicle, or package"",
      },
      body: t.Object({
        hotelBooking: t.Optional(
          t.Object({
            hotelId: t.String(),
            roomIds: t.Array(t.String()),
            checkIn: t.String(),
            checkOut: t.String(),
            numberOfGuests: t.Number(),
            numberOfNights: t.Number(),
            specialRequests: t.Optional(t.String()),
          })
        ),
        vehicleBooking: t.Optional(
          t.Object({
            vehicleId: t.String(),
            pickupDate: t.String(),
            returnDate: t.String(),
            pickupLocation: t.Object({
              address: t.String(),
              city: t.String(),
              country: t.String(),
              coordinates: t.Optional(
                t.Object({
                  latitude: t.Number(),
                  longitude: t.Number(),
                })
              ),
            }),
            dropoffLocation: t.Object({
              address: t.String(),
              city: t.String(),
              country: t.String(),
              coordinates: t.Optional(
                t.Object({
                  latitude: t.Number(),
                  longitude: t.Number(),
                })
              ),
            }),
            numberOfDays: t.Number(),
            driverDetails: t.Optional(
              t.Object({
                name: t.String(),
                licenseNumber: t.String(),
                contactNumber: t.String(),
              })
            ),
          })
        ),
        packageBooking: t.Optional(
          t.Object({
            packageId: t.String(),
            startDate: t.String(),
            participants: t.Array(
              t.Object({
                type: t.Union([
                  t.Literal(""adult""),
                  t.Literal(""child""),
                  t.Literal(""infant""),
                ]),
                count: t.Number(),
              })
            ),
            customizations: t.Optional(
              t.Array(
                t.Object({
                  type: t.Union([
                    t.Literal(""hotel""),
                    t.Literal(""activity""),
                    t.Literal(""transportation""),
                  ]),
                  itemId: t.String(),
                  details: t.Optional(t.String()),
                })
              )
            ),
          })
        ),
      }),
    }
  )
  .put(
    ""/:id"",
    async ({ request, params: { id }, body, userId }) => {
      const bookingController = new BookingController();
      return bookingController.updateBooking(id, body, userId);
    },
    {
      detail: {
        tags: [""Bookings""],
        summary: ""Update a booking"",
        description: ""Update an existing booking's details"",
      },
      body: t.Object({
        status: t.Optional(t.String()),
        hotelBooking: t.Optional(
          t.Object({
            checkIn: t.Optional(t.String()),
            checkOut: t.Optional(t.String()),
            numberOfGuests: t.Optional(t.Number()),
            specialRequests: t.Optional(t.String()),
          })
        ),
        vehicleBooking: t.Optional(
          t.Object({
            pickupDate: t.Optional(t.String()),
            returnDate: t.Optional(t.String()),
            pickupLocation: t.Optional(
              t.Object({
                address: t.String(),
                city: t.String(),
                country: t.String(),
              })
            ),
            dropoffLocation: t.Optional(
              t.Object({
                address: t.String(),
                city: t.String(),
                country: t.String(),
              })
            ),
          })
        ),
        packageBooking: t.Optional(
          t.Object({
            startDate: t.Optional(t.String()),
            participants: t.Optional(
              t.Array(
                t.Object({
                  type: t.Union([
                    t.Literal(""adult""),
                    t.Literal(""child""),
                    t.Literal(""infant""),
                  ]),
                  count: t.Number(),
                })
              )
            ),
          })
        ),
      }),
    }
  )
  .post(
    ""/:id/cancel"",
    async ({ request, params: { id }, userId }) => {
      const bookingController = new BookingController();
      return bookingController.cancelBooking(id, userId);
    },
    {
      detail: {
        tags: [""Bookings""],
        summary: ""Cancel a booking"",
        description:
          ""Cancel an existing booking and process refund if applicable"",
      },
    }
  )
  .post(
    ""/:id/itinerary/progress"",
    async ({ request, params: { id }, body, userId }) => {
      const bookingController = new BookingController();
      return bookingController.updateItineraryProgress(
        id,
        body.activityId,
        body.status,
        userId
      );
    },
    {
      detail: {
        tags: [""Bookings""],
        summary: ""Update itinerary progress"",
        description:
          ""Update the progress of activities in a booking's itinerary"",
      },
      body: t.Object({
        activityId: t.String(),
        status: t.Union([t.Literal(""completed""), t.Literal(""upcoming"")]),
      }),
    }
  )
  .get(
    ""/my-bookings"",
    async ({ request, query, userId }) => {
      const bookingController = new BookingController();
      return bookingController.getUserBookings(userId, query);
    },
    {
      detail: {
        tags: [""Bookings""],
        summary: ""Get logged-in user's bookings"",
        description:
          ""Retrieve a paginated list of bookings for the authenticated user"",
        security: [{ bearerAuth: [] }],
      },
      query: t.Object({
        page: t.Optional(t.Number({ minimum: 1 })),
        limit: t.Optional(t.Number({ minimum: 1, maximum: 100 })),
        status: t.Optional(t.String()),
        paymentStatus: t.Optional(t.String()),
        startDate: t.Optional(t.String()),
        endDate: t.Optional(t.String()),
        sortBy: t.Optional(t.String()),
        sortOrder: t.Optional(t.Union([t.Literal(""asc""), t.Literal(""desc"")])),
          bookingType: t.Optional","
      }),
    }
  );

export default bookingRoutes;
",qwen-2.5-coder-32b-instruct,gpt-4o-mini-2024-07-18,0.0,"(t.Union([t.Literal(""hotel""), t.Literal(""vehicle""), t.Literal(""package"")])),",(
"import java.util.*;

public class traversals {
    static class Node {
        int data;
        Node left;
        Node right;

        Node(int data) {
            this.data = data;
            this.left = null;
            this.right = null;
        }
    }

    public static void preOrder(Node root) {
        if (root == null) {
            // System.out.print(""-1 "");
            return;
        }
        System.out.print(root.data + "" "");
        preOrder(root.left);
        preOrder(root.right);
    }

    public static void inOrder(Node root) {
        if (root == null) {
            // System.out.print(""-1 "");
            return;
        }
        inOrder(root.left);
        System.out.print(root.data + "" "");
        inOrder(root.right);
    }

    public static void postOrder(Node root) {
        if (root == null) {
            // System.out.print(""-1 "");
            return;
        }
        postOrder(root.left);
        postOrder(root.right);
        System.out.print(root.data + "" "");
    }

    public static void leverOrder(Node root) {
        if (root == null) {
            return;
        }
        Queue<Node> queue = new LinkedList<Node>();
        queue.add(root);
        queue.add(null);
        while (!queue.isEmpty()) {
            Node temp = queue.remove();
            if (temp == null) {
                System.out.println();
                if (!queue.isEmpty()) {
                    queue.add(null);
                }
            } else {
                System.out.print(temp.data + "" "");
                if (temp.left != null) {
                    queue.add(temp.left);
                }
                if (temp.right != null) {
                    queue.add(temp.right);
                }
            }
        }
    }

    // public static void leverOrder(Node root){
    // if(root == null){
    // return;
    // }
    // Queue<Node> queue = new LinkedList<Node>();
    // queue.add(root);
    // while(!queue.isEmpty()){
    // Node temp = queue.remove();
    // System.out.print(temp.data + "" "");
    // if(temp.left != null){
    // queue.add(temp.left);
    // }
    // if(temp.right != null){
    // queue.add(temp.right);
    // }
    // }
    // }

    public static int height(Node root) {
        if (root == null) {
            return 0;
        }
        int lh = height(root.left);
        int rh = height(root.right);
        return Math.max(lh, rh) + 1;
    }

    public static int count(Node root) {
        if (root == null) {
            return 0;
        }
        int leftCount = count(root.left);
        int rightCount = count(root.right);
        return leftCount + rightCount + 1;
    }

    public static int sumOfNodes(Node root) {
        if (root == null) {
            return 0;
        }
        int leftSum = sumOfNodes(root.left);
        int rightSum = sumOfNodes(root.right);
        return leftSum + rightSum + root.data;
    }

    public static int diameter(Node root) { // O(n^2);
        if (root == null) {
            return 0;
        }
        int leftDiameter = diameter(root.left);
        int rightDiameter = diameter(root.right);
        int leftHeight = height(root.left);
        int rightHeight = height(root.right);
        int selfDiameter = leftHeight + rightHeight + 1;
        return Math.max(selfDiameter, Math.max(leftDiameter, rightDiameter));
    }

    static class Info {
        int dia;
        int height;

        Info(int dia, int height) {
            this.dia = dia;
            this.height = height;
        }
    }

    public static Info diameter2(Node root) { // O(n);
        if (root == null) {
            return new Info(0, 0);
        }
        Info leftInfo = diameter2(root.left);
        Info rightInfo = diameter2(root.right);

        int diam = Math.max(Math.max(leftInfo.dia, rightInfo.dia), leftInfo.height + rightInfo.height + 1);
        int ht = Math.max(leftInfo.height, rightInfo.height) + 1;

        return new Info(diam, ht);
    }

    public static boolean isSubTree(Node root, Node subRoot) {
        if (root == null) {
            return false;
        }
        if (areIdentical(root, subRoot)) {
            return true;
        }
        return isSubTree(root.left, subRoot) || isSubTree(root.right, subRoot);
    }

    public static boolean areIdentical(Node root, Node subRoot) {
        if (root == null && subRoot == null) {
            return true;
        }
        if (root == null || subRoot == null) {
            return false;
        }
        return (root.data == subRoot.data && areIdentical(root.left, subRoot.left)
                && areIdentical(root.right, subRoot.right));
    }

    public static boolean isIdentical(Node root, Node subRoot) {
        if (root == null && subRoot == null) {
            return true;
        } else if (root == null || subRoot == null || root.data != subRoot.data) {
            return false;
        }
        if (!isIdentical(root.left, subRoot.left)) {
            return false;
        }
        if (!isIdentical(root.right, subRoot.right)) {
            return false;
        }
        return true;
    }

    static class Info2 {
        Node node;
        int hd;

        Info2(Node node, int hd) {
            this.node = node;
            this.hd = hd;
        }
    }

    public static void topView(Node root) {
        // Lever Order
        Queue<Info2> queue = new LinkedList<Info2>();
        HashMap<Integer, Node> map = new HashMap<>();

        int min = 0, max = 0;
        queue.add(new Info2(root, 0));
        queue.add(null);
        while (!queue.isEmpty()) {
            Info2 temp = queue.remove();
            if (temp == null) {
                if (!queue.isEmpty()) {
                    queue.add(null);
                }
            } else {
                if (!map.containsKey(temp.hd)) { // first time hd is occuring.
                    map.put(temp.hd, temp.node);
                }
                if (temp.node.left != null) {
                    queue.add(new Info2(temp.node.left, temp.hd - 1));
                    min = Math.min(min, temp.hd - 1); // to see if we are going further left.
                }
                if (temp.node.right != null) {
                    queue.add(new Info2(temp.node.right, temp.hd + 1));
                    max = Math.max(max, temp.hd + 1); // to see if we are going further right.
                }
            }
        }

        for (int i = min; i <= max; i++) {
            System.out.print(map.get(i).data + "" "");
        }
        System.out.println();
    }

    public static void kthLevelIterative(Node root, int k) {
        // Lever Order
        Queue<Node> queue = new LinkedList<Node>();
        queue.add(root);
        queue.add(null);
        int level = 1;
        while (!queue.isEmpty()) {
            Node temp = queue.remove();
            if (temp == null) {
                level++;
                if (!queue.isEmpty()) {
                    queue.add(null);
                }
            } else {
                if (level == k) {
                    System.out.print(temp.data + "" "");
                }
                if (temp.left != null) {
                    queue.add(temp.left);
                }
                if (temp.right != null) {
                    queue.add(temp.right);
                }
            }
        }
        System.out.println();
    }

    public static void kthLeverRecursive(Node root, int level, int k){
        if (root == null) {
            return;
        }
        if (level == k) {
            System.out.print(root.data + "" "");
        }
        kthLeverRecursive(root.left, level + 1, k);
        kthLeverRecursive(root.right, level + 1, k);
    }

    // lowest common ancestor
    public static Node lca(Node root, int n1, int n2){
        ArrayList<Integer> path1 = new ArrayList<>();
        ArrayList<Integer> path2 = new ArrayList<>();
        getPath(root, n1, path1);
        getPath(root, n2, path2);

        //last common ancestor
        int i = 0;
        for(; i < path1.size() && i < path2.size()){
            if(path1.get(i) != path2.get(i)){
                break;
            }
        }
        // last equal node -> i - 1;
        return ","
    }

    public static void main(String args[]) {
        Node root = new Node(1);
        root.left = new Node(2);
        root.right = new Node(3);
        root.left.left = new Node(4);
        root.left.right = new Node(5);
        root.right.left = new Node(6);
        root.right.right = new Node(7);

        // System.out.println(""Preorder traversal:"");
        // preOrder(root);
        // System.out.println();
        // System.out.println(""Inorder traversal:"");
        // inOrder(root);
        // System.out.println();
        // System.out.println(""Postorder traversal:"");
        // postOrder(root);
        // System.out.println();
        // System.out.println(""LeverOrder traversal:"");
        // leverOrder(root);
        // System.out.print(""Height of the tree is: "");
        // System.out.println(height(root));
        // System.out.print(""Count of the tree is: "");
        // System.out.println(count(root));
        // System.out.print(""Sum of nodes in the tree is: "");
        // System.out.println(sumOfNodes(root));
        // System.out.print(""Diameter of the tree is: "");
        // System.out.println(diameter(root));
        // System.out.print(""Diameter of the tree is: "");
        // System.out.println(diameter2(root).dia);
        // Node subRoot = new Node(2);
        // subRoot.left = new Node(4);
        // subRoot.right = new Node(5);
        // System.out.print(""Is subtree: "");
        // System.out.println(isSubTree(root, subRoot));
        // System.out.println(""Top view of the tree is: "");
        // topView(root);
        printTree2(root);

        kthLevelIterative(root, 3);
        kthLeverRecursive(root, 1, 3);
        System.out.println();
    }

    

    // Method 1: Simple but less visually aligned printing
    static void printTree1(Node root, String indent, String prefix) {
        if (root == null)
            return;

        System.out.println(indent + prefix + root.data);
        printTree1(root.left, indent + ""   "", ""L:"");
        printTree1(root.right, indent + ""   "", ""R:"");
    }

    // Method 2: More visually aligned tree printing
    static void printTree2(Node root) {
        int maxLevel = getMaxLevel(root);
        printNodeInternal(Collections.singletonList(root), 1, maxLevel);
    }

    private static void printNodeInternal(List<Node> nodes, int level, int maxLevel) {
        if (nodes.isEmpty() || isAllElementsNull(nodes))
            return;

        int floor = maxLevel - level;
        int edgeLines = (int) Math.pow(2, (Math.max(floor - 1, 0)));
        int firstSpaces = (int) Math.pow(2, (floor)) - 1;
        int betweenSpaces = (int) Math.pow(2, (floor + 1)) - 1;

        printWhitespaces(firstSpaces);

        List<Node> newNodes = new ArrayList<>();
        for (Node node : nodes) {
            if (node != null) {
                System.out.print(node.data);
                newNodes.add(node.left);
                newNodes.add(node.right);
            } else {
                newNodes.add(null);
                newNodes.add(null);
                System.out.print("" "");
            }
            printWhitespaces(betweenSpaces);
        }
        System.out.println();

        for (int i = 1; i <= edgeLines; i++) {
            for (Node node : nodes) {
                printWhitespaces(firstSpaces - i);
                if (node == null) {
                    printWhitespaces(edgeLines + edgeLines + i + 1);
                    continue;
                }

                if (node.left != null)
                    System.out.print(""/"");
                else
                    printWhitespaces(1);

                printWhitespaces(i + i - 1);

                if (node.right != null)
                    System.out.print(""\\"");
                else
                    printWhitespaces(1);

                printWhitespaces(edgeLines + edgeLines - i);
            }
            System.out.println();
        }

        printNodeInternal(newNodes, level + 1, maxLevel);
    }

    private static void printWhitespaces(int count) {
        for (int i = 0; i < count; i++)
            System.out.print("" "");
    }

    private static int getMaxLevel(Node node) {
        if (node == null)
            return 0;
        return Math.max(getMaxLevel(node.left), getMaxLevel(node.right)) + 1;
    }

    private static boolean isAllElementsNull(List<Node> list) {
        for (Object object : list) {
            if (object != null)
                return false;
        }
        return true;
    }
}
",llama-3.1-405b-instruct,llama-3.1-70b-instruct,0.0,new Node(path1.get(i - 1));,"new Info2(path1.get(i - 1), path1.get(i - 1));
    }

    public static boolean getPath(Node root, int n1, ArrayList<Integer> path) {
        if (root == null) {
            return false;
        }
        path.add(root.data);
        if (root.data == n1) {
            return true;
        }
        if (root.left != null && getPath(root.left, n1, path)) {
            return true;
        }
        if (root.right != null && getPath(root.right, n1, path)) {
            return true;
        }
        path.remove(path.size() - 1);
        return false;"
"{
    ""name"": ""John Doe"",
    ""age"": 30,
    ","
}",gemini-1.5-pro-002,qwen-2.5-coder-32b-instruct,0.0,"""occupation"": ""Software Engineer""","""age"": 30,"
"import sys
import   json   as json    
","        
sys.path.append(os.path.join(os.path.dirname(__file__), '..'))
sys.path.append(os.path.join(os.path.dirname(__file__), '..'))



sys.path.append(os.path.join(os.path.dirname(__file__), '..'))


sys.path.append(os.path.join(os.path.dirname(__file__), '..'))

# Definicija klase Event
import        os 
class Event:
    def __init__(self, data):
        self.data = data

class State:
    def __init__(self, value):
        self.value = value

    def update(self, event):
        if event.data == ""increment"":
            self.value += 1
        elif event.data == ""decrement"":
            self.value -= 1

# Inicijalno stanje
state = State(0)

# Lista događaja
events = [Event(""increment""), Event(""increment""), Event(""decrement"")]

# Obrada događaja
for event in events:
    state.update(event)
    print(f""Current state: {state.value}"")",gemini-1.5-flash-002,gpt-4o-2024-08-06,0.0,"
import        os",import os
"import vnstock

for i in range(dir(vnstock)):
    print(i,",")

",llama-3.1-70b-instruct,llama-3.1-405b-instruct,0.0,    print(dir(vnstock)[i],dir(vnstock)[i]
"# ---------------------------------------------------------
# Copyright (c) Microsoft Corporation. All rights reserved.
# ---------------------------------------------------------

from promptflow.core import tool
import instructor
from promptflow.connections import CustomConnection
from google.generativeai import genai
from src.schemas.classif import create_file_classification

# The inputs section will change based on the arguments of the tool function, after you save the code
# Adding type to arguments and return value will help the system show the types properly
# Please update the function name/signature per need


@tool
def my_python_tool(gemini_connection : CustomConnection ,file_path: str,symstem_prompt: str, user_prompt: str) -> str:
    
    safe = [
        {
            ""category"" : ""HARM_CATEGORY_DANGEROUS""
            ,""threshold"" : ""BLOCK_NONE""
        },
        {
            ""category"" : ""HARM_CATEGORY_HARASSMENT""
            ,""threshold"" : ""BLOCK_NONE""
        },
        {
            ""category"" : ""HARM_CATEGORY_HATE_SPEECH""
            ,""threshold"" : ""BLOCK_NONE""
        },
        {
            ""category"" : ""HARM_CATEGORY_SEXUALLY_EXPLICIT""
            ,""threshold"" : ""BLOCK_NONE""
        },
        {
            ""category"" : ""HARM_CATEGORY_SECURITY""
            ,""threshold"" : ""BLOCK_NONE""
        }
    ]

    genai.configure(api_key=gemini_connection.api_key)

    client_gemini = instructor.from_gemini(
        client = genai.GenerativeAI(
            model_name=""gemini-1.5-flash-8b-001""
            safe","
        )
    )
   
    




    return ""pass"" 
",codestral-2405,gpt-4o-mini-2024-07-18,0.0,"_settings = safe
        )
    )",=safe
"from dataclasses import dataclass, field
from datetime import datetime, timedelta
from pathlib import Path


@dataclass
class Video:
    original_path: Path
    camera_number: int | None = None
    start_datetime: datetime | None = None
    end_datetime: datetime | None = None
    repack_path: Path | None = None
    duration: timedelta | None = None

    @property
    def path(self) -> Path:
        if self.repack_path is not None:
            return self.repack_path
        return self.original_path

    @property
    def suffix(self) -> str:
        return self.path.suffix

    def remove_repack(self) -> None:
        if self.repack_path is not None:
            self.repack_path.unlink()
            self.repack_path = None


@dataclass
class VideoSequence:
    _videos: list[Video] = field(default_factory=list)

    @property
    def videos(self) -> list[Path]:
        return [video.path for video in self._videos]

    @property
    def back(self) -> Video | None:
        if len(self._videos):
            return self._videos[-1]
        return None

    @property
    def duration(self) -> timedelta:
        return sum(
            [video.duration for video in self._videos if video.duration is not None],
            timedelta(),
        )

    @property
    def camera_number(self) -> int | None:
        return self._videos[0].camera_number if len(self._videos) else None

    @property
    def start_datetime(self) -> datetime | None:
        return self._videos[0].start_datetime if len(self._videos) else None

    @property
    def end_datetime(self) -> datetime | None:
        if (
            len(self._videos) == 0
            or self._videos[-1].start_datetime is None
            or self._videos[-1].duration is None
        ):
            return None
        return self._videos[-1].start_datetime + self._videos[-1].duration

    @property
    def suffix(self) -> str | None:
        return self._videos[-1].path.suffix if len(self._videos) > 0 else None

    def name(self, video_datetime_format: str | None = None) -> str | None:
        if not self._videos:
            return None
        if (
            self.start_datetime is None
            or self.end_datetime is None
            or self.camera_number is None
            or self.suffix is None
            or video_datetime_format is None
        ):
            return f""{self._videos[0].path.name}""

        return ""{}_{}_{}{}"".format(
            self.start_datetime.strftime(video_datetime_format),
            self.end_datetime.strftime(video_datetime_format),
            self.camera_number,
            self.suffix,
        )

    def is_sutable_video(self, video: Video):
        if not len(self._videos):
            return True
        ","

    def append(self, video: Video) -> None:
        self._videos.append(video)

    def remove_repacks(self) -> None:
        for video in self._videos:
            video.remove_repack()
",qwen-2.5-coder-32b-instruct,claude-3-5-sonnet-20241022,1.0,if self.camera_number != video.camera_number:,"if not len(self._videos):
            return True

        if (
            video.camera_number != self.camera_number
            or video.start_datetime is None
            or self.end_datetime is None
            or video.start_datetime > self.end_datetime + timedelta(seconds=1)
        ):
            return False
        return True"
"""""""# HSE 2024: Mathematical Methods for Data Analysis

## Homework 4

**Warning 1**: You have 10 days for this assignemnt.  **it is better to start early (!)**

**Warning 2**: it is critical to describe and explain what you are doing and why, use markdown cells


### Contents

#### Decision Trees - 7 points
* [Task 1](#task1) (0.5 points)
* [Task 2](#task2) (0.5 points)
* [Task 3](#task3) (2 points)
* [Task 4](#task4) (0.5 points)
* [Task 5](#task5) (0.5 points)
* [Task 6](#task6) (2 points)
* [Task 7](#task7) (0.5 points)
* [Task 8](#task8) (0.5 points)

#### Ensembles - 3 points
* [Task 1](#task2_1) (1 point)
* [Task 2](#task2_2) (0.7 points)
* [Task 3](#task2_3) (0.5 points)
* [Task 4](#task2_4) (0.7 points)
* [Task 5](#task2_5) (0.1 points)""""""

import matplotlib.pyplot as plt
import numpy as np
import pandas as pd

plt.rcParams['figure.figsize'] = (11, 5)
%matplotlib inline

RANDOM_STATE = 42

""""""# Part 1. Decision Tree Regressor""""""

""""""In this task you will be implementing decision tree for the regression by hand. """"""

""""""### Task 1 <a id=""task1""></a> (0.5 points)

Here you should implement the function `H()` which calculates impurity criterion. We will be training regression tree, and will take mean absolute deviation as impurity criterion.

* You cannot use loops
* If `y` is empty, the function should return 0""""""

def H(y):
    """"""
    Calculate impurity criterion
    
    Parameters
    ----------
    y : np.array
        array of objects target values in the node

    Returns
    -------
    H(R) : float
        Impurity in the node (measuread by variance)
    """"""
    if len(y) == 0:
        return 0.0
    
    return np.var(y, ddof=0)

# Test the function
assert np.allclose(H(np.array([4, 2, 2, 2])), 0.75)
assert np.allclose(H(np.array([])), 0.0)

""""""### Task 2 <a id=""task2""></a>  (0.5 points)

To find the best split in the node we need to calculate the cost function. Denote: 
- `R` all the object in the node
- `j` index of the feature selected for the split
- `t` threshold
- `R_l` and `R_r` objects in the left and right child nodes correspondingly

We get the following cost function:

$$
Q(R, j, t) =\frac{|R_\ell|}{|R|}H(R_\ell) + \frac{|R_r|}{|R|}H(R_r) \to \min_{j, t},
$$

Implement the function `Q`, which should calculate value of the cost function for a given feature and threshold.""""""

def Q(X, y, j, t):
    """"""
    Calculate cost function
    Parameters
    ----------
    X : ndarray
        array of objects in the node 
    y : ndarray
        array of target values in the node 
    j : int
        feature index (column in X)
    t : float
        threshold

    Returns
    -------
    Q : float
        Value of the cost function
    """"""   
    
    y_l = y[X[:, j] <= t]
    y_r = y[X[:, j] > t]
    
    total_size = len(y)
    size_l = len(y_l)
    size_r = len(y_r)
    
    H_l = H(y_l)
    H_r = H(y_r)
    
    # YOUR CODE HERE
    return (size_l / total_size) * H_l + (size_r / total_size) * H_r

""""""### Task 3 <a id=""task3""></a>  (2 points)

Now, let's implement `MyDecisionTreeRegressor` class. More specifically, you need to implement the following methods:

- `best_split`
- `grow_tree`
- `get_prediction`

Also, please add `min_samples_leaf` parameter to your class

Read docstrings for more details. Do not forget to use function `Q` implemented above, when finding the `best_split`""""""

class Node(object):
    """"""
    Class for a decision tree node.
    
    Parameters
    ----------
    right : Node() or None
        Right child
    left : Node() or None
        Left child
    threshold: float
        
    column: int
        
    depth: int
        
    prediction: float
        prediction of the target value in the node 
        (average values calculated on a train dataset)
    is_terminal:bool
        indicates whether it is a terminal node (leaf) or not
    """"""    
    def __init__(self, threshold=0, column = 0, depth=0, prediction=0.0, is_terminal=False):        
        self.left = None
        self.right = None
        self.threshold = threshold
        self.column = column
        self.depth = depth
        self.is_terminal = is_terminal
        self.prediction = prediction
        
    def __repr__(self):
        if self.is_terminal:
            node_desc = 'Pred: {:.2f}'.format(self.prediction)
        else:
            node_desc = 'Col {}, t {:.2f}, Pred: {:.2f}'. \
            format(self.column, self.threshold, self.prediction)
        return node_desc

from sklearn.base import BaseEstimator, RegressorMixin
from sklearn.utils.validation import check_X_y, check_array, check_is_fitted

class MyDecisionTreeRegressor(RegressorMixin, BaseEstimator):
    """"""
    Class for a Decision Tree Regressor.

    Parameters
    ----------
    max_depth : int
        Max depth of a decision tree.
    min_samples_split : int
        Minimal number of samples (objects) in a node to make a split.
    min_samples_leaf: int 
        Minimum number of samples (objects) in left and right branches after splitting the current node
    """""" 
    def __init__(self, max_depth=3, min_samples_split=2, min_samples_leaf=1):
        self.max_depth = max_depth
        self.min_samples_split = min_samples_split
        self.min_samples_leaf = min_samples_leaf
            
    def best_split(self, X: np.ndarray, y: np.ndarray):
        """"""
        Find the best split in terms of Q of data in a given decision tree node. 
        Try all features and thresholds. 
        
        Parameters
        ----------
        X : ndarray, shape (n_objects, n_features)
            Objects in the parent node
        y : ndarray, shape (n_objects, )
            1D array with the object labels. 
            
        Returns
        -------
        best_split_column : int
            Index of the best split column
        best_threshold : float
            The best split condition.
        X_left : ndarray, shape (n_objects_l, n_features)
            Objects in the left child
        y_left : ndarray, shape (n_objects_l, )
            Objects labels in the left child. 
        X_right : ndarray, shape (n_objects_r, n_features)
            Objects in the right child
        y_right : ndarray, shape (n_objects_r, )
            Objects labels in the right child. 
        """"""
        
        # To store best split parameters
        best_split_column = None
        best_threshold = None
        # without splitting
        best_cost = H(y) 
        
        if X.shape[0] < self.min_samples_split:
            return None, None, X, y, np.array([]), np.array([])
        
        X_left, X_right = X, np.array([])
        y_left, y_right = y, np.array([])
        
        for j in range(X.shape[1]):
            for threshold in X[self.min_samples_leaf: X.shape[0] - self.min_samples_leaf, j]:
                cur_Q = Q(X, y, j, threshold)
                
                if cur_Q < best_cost:
                    best_cost = cur_Q
                    best_split_column = j
                    best_threshold = threshold
                    
                    X_left = X[X[:, j] <= threshold]
                    X_right = X[X[:, j] > threshold]
                    
                    y_left = y[X[:, j] <= threshold]
                    y_right = y[X[:, j] > threshold]
        
        
        return best_split_column, best_threshold, X_left, y_left, X_right, y_right
    
    def is_terminal(self, node: Node, y: np.ndarray):
        """"""
        Check terminality conditions based on `max_depth`, 
        `min_samples_split` parameters for a given node. 
        
        Parameters
        ----------
        node : Node, 
            
        y : ndarray, shape (n_objects, )
            Object labels. 
            
        Returns
        -------
        Is_termial : bool
            If True, node is terminal
        """"""
        if node.depth >= self.max_depth:    
            return True
        if len(y) < self.min_samples_split:   
            return True
        return False
        
    def grow_tree(self, node: Node, X: np.ndarray, y: np.ndarray):
        """"""
        Reccurently grow the tree from the `node` using a `X` and `y` as a dataset:
         - check terminality conditions
         - find best split if node is not terminal
         - add child nodes to the node
         - call the function recursively for the added child nodes
        
        Parameters
        ----------
        node : Node() object
            Current node of the decision tree.
        X : ndarray, shape (n_objects, n_features)
            Objects 
        y : ndarray, shape (n_objects)
            Labels
        """"""
        
        if self.is_terminal(node, y):
            node.is_terminal =True
            node.prediction = np.mean(y)
            return
                
        split_col, threshold, X_left, y_left, X_right, y_right = self.best_split(X, y)
        
        if split_col is None:
            node.is_terminal = True
            node.prediction = np.mean(y)
            return
        
        node.column = split_col
        node.threshold = threshold
        
        # Create child nodes
        node.left = Node(depth=node.depth + 1)
        node.right = Node(depth=node.depth + 1)
        
        # Recursively grow the tree
        self.grow_tree(node.left, X_left, y_left)
        self.grow_tree(node.right, X_right, y_right)
        

    def fit(self, X, y):
        """"""
        Fit the Decision Tree Regressor.
            
        Parameters
        ----------
        X : ndarray, shape (n_samples, n_features)
            The input samples.
        y : ndarray, shape (n_samples,) or (n_samples, n_outputs)
            The target values.
        Returns
        -------
        self : object
            Returns self.
        """"""
        X, y = check_X_y(X, y, accept_sparse=False)
        self.is_fitted_ = True
        self.n_features_in_ = X.shape[1]
        
        
        # Initialize the tree (root node)
        self.tree_ = Node()                             
        self.tree_.depth = 1                            
        self.tree_.prediction = np.mean(y)
        
        # Grow the tree
        self.grow_tree(self.tree_, X, y)
        return self        
    
    def get_prediction(self, node: Node, x: np.ndarray):
        """"""
        Get prediction for an object `x`
            - Return prediction of the `node` if it is terminal
            - Otherwise, recursively call the function to get 
            predictions of the proper child
        
        Parameters
        ----------
        node : Node() object
            Current node of the decision tree.
        x : ndarray, shape (n_features,)
            Array of feature values of one object.
        Returns
        -------
        y_pred : float
            Prediction for an object x
        """"""
        if node.is_terminal:
            return node.prediction
        
        if x[node.column] <= node.threshold:
            return self.get_prediction(node.left, x)
        else:
            return self.get_prediction(node.right, x)
    
    def predict(self, X):
        """""" 
        Get prediction for each object in X
        
        Parameters
        ----------
        X : ndarray, shape (n_samples, n_features)
            The input samples.
        Returns
        -------
        y : ndarray, shape (n_samples,)
            Returns predictions.
        """"""
        # Check input and that `fit` had been called
        X = check_array(X, accept_sparse=False)
        check_is_fitted(self, 'is_fitted_')
        
        # Get predictions
        y_predicted = []
        for x in X:
            y_curr = self.get_prediction(self.tree_, x)
            y_predicted.append(y_curr)
        return np.array(y_predicted)

# check yourself
from sklearn.utils.estimator_checks import check_estimator

check_estimator(MyDecisionTreeRegressor())

""""""### Task 4 <a id=""task4""></a>  (0.5 points)

Load boston dataset and split it on the train ($75\%$) and test ($25\%$). Fit Decision Tree of **depth 1 and 2** (root node has **depth 0**) and make the following plot for every case :

- Scatter plot of the traning points for each splitted feature (selected for split feature on the x-axis, target variable on the y-axis). Show the resulting thresholds

After that, fit analogical model from sklearn and visual it

Compare `MAE` on train and test. Have trees overfitted?""""""

from sklearn.datasets import fetch_openml

boston = fetch_openml(name=""boston"", version=1, as_frame=True)
X, y = boston.data, boston.target
feature_names = boston.feature_names
print(boston.DESCR)

X.shape, y.shape

X.head()

y.head()

from sklearn.model_selection import train_test_split

X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.25, random_state=RANDOM_STATE)

X_train

# Helper function to plot the tree
import sklearn
from tqdm import trange


def plot_node_handmade(node, X, y):
    if node is None:
        return
    threshold = node.threshold
    feature_index = node.column

    plt.scatter(X.iloc[:, feature_index], y, alpha=0.5, label='Data points')
    plt.axvline(threshold, color='red', linestyle='--', label='Threshold')
    plt.xlabel(feature_names[feature_index])
    plt.ylabel('MEDV')
    plt.legend()
    plt.show()
    
    plot_node_handmade(node.left, X, y)
    plot_node_handmade(node.right, X, y)

def plot_node_sklearn(tree, X, y):
    for i in trange(tree.threshold.shape[0]):
        threshold = tree.threshold[i]
        feature_index = tree.feature[i]
        
        is_split_node = tree.children_left[i] != tree.children_right[i]
        
        if not is_split_node:
            continue

        plt.scatter(X.iloc[:, feature_index], y, alpha=0.5, label='Data points')
        plt.axvline(threshold, color='red', linestyle='--', label='Threshold')
        plt.xlabel(feature_names[feature_index])
        plt.ylabel('MEDV')
        plt.legend()
        plt.show()

def plot_tree(tree, X, y):
    print(type(tree))
    if isinstance(tree, sklearn.tree._classes.DecisionTreeRegressor):
        plot_node_sklearn(tree.tree_, X, y)
    else:
        plot_node_handmade(tree.tree_, X, y)

""""""#### Depth 1""""""

regressor = MyDecisionTreeRegressor(max_depth=1)

regressor.fit(X_train, y_train)

pred_train = regressor.predict(X_train)
pred_test = regressor.predict(X_test)

plot_tree(regressor, X_train, y_train)

from sklearn.metrics import mean_absolute_error

mae_train = mean_absolute_error(y_train, pred_train)
mae_test = mean_absolute_error(y_test, pred_test)

mae_train, mae_test

""""""Trees did not overfit""""""

from sklearn.tree import DecisionTreeRegressor


regressor = DecisionTreeRegressor(max_depth=1)

regressor.fit(X_train, y_train)

pred_train = regressor.predict(X_train)
pred_test = regressor.predict(X_test)

plot_tree(regressor, X_train, y_train)

from sklearn.metrics import mean_absolute_error

mae_train = mean_absolute_error(y_train, pred_train)
mae_test = mean_absolute_error(y_test, pred_test)

mae_train, mae_test

""""""Those trees didn't overfit either""""""

""""""### Task 5 <a id=""task5""></a>  (0.5 points)

Keep working with boston dataset. 
- Use `GridSearchCV` to find the best hyperparameters among [`max_depth`, `min_samples_leaf`] on 5-Fold cross-validation
- Train the model with the best set of hyperparameters on the whole train dataset. 
- Report `MAE` on test dataset and hyperparameters of the best estimator. """"""


from sklearn.model_selection import GridSearchCV
from sklearn.preprocessing import StandardScaler
from sklearn.pipeline import Pipeline

param_grid = [
    {
        'regressor__max_depth': [1, 2, 3, 4, 5],
        'regressor__min_samples_leaf': [1, 2, 3, 4, 5]
    }
]


pipeline = Pipeline([
    ('scaler', StandardScaler()),
    ('regressor', DecisionTreeRegressor())
])

grid = GridSearchCV(pipeline, param_grid, cv=5, scoring='neg_mean_squared_error', n_jobs=-1)
grid.fit(X_train, y_train)

grid.best_params_

best_estimator = grid.best_estimator_
y_pred = best_estimator.predict(X_test)

mean_absolute_error(y_test, y_pred)


from sklearn.model_selection import GridSearchCV
from sklearn.preprocessing import StandardScaler
from sklearn.pipeline import Pipeline

param_grid = [
    {
        'regressor__max_depth': [1, 2, 3, 4, 5],
        'regressor__min_samples_leaf': [1, 2, 3, 4, 5]
    }
]


pipeline = Pipeline([
    ('scaler', StandardScaler()),
    ('regressor', MyDecisionTreeRegressor())
])

grid = GridSearchCV(pipeline, param_grid, cv=5, scoring='neg_mean_squared_error', n_jobs=-1)
grid.fit(X_train, y_train)

grid.best_params_

best_estimator = grid.best_estimator_
y_pred = best_estimator.predict(X_test)

mean_absolute_error(y_test, y_pred)

""""""### Task 6 <a id=""task6""></a>  (2 points)

Recall definition of bias and variance:
$$
\text{Bias}^2 = \mathbb{E}_{p(x, y)} \left[  (f(x) - \mathbb{E}_{\mathbb{X}}a_{\mathbb{X}}(x))^2 \right] \\
\text{Variance} = \mathbb{E}_{p(x, y)} \left[  \mathbb{V}_{\mathbb{X}}( a_{\mathbb{X}}(x))  \right]
$$

We wil now use the following algorithm to estimate bias and variance:

1. Use bootsrap to create `n_iter` samples from the original dataset: $X_1, \dots, X_{n_iter}$
2. For each bootstrapped sample define out-of-bag (OOB) sample $Z_1, \dots, Z_{n_iter}$, which contain all the observations, which did not appear in the corresponding boostraped sample
3. Fit the model on $X_i$s and compute predictions on $Z_i$s
4. For a given *object* $n$:
     - bias^2: squared difference between true value $y_n$ and average prediction (average over the algorithms, for which $n$ was in OOB)
     - variance: variance of the prediction (predictions of the algorithms, for which $n$ was in OOB)
5. Average bias^2 and variance over all the points
    
**Implement `get_bias_variance` function, using the algorithm above**

*Note:*  You can only use 1 loop (for bootsrap iterations). All other operations should be vectorized. """"""

import numpy as np
from sklearn.utils import resample

def get_bias_variance(estimator, x, y, n_iter):
    """""" 
    Calculate bias and variance of the `estimator`. 
    Using a given dataset and bootstrap with `n_iter` samples. 

    Parameters
    ----------
    x : ndarray, shape (n_samples, n_features)
        The input samples.
    y : ndarray, shape (n_samples, n_features)
        The input samples.
    n_iter: int
        Number of samples in 
    Returns
    -------
    bias2 : float, 
        Estiamted squared bias
    variance : float, 
        Estiamted variance
    """"""
    
    # YOUR CODE HERE

    bias2_list = []
    variance_list = []

    for _ in range(n_iter):
        # Bootstrap sampling
        x_resampled, y_resampled = resample(x, y, replace=True)
        
        # Fit the estimator on the resampled data
        estimator.fit(x_resampled, y_resampled)
        
        # Predict on the original data
        predictions = estimator.predict(x)
        
        # Calculate bias and variance
        bias2 = np.mean((np.mean(predictions) - y) ** 2)
        variance = np.var(predictions)
        
        bias2_list.append(bias2)
        variance_list.append(variance)

    # Average bias^2 and variance over all iterations
    bias2 = np.mean(bias2_list)
    variance = np.mean(variance_list)

    return bias2, variance


# Test
estimator = MyDecisionTreeRegressor(max_depth=4, min_samples_split=15)

get_bias_variance(estimator, X_train.values, y_train, 10)

""""""### Task 7 <a id=""task7""></a>  (0.5 points)

Compute bias and variance for the trees with different min_samples_split. Plot how bias and variance change as min_samples_split increases. 

Comment on what you observe, how does your result correspond to theory?""""""

from tqdm import tqdm

biases = []
vars = []

min_samples = list(range(1, 11))

for min_samples_split in tqdm(min_samples):
    estimator = MyDecisionTreeRegressor(max_depth=4, min_samples_split=min_samples_split)

    bias, var = get_bias_variance(estimator, X_train.values, y_train, 5)
    biases += [bias]
    vars += [var]

plt.plot(min_samples, biases, label='bias')
plt.plot(min_samples, vars, label='variance')

plt.legend(loc='best')
plt.show()

""""""``` your comments here```""""""

""""""### Task 8 <a id=""task8""></a>  (0.5 points)

Let's try to reduce variance with bagging. Use `sklearn.ensemble.BaggingRegressor` to get an ensemble and compute its bias and variance. 

Answer the following questions:
 - How bagging should affect bias and variance in theory?
 - How bias and variance change (if they change) compared to an individual tree in you experiments? 
 - Do your results align with the theory? Why?""""""

from sklearn.ensemble import BaggingRegressor

from tqdm import tqdm

biases = []
vars = []

min_samples = list(range(1, 11))

for min_samples_split in tqdm(min_samples):
    estimator = BaggingRegressor(
        MyDecisionTreeRegressor(max_depth=4, min_samples_split=min_samples_split),
        n_estimators=5
    )

    bias, var = get_bias_variance(estimator, X_train.values, y_train, 5)
    biases += [bias]
    vars += [var]

plt.plot(min_samples, biases, label='bias')
plt.plot(min_samples, vars, label='variance')

plt.legend(loc='best')
plt.show()

""""""```your comments here```""""""

""""""# Part 2. More Ensembles""""""

""""""In this part we will be working with [Billionaires Statistics Dataset](https://www.kaggle.com/datasets/nelgiriyewithana/billionaires-statistics-dataset) to solve a classification task. """"""

import kagglehub

# Download latest version
path = kagglehub.dataset_download(""nelgiriyewithana/billionaires-statistics-dataset"")

print(""Path to dataset files:"", path)

from sklearn.preprocessing import LabelEncoder

df = pd.read_csv(path + '/Billionaires Statistics Dataset.csv')

le = LabelEncoder()
y = le.fit_transform(df['selfMade'])
X = df.drop('selfMade', axis=1)
X.head(5)

y[:5]

""""""### Task 1 <a id=""task2_1""></a> (1 point)

Let's start with data preprocessing. 

0. Drop columns, which are not usefull (e.g. a lot of missing values). Motivate your choice. 
1. Split dataset into train and test
2. You've probably noticed that we have both categorical and numerical columns. Here is what you need to do with them:
    - Categorical: Fill missing values and apply one-hot-encoding (if there are more than 10 unique values in a column, use `min_frequency` and/or `max_categories` parameter)
    - Numeric: Fill missing values
    
Use `ColumnTranformer` to define a single transformer for all the columns in the dataset. It takes as input a list of tuples

```
ColumnTransformer([
    ('name1', transform1, column_names1),
    ('name2', transform2, column_names2)
])
```

Pay attention to an argument `remainder='passthrough'`. [Here](https://scikit-learn.org/stable/modules/compose.html#column-transformer) you can find some examples of how to use column transformer. 
    
Since we want to apply 2 transformations to categorical feature, it is very convenient to combine them into a `Pipeline`:

```
double_tranform = make_pipeline(
                        transform_1,
                        transform_2
                        )
```

P.S. Choose your favourite way to fill missing values. 

*Hint* Categorical column usually have `dtype = 'object'`. This may help to obtain list of categorical and numerical columns on the dataset. """"""

(X.notna().sum() / X.shape[0]).sort_values()

""""""Dropping the following columns as they have <30% of non-NaN vales:

organization
title
residenceStateRegion
state""""""

X_preprocessed = X.drop(['organization', 'title', 'residenceStateRegion', 'state'], axis=1)
X_preprocessed.info()

for column in X_preprocessed.columns:
    print(f""Column {column}: {len(X_preprocessed[column].value_counts())}"")

cat_columns = list(filter(lambda x: X_preprocessed[x].dtype == 'object', X_preprocessed.columns))
cat_columns

num_columns = list(set(X_preprocessed.columns) - set(cat_columns))
num_columns

from sklearn.pipeline import make_pipeline
from sklearn.compose import ColumnTransformer
from sklearn.preprocessing import OneHotEncoder
from sklearn.impute import SimpleImputer


column_transformer = ColumnTransformer([
    ('categorical', OneHotEncoder(","))
])

# Transform the data
X_train = column_transformer.fit_transform(X_train)
X_test = column_transformer.transform(X_test)

""""""### Task 2 <a id=""task2_2""></a> (0.7 points)

Fit and compare 5 different models (use sklearn): Gradient Boosting, Random Forest, Decision Tree, SVM, Logitics Regression
    
* Choose one classification metric and justify your choice .
* Compare the models using score on cross validation. Mind the class balance when choosing the cross validation. (You can read more about different CV strategies [here](https://scikit-learn.org/stable/modules/cross_validation.html#stratified-k-fold))
* Which model has the best performance? Which models overfit or underfit?""""""

# YOUR CODE HERE

""""""```your comments here```""""""

""""""### Task 3 <a id=""task2_3""></a> (0.5 points)

More Gradient Boosting. You will have to take one of the three popular boosting implementations (xgboost, lightgbm, catboost). Select hyperparameters (number of trees, learning rate, depth) on cross-validation and compare with the methods from the previous task. """"""

# YOUR CODE HERE

""""""```your comments here```""""""

""""""### Task 4 <a id=""task2_4""></a> (0.7 points)

Now let's train more fancy ensembles:

* Bagging with decision trees as base estimators
* Bagging with gradient boosting (with large amount of trees, >100) as base estimators
* [Voting classifier](https://scikit-learn.org/stable/modules/generated/sklearn.ensemble.VotingClassifier.html#sklearn.ensemble.VotingClassifier) 
* [Stacking Classifier](https://scikit-learn.org/stable/modules/generated/sklearn.ensemble.StackingClassifier.html#sklearn.ensemble.StackingClassifier) with Logistic Regression as a final model
* [Stacking Classifier](https://scikit-learn.org/stable/modules/generated/sklearn.ensemble.StackingClassifier.html#sklearn.ensemble.StackingClassifier) with Gradeint Boosting as a final model


If not stated in the task, feel free to tune / choose hyperparameters and base models.

Answer the questions:
* Which model has the best performance?
* Does bagging reduce overfiting of the gradient boosting with large amount of trees? 
* What is the difference between voting and staking? """"""

# YOUR CODE HERE

""""""```your comments here```""""""

""""""### Task 5 <a id=""task2_5""></a> (0.1 points)

Report the test score for the best model, that you were able to train. """"""

# YOUR CODE HERE",codestral-2405,llama-3.1-405b-instruct,0.0,"handle_unknown='ignore', min_frequency=10, max_categories=10), cat_columns),
    ('numerical', SimpleImputer(strategy='mean'), num_columns)
], remainder='passthrough')","min_frequency=0.01, handle_unknown='ignore'"
"#include <iostream>
#include <cmath>

int fib(int n){
    if (n <= 0) return 0;
    if (n == 1) return 1;
    int a = 0, b = 1, c;
    for (int i = 2; i <= n; ++i) {
        c = a + b;
        a = b;
        b = c;
    }
    return b;
}
/*
int fib2(int n) {
    double c = (1+sqrt(5))/2;
    return round(pow(c, n) / sqrt(5));
}
int exp(int n, int k){
    if (k == 0) return 1;
    if (k == 1) return n;
    int tmp = exp(n, k/2);
    int res = tmp*tmp; 
    if (k % 2 != 0)res*=n;
    return res;
}
*/
int mMat(int a[], int b[], int res[]) {
    res[0] = a[0] * b[0] + a[1] * b[2];
    res[1] = a[0] * b[1] + a[1] * b[3];
    res[2] = a[2] * b[0] + a[3] * b[2];
    res[3] = a[2] * b[1] + a[3] * b[3];
    return 0;
}
int mMat2(int a[], int b[], int res[]) {
    res[0] = a[0] * b[0] + a[1] * b[1];
    res[1] = a[2] * b[0] + a[3] * b[1];
    return 0;
}
int expF(int n[], int res1[], int k) {
    int temp[4]","
}

int main(){
    int k = 1;
    int n[4] ={1,1,1,0};
    int res1[4];
    mMat(n,n,res1);
    std::cout<<res1[0]<< ' ' <<res1[1]<< ""\n"" <<res1[2]<<' '<<res1[3]<< ""\n"";
    int b[2] = {fib(k),fib(k-1)};
    int res2[4];
    mMat2(n,b,res2);

    std::cout<<res2[0]<< ' ' <<res2[1]<< ""\n"" <<res2[2]<<' '<<res2[3];
    return 0;
}
",llama-3.1-70b-instruct,claude-3-5-sonnet-20240620,0.0,";
    if (k == 0) {
        res1[0] = 1; res1[1] = 0; res1[2] = 0; res1[3] = 1;
        return 0;
    }
    if (k == 1) {
        res1[0] = n[0]; res1[1] = n[1]; res1[2] = n[2]; res1[3] = n[3];
        return 0;
    }
    expF(n, temp, k / 2);
    mMat(temp, temp, res1);
    if (k % 2 != 0) {
        mMat(res1, n, res1);
    }
    return 0;",";
    if (k == 1) {
        for (int i = 0; i < 4; i++) {
            res1[i] = n[i];
        }
        return 0;
    }
    expF(n, temp, k/2);
    mMat(temp, temp, res1);
    if (k % 2 != 0) {
        mMat(res1, n, temp);
        for (int i = 0; i < 4; i++) {
            res1[i] = temp[i];
        }
    }
    return 0;"
"# constant.py
import random

def get_aggression():
    return random.choice([0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9, 1.0])

def get_kickoff():
    return random.choice([0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9, 1.0])

AGGRESION = get_aggression()

",,codestral-2405,llama-3.1-70b-instruct,1.0,KICKOFF = get_kickoff(),"    AGGRESION = get_aggression()

    KICKOFF = get_kickoff()
"
"import gradio as gr
import requests
from src.core.init_repo import process_process_input

def init_repo(repo_link):
    """"""Send repository link to server and get initialization parameter""""""
    try:
        cache_name = process_process_input(repo_link)
        repo_params = {""repo_name"": repo_link.split(""/"")[-1], ""cache_id"": cache_name}
        return (
            repo_params,
            f""Successfully initialized repository: {repo_params['repo_name']}\n Select model Custume Documentalist To Give any task to your specialized model"",
        )
    except Exception as e:
        return {
            ""repo_name"": """",
            ""cache_id"": """",
        }, f""Error initializing repository: {str(e)}""

def respond(message, chat_history, model_name, repo_param={""repo_name"": """", ""cache_id"": """"}):
    history_text = """"
    if chat_history:
        for user_msg, bot_msg in chat_history:
            history_text += f""User: {user_msg}\nYou: {bot_msg}\n""
    else:
        chat_history = []

    history_text += f""User: {message}\n""
    payload = {
        ""message"": history_text,
        ""model_name"": model_name,
        ""cache_id"": repo_param[""cache_id""] if type(repo_param)==dict else """",
        ""repo_name"": repo_param[""repo_name""] if type(repo_param)==dict else ","
    }
    endpoint_url = ""http://localhost:8000/generate""

    try:
        response = requests.post(endpoint_url, json=payload)
        response.raise_for_status()
        reply_text = response.json().get(""response"", """")
    except Exception as e:
        reply_text = ""Error: Unable to get a response from the server.""

    chat_history.append((message, reply_text))
    return chat_history

custom_css = """"""
:root {
    --main-bg-color: #1a1a1a;
    --component-bg-color: #252525;
    --border-color: #3a3a3a;
    --text-color: white;
    --hover-color: #2d2d2d;
}

body {
    margin: 0 !important;
    padding: 0 !important;
    background-color: var(--main-bg-color) !important;
}

.main-container {
    height: 100vh !important;
    padding: 1rem !important;
    box-sizing: border-box !important;
    display: flex !important;
    flex-direction: column !important;
    gap: 1rem !important;
}

#model-selector {
    background-color: var(--component-bg-color) !important;
    border-radius: 8px !important;
    border: 1px solid var(--border-color) !important;
    padding: 0.5rem !important;
    color: var(--text-color) !important;
    width: 100% !important;
    max-width: 300px !important;
}

#repo-container {
    background-color: var(--component-bg-color) !important;
    border-radius: 8px !important;
    border: 1px solid var(--border-color) !important;
    padding: 1rem !important;
    display: flex !important;
    flex-direction: column !important;
    gap: 0.5rem !important;
    width: 100% !important;
}

#chatbot {
    flex-grow: 1 !important;
    background-color: var(--component-bg-color) !important;
    border: 1px solid var(--border-color) !important;
    border-radius: 8px !important;
    overflow-y: auto !important;
    padding: 1rem !important;
}

#input-container {
    background-color: var(--component-bg-color) !important;
    border: 1px solid var(--border-color) !important;
    border-radius: 8px !important;
    padding: 1rem !important;
    display: flex !important;
    gap: 0.5rem !important;
}

#input-box {
    flex-grow: 1 !important;
    background-color: var(--component-bg-color) !important;
    border: 1px solid var(--border-color) !important;
    border-radius: 4px !important;
    color: var(--text-color) !important;
    padding: 0.5rem !important;
    transition: all 0.2s ease-in-out !important;
}

#input-box:focus {
    border-color: #4a4a4a !important;
    outline: none !important;
}

#submit-btn {
    background-color: var(--component-bg-color) !important;
    border: 1px solid var(--border-color) !important;
    border-radius: 4px !important;
    color: var(--text-color) !important;
    padding: 0.5rem 1rem !important;
    cursor: pointer !important;
    transition: all 0.2s ease-in-out !important;
}

#submit-btn:hover {
    background-color: var(--hover-color) !important;
}

@media (max-width: 768px) {
    .main-container {
        padding: 0.5rem !important;
    }
    
    #input-container {
        flex-direction: column !important;
    }
    
    #submit-btn {
        width: 100% !important;
    }
}

/* Custom scrollbar */
::-webkit-scrollbar {
    width: 8px !important;
}

::-webkit-scrollbar-track {
    background: var(--main-bg-color) !important;
}

::-webkit-scrollbar-thumb {
    background: var(--border-color) !important;
    border-radius: 4px !important;
}

::-webkit-scrollbar-thumb:hover {
    background: var(--hover-color) !important;
}
""""""

# Create the Gradio interface
with gr.Blocks(css=custom_css, theme=gr.themes.Base()) as demo:
    repo_param = gr.State("""")

    with gr.Column(elem_id=""main-container""):
        model_selector = gr.Dropdown(
            choices=[
                ""gemini-1.5-flash-8b-001"",
                ""gemini-1.5-flash-002"",
                ""gemini-1.5-pro-002"",
                ""Custume Documentalist"",
            ],
            value=""gemini-1.5-flash-8b-001"",
            label=""Select Model"",
            elem_id=""model-selector"",
        )

        with gr.Row(elem_id=""repo-container""):
            repo_input = gr.Textbox(
                show_label=False,
                placeholder=""Enter repository link"",
                scale=8
            )
            repo_submit = gr.Button(""Initialize"", scale=1)
            repo_message = gr.Textbox(
                show_label=False,
                interactive=False,
                scale=1
            )

        chatbot = gr.Chatbot(
            elem_id=""chatbot"",
            label=""Chat"",
            height=None,
        )

        with gr.Row(elem_id=""input-container""):
            msg = gr.Textbox(
                show_label=False,
                placeholder=""Type your message here..."",
                elem_id=""input-box"",
                scale=9
            )
            send_btn = gr.Button(""Send"", elem_id=""submit-btn"", scale=1)

    def user_input(user_message, chat_history, model_name, current_repo_param):
        if not user_message.strip():
            return """", chat_history
        return """", respond(user_message, chat_history or [], model_name, current_repo_param)

    repo_submit.click(
        init_repo,
        inputs=[repo_input],
        outputs=[repo_param, repo_message]
    )

    send_btn.click(
        user_input,
        inputs=[msg, chatbot, model_selector, repo_param],
        outputs=[msg, chatbot],
    )
    
    msg.submit(
        user_input,
        inputs=[msg, chatbot, model_selector, repo_param],
        outputs=[msg, chatbot],
    )

demo.launch(
    share=True,
    debug=True,
    show_error=True,
    server_name=""0.0.0.0"",
    server_port=7865
)",codestral-2405,deepseek-coder-fim,0.0,""""",",""""""
"import {ApiError} from ""../utils/ApiError.js""
import {ApiResponse} from ""../utils/ApiResponse.js""
import {asyncHandler} from ""../utils/asyncHandler.js""
import   { Space }   from ""@repo/db/src/modules/Space.moduls.js""
import   { Map }   from ""@repo/db/src/modules/Map.moduls.js""
import   { SpaceElement }   from ""@repo/db/src/modules/SpaceElements.moduls.js""



const createSpace = asyncHandler(async(req, res)=>{
    const {name, width, height, thumbnail, mapId} = req.body;
    
    if([name, width, height, thumbnail].some(field => field?.trim()=== """")) {
        throw new ApiError(new ApiError(400, ""All fields are required""));
    }

    if(!mapId){
        const space = await Space.create({
            data : {
                name,
                width,
                height,
                thumbnail,
                creatorId: req.user,
            }
        })
     return res.json({spaceId : space._id})
    
    }

    const map = await Map.findOne({mapId})
    if(!map){
        throw new ApiError(400, ""Map not found"");
    }

    let space = asyncHandler(async ()=>{
        const space = await Space.create({
                name, 
                width : map.width,
                height : map.height,
                creatorId: req.user,
        })

        await SpaceElement.Create({
              map",".SpaceElement.map(x =>({
                spaceId : space._id,
                elementId,
                x : x.x,
                y : x.y
            }))
        })
        return space
    })

    console.log(""space crated"")

    return res
    .status(200)
    .json(
        new ApiResponse(200,space, ""new Space has been created"" )
    )
});


const deleteElement = asyncHandler(async(req, res)=>{
    const {elementId} = req.body

    if(!elementId){
        throw new ApiError(400, ""Name is required"");
    }

   
    await Space.findByIdAndDelete({elementId})

    return res
    .status(200)
    .json({message: ""Space deleted successfully""});

})

const deleteSpace = asyncHandler(async (req, res)=>{
    
    const space = Space.findById(req.params.spaceId)

    if(!space){
        throw new ApiError(404, ""Space not found"")
    }

    if(space.creatorId !== req.user){
        throw new ApiError(403, ""Unauthorized to delete this space"");
    }

    await Space.deleteOne(space);

    return res
    .status(200)
    .json(
        new ApiResponse(200, {}, ""Space deleted successfully"")
    );

})

const getAllSpace = asyncHandler(async(req, res)=>{
    const spaces = await Space.find({});

    if (!spaces || spaces.length === 0) {
        throw new ApiError(404, ""No spaces found"");
    }

    return res
    .status(200)
    .json(
        new ApiResponse(200, spaces, ""All spaces retrieved successfully"")
    );
})

const addElement = asyncHandler(async( req, res)=>{
    const {spaceId, elementId, x , y } = req.body

    const space = Space.findOne({
        $and : [{spaceId}, {creatorId : req.user} ]
    })

    if(!space){
       throw new ApiError(404, ""Space not found"");
    }

    if(x < 0 || y < 0){
        throw new ApiError(400, ""Pointer is Out of Boundry"");
    }
    
    await SpaceElement.create({
        data : {
            spaceId,
            elementId,
            x,
            y
        }
    })

    return res
    .status(200)
    .json(
        new ApiResponse(200, {}, ""Element added successfully"")
    )

})

const getspace = asyncHandler(async(req, res)=>{
    const space = Space.findOne(req.params.spaceId)
    
    if(!space){
        throw new ApiError(400, ""space not found !!"")
    }

    return res
    .status(200)
    .json(
        new ApiResponse(200, {
            ""dimensions"" : `${space.width},${space.height}`,
            element: space.element.map(e =>({
                id : e._id,
                element : {
                    _id : e.element._id,
                    imageUrl : e.element.imageUrl,
                    width : e.element.width,
                    height : e.element.heigth,
                    isStatic  :e.element.isStatic
                },
                x : e.x,
                Y : e.Y
            }))
        }
                
            , ""Space retrieved successfully"" 
        )
    )
})



export {
    createSpace,
    deleteElement,
    deleteSpace,
    getAllSpace,
    addElement,
    getspace,
}",gemini-1.5-flash-002,llama-3.1-70b-instruct,0.0,"Id: mapId,
            elements : map<CODE>","Id,
                elementId: map.elementId,
            })
        })

        await SpaceElement.Create({
              map"
"import json

# Example data in conversational format
data = [
    {""messages"": [{""role"": ""system"", ""content"": ""You are a helpful assistant.""}, {""role"": ""user"", ""content"": ""What is the capital of France?""}, {""role"": ""assistant"", ""content"": ""The capital of France is Paris.""}]},
    {""messages"": [{""role"": ""system"", ""content"": ""You are a friendly assistant.""}, {""role"": ""user"", ""content"": ""How can I learn Python programming?""}, {""role"": ""assistant"", ""content"": ""To learn Python, you can start with tutorials on websites like Codecademy or W3Schools.""}]},
    {""messages"": [{""role"": ""system"", ""content"": ""You are a helpful assistant.""}, {""role"": ""user"", ""content"": ""What is the capital of France?""}, {""role"": ""assistant"", ""content"": ""The capital of France is Paris.""}]},
{""messages"": [{""role"": ""system"", ""content"": ""You are a helpful assistant.""}, {""role"": ""user"", ""content"": ""What is the square root of 144?""}, {""role"": ""assistant"", ""content"": ""The square root of 144 is 12.""}]},
{""messages"": [{""role"": ""system"", ""content"": ""You are a knowledgeable assistant.""}, {""role"": ""user"", ""content"": ""Tell me about quantum computing.""}, {""role"": ""assistant"", ""content"": ""Quantum computing is a type of computing that uses quantum-mechanical phenomena, such as superposition and entanglement, to perform operations on data.""}]},
{""messages"": [{""role"": ""system"", ""content"": ""You are a friendly assistant.""}, {""role"": ""user"", ""content"": ""How can I learn Python programming?""}, {""role"": ""assistant"", ""content"": ""To learn Python programming, start with basic tutorials on websites like Codecademy, then try solving problems on platforms like LeetCode or HackerRank.""}]},
{""messages"": [{""role"": ""system"", ""content"": ""You are a helpful assistant.""}, {""role"": ""user"", ""content"": ""What is the weather like in New York?""}, {""role"": ""assistant"", ""content"": ""I'm unable to provide real-time weather updates. You can check the current weather in New York using websites like Weather.com.""}]},
{""messages"": [{""role"": ""system"", ""content"": ""You are an assistant for educational purposes.""}, {""role"": ""user"", ""content"": ""Can you explain Einstein's theory of relativity?""}, {""role"": ""assistant"", ""content"": ""Einstein's theory of relativity consists of two parts: special relativity, which deals with objects moving at constant speed, and general relativity, which deals with the effect of gravity on the fabric of space-time.""}]},
{""messages"": [{""role"": ""system"", ""content"": ""You are a helpful assistant.""}, {""role"": ""user"", ""content"": ""What is the boiling point of water?""}, {""role"": ""assistant"", ""content"": ""The boiling point of water is 100°C (212°F) at sea level.""}]},
{""messages"": [{""role"": ""system"", ""content"": ""You are a knowledgeable assistant.""}, {""role"": ""user"", ""content"": ""Can you help me with my math homework?""}, {""role"": ""assistant"", ""content"": ""Sure! What problem are you working on?""}]},
{""messages"": [{""role"": ""system"", ""content"": ""You are an assistant who answers questions on science topics.""}, {""role"": ""user"", ""content"": ""What is photosynthesis?""}, {""role"": ""assistant"", ""content"": ""Photosynthesis is the process by which green plants and some other organisms use sunlight to synthesize foods with the help of chlorophyll.""}]},
{""messages"": [{""role"": ""system"", ""content"": ""You are a helpful assistant.""}, {""role"": ""user"", ""content"": ""How do I make a cake?""}, {""role"": ""assistant"", ""content"": ""To make a basic cake, you'll need flour, sugar, eggs, butter, and baking powder. Mix the dry ingredients, then add the wet ingredients, and bake in the oven at 350°F for about 30 minutes.""}]},
{""messages"": [{""role"": ""system"", ""content"": ""You are an assistant for language learning.""}, {""role"": ""user"", ""content"": ""How do I say 'thank you' in French?""}, {""role"": ""assistant"", ""content"": ""In French, 'thank you' is 'merci'.""}]},
{""messages"": [{""role"": ""system"", ""content"": ""You are a math assistant.""}, {""role"": ""user"", ""content"": ""What is the derivative of x^2?""}, {""role"": ""assistant"", ""content"": ""The derivative of x^2 is 2x.""}]},
{""messages"": [{""role"": ""system"", ""content"": ""You are a helpful assistant.""}, {""role"": ""user"", ""content"": ""Can you help me find a good book to read?""}, {""role"": ""assistant"", ""content"": ""Sure! What genre are you interested in?""}]},
{""messages"": [{""role"": ""system"", ""content"": ""You are a language model assistant.""}, {""role"": ""user"", ""content"": ""What is AI?""}, {""role"": ""assistant"", ""content"": ""AI, or Artificial Intelligence, is the simulation of human intelligence in machines that are programmed to think, learn, and problem-solve like humans.""}]},
{""messages"": [{""role"": ""system"", ""content"": ""You are a knowledgeable assistant.""}, {""role"": ""user"", ""content"": ""How does a plane fly?""}, {""role"": ""assistant"", ""content"": ""A plane flies due to the lift generated by its wings, which is created by the air pressure difference between the upper and lower surfaces of the wings.""}]},
{""messages"": [{""role"": ""system"", ""content"": ""You are an assistant focused on historical topics.""}, {""role"": ""user"", ""content"": ""Who was Julius Caesar?""}, {""role"": ""assistant"", ""content"": ""Julius Caesar was a Roman general and statesman who played a critical role in the events that led to the demise of the Roman Republic and the rise of the Roman Empire.""}]},
{""messages"": [{""role"": ""system"", ""content"": ""You are an assistant for technology-related queries.""}, {""role"": ""user"", ""content"": ""What is blockchain?""}, {""role"": ""assistant"", ""content"": ""Blockchain is a decentralized digital ledger that records transactions across many computers, ensuring that the record cannot be altered retroactively.""}]},
{""messages"": [{""role"": ""system"", ""content"": ""You are a science assistant.""}, {""role"": ""user"", ""content"": ""What is gravity?""}, {""role"": ""assistant"", ""content"": ""Gravity is a force that attracts objects with mass towards each other. It is what gives weight to objects and causes them to fall towards the ground when dropped.""}]},
{""messages"": [{""role"": ""system"", ""content"": ""You are a friendly assistant.""}, {""role"": ""user"", ""content"": ""How do I fix a leaky faucet?""}, {""role"": ""assistant"", ""content"": ""To fix a leaky faucet, you can replace the washer or O-ring inside the faucet valve, which is often the cause of the leak.""}]}","
]

# Save data to a .jsonl file
with open('1dataset.jsonl', 'w', encoding='utf-8') as f:
    for item in data:
        json.dump(item, f, ensure_ascii=False)
        f.write('\n')
",llama-3.1-70b-instruct,gpt-4o-2024-08-06,0.0,"        for idx2, elem2 in enumerate(numbers):
            if idx != idx2:
                distance = abs(elem - elem2)
                if distance < threshold:
                    return True

    return False","
]

# Save data to a .jsonl file
with open('1dataset.jsonl', 'w', encoding='utf-8') as f:
    for item in data:
        json.dump(item, f, ensure_ascii=False)
        f.write('
')"
"from collections import defaultdict
import json
import math
import gdown
import numpy as np
import pandas as pd
import seaborn as sns
import matplotlib.pyplot as plt
from matplotlib.colors import LinearSegmentedColormap
import plotly.express as px
from tqdm import tqdm
import os
import requests
import torch
import torch.nn as nn
import sys

# Adjust display format for pandas
pd.options.display.float_format = '{:.2f}'.format

# Add parent directory to system path
notebook_dir = os.getcwd()
parent_dir = os.path.dirname(notebook_dir)
sys.path.append(os.path.join(parent_dir, 'core'))

# Import from core directory
from algorithms import GD, LogisticModel

# Load models, X, Y, and datetimes to a file
data = np.load('./.cache/models_X_Y.npz', allow_pickle=True)
models, X, Y, datetimes = data['models'], data['X'], data['Y'], data['datetimes']

truncate = 50000
X = X[-truncate:]
Y = Y[-truncate:]
datetimes = datetimes[-truncate:]

# Subset to only the models with battles
idx_nonzero = np.abs(X).sum(axis=0) > 0

X = X.T[idx_nonzero].T
models = models[idx_nonzero]

# Make a dataframe with columns ""model a"", ""model b"", and ""win""
df = pd.DataFrame(columns=['model_a', 'model_b', 'win'])
# Each row of X is -1 for model a and 1 for model b
df_list = []
for i in range(X.shape[0]):
    model_a = models[X[i] == -1][0]
    model_b = models[X[i] == 1][0]
    win = Y[i]
    df_list += [pd.DataFrame([{
        'model_a': model_a,
        'model_b': model_b,
        'win': win
    }])]
df = pd.concat(df_list, ignore_index=True)


df

# Make a seaborn heatmap of the win rates between the different models.
# A model can appear both in column model_a and in column model_b
# The value of the cell is the win rate of model_a against model_b
# The win rate is the number of wins of model_a against model_b divided by the total number of battles between model_a and model_b
# The color of the cell is the win rate
pivot_table = df.pivot_table(index='model_a', columns='model_b', values='win', aggfunc='mean')

plt.figure(figsize=(30, 28))
sns.heatmap(pivot_table, annot=True, fmt="".2f"", cmap=""YlGnBu"")
plt.title('Win Rates Between Models')
plt.xlabel('Model B')
plt.ylabel('Model A')
# Make the plot square
","

",deepseek-coder-fim,gpt-4o-mini-2024-07-18,0.0,"plt.gca().set_aspect('equal', adjustable='box')
plt.show()","plt.axis('equal')
plt.show()"
"# dummy functions

def a(arg1 = ""a(arg1)""):
    print(arg1)

def b(arg1 = ""b(arg1)""):
    print(arg1)


# dictionnary to store functions in a list

dictionnary = {
    ""sequence_1"" : ","
}",llama-3.1-70b-instruct,claude-3-5-sonnet-20241022,0.0,"[a, b],
    ""sequence_2"" : [b, a],
    ""sequence_3"" : [a, a, b, b],
    ""sequence_4"" : [b, b, a, a],","[a, b]"
"{
  ""singleQuote"": true,
  ""trailingComma"": ""all"",
  ""printWidth"": 120,
  ","
}",claude-3-5-sonnet-20241022,gemini-1.5-flash-002,0.0,"""trailingComma"": ""all"",
  ""printWidth"": 120,","""tabWidth"": 2,
  ""semi"": false,
  ""bracketSpacing"": true,
  ""arrowParens"": ""always"""
"import { Hero } from ""@/components/Hero"";
import { Services } from ""@/components/Services"";
import { Statistics } from ""@/components/Statistics"";
import { Testimonials } from ""@/components/Testimonials"";
import { ContactForm } from ""@/components/ContactForm"";
import { Footer } from ""@/components/Footer"";
import","

const Index = () => {
  return (
    <div className=""min-h-screen"">
      <Navbar />
      <Hero />
      <Services />
      <Statistics />
      <Testimonials />
      <ContactForm />
      <Footer />
    </div>
  );
};

export default Index;",gpt-4o-mini-2024-07-18,gpt-4o-2024-08-06,0.0,"  from ""@/components/Footer"";
import Navbar from ""@/components/Navbar"""," { Navbar } from ""@/components/Navbar"""
"from django import forms
from .models import Article, Username

class RegistrationForm(forms.ModelForm):
    class Meta:
        model = Article  # Spécifiez le modèle lié à ce formulaire
        fields = ['title', 'content', 'publication_date', 'email', 'phone']  # Liste des champs à inclure dans le formulaire
        widgets = {
            'title': forms.TextInput(attrs={'class': 'form-control', 'placeholder': 'Title'}),
            'email': forms.EmailInput(attrs={'class': 'form-control', 'placeholder': 'Email'}),
            'content': forms.Textarea(attrs={'class': 'form-control', 'placeholder': 'Content'}),
            'phone': forms.TextInput(attrs={'class': 'form-control', 'placeholder': 'Phone'}),
            'publication_date': forms.DateInput(attrs={'class': 'form-control', 'placeholder': 'Publication Date', 'type': 'date'}),
        }

    
class usernameform:(forms.Model","Form):
    class Meta:
        model=Username
        fields=['firstrname', 'lastname','email','password']
        widgets = {
            'firstname': forms.TextInput(attrs={'class': 'form-control', 'placeholder': 'firstname'}),
            'lastname': forms.TextInput(attrs={'class': 'form-control', 'placeholder': 'lastname'}),
            'email': forms.EmailInput(attrs={'class': 'form-control', 'placeholder': 'Email'}),
            'password': forms.PasswordInput(attrs={'class': 'form-control', 'placeholder': 'Password'}),
        }

    
class usernameform(forms.Form):
    class Meta:
    
    
    # def clean(self):
    #     cleaned_data = super(RegistrationForm, self).clean()
    #     password = cleaned_data.get('password')
    #     confirm_password = cleaned_data.get('confirm_password')

    #     if password != confirm_password:
    #         raise forms.ValidationError(""Passwords do not match."")",deepseek-coder-fim,gemini-1.5-flash-002,0.0,"Form):
    class Meta:
        model=Username
        fields=['firstrname', 'lastname','email','password']
        widgets = {
            'firstname': forms.TextInput(attrs={'class': 'form-control', 'placeholder': 'firstname'}),
            'lastname': forms.TextInput(attrs={'class': 'form-control', 'placeholder': 'lastname'}),
            'email': forms.EmailInput(attrs={'class': 'form-control', 'placeholder': 'Email'}),
            'password': forms.PasswordInput(attrs={'class': 'form-control', 'placeholder': 'Password'}),
        }

    
class usernameform(forms.Form):
    class Meta:
    
    
    # def clean(self):
    #     cleaned_data = super(RegistrationForm, self).clean()
    #     password = cleaned_data.get('password')
    #     confirm_password = cleaned_data.get('confirm_password')
","        model=Username
        fields=['firstrname', 'lastname','email','password']
        widgets = {
            'firstname': forms.TextInput(attrs={'class': 'form-control', 'placeholder': 'firstname'}),
            'lastname': forms.TextInput(attrs={'class': 'form-control', 'placeholder': 'lastname'}),
            'email': forms.EmailInput(attrs={'class': 'form-control', 'placeholder': 'Email'}),
            'password': forms.PasswordInput(attrs={'class': 'form-control', 'placeholder': 'Password'}),
        }

    
class usernameform(forms."
"*{
    margin: 0px;
    padding: 0px;
}

body {
    font-family: monospace;
    background-color: #0e1111;
}

a {
    text-decoration: none;
    color: black;
}

li {
    list-style: none;
}

.nav {
    background-color: black;
}

.nav_a {
    color: red;
    font-size: 30px;    padding: 20px;
    display: inline-block;
}

.nav ul {
    display: inline-block;
    position: absolute;
    top: 15px;
    left: 1200px;
}

.nav li {
    display: inline-block;
    padding: 0px 20px;
}

.nav_a:hover {
    background-color: red;
    color: black;
    transition: background-color 0.5s;
    border-radius: 20px;
}

.main_ul {
    ","
}

.main_a {
}

",gemini-1.5-flash-002,codestral-2405,0.0,"padding: 0px;
    margin: 0px;
    list-style: none;
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    height: 100vh;
}

.main_ul li {
    padding: 20px;
    font-size: 30px;
    color: white;
    background-color: black;
    border-radius: 20px;
    margin: 20px;
}

.main_ul li:hover {"," margin-top: 100px;
     margin-left: 100px;
     font-size: 20px

















"
"there is some issues to fix :
1- the layout size changes for each tab make it same for all tabs (full width)
2- the complete button shows in all tabs ..it should appear only in pos tab 
3- the complete button  works even the cart is empty make it disabled until there is at least one item in cart 
4- in sales tab add search button next to filters for better ux
5- in sales tab show labels (from - to) for the date and time inputs ranges  and remove the seconds input 
6- in sales tab when selecting a sale it a box appear below the sales box showing sale details and items sold in it
7- the date input for the sales filter should be formated in dd/mm/yyyy
8- the time should be formated hh:mm
9- when completeing sale it should stay in the pos tab and DO NOT GO TO SALES tab
10-in the returs tab when the search empty and the user click search it would shows the latest sales of the day descending meaning last sale comes first 
11-in returns tab when shoosing a sale a box appear under the reultes list showing details for that sale and each item will have a return button so that if a sale have more than one item the user can decide which one to return 
12- add a tab for alerts for : items that expierd with degree of  red labels ..items near expier with degree of ornages and for the low stock items with same color rules 
13-in pos the expireation date shouldbe in mm/yyyy only without day 


there is some issues to fix :
- the layout size changes for each tab make it same for all tabs (full width)
- the date input for the sales filter should be formated in dd/mm/yyyy
- the time should be formated hh:mm remove the seconds input
- in the returs tab shows the latest sales first 
- in the alerts tab :in a grouped box items that expierd with degree of  red labels ..items near expier with degree of ornages 
and below that box another box for the low stock items with same color rules 
- in pos the expireation date shouldbe in mm/yyyy only without day 
- add dummy data for teh sales tab with diif dates and cashier names so that it can be esaier to test 
- in the return tab when searching with cashier name it should be case insenctive 
- add tab for managing pharmacy staff .. add the featuers u think it should be in this tab
-  in the sales tab the input dates format should be dd/mm/yyy




- in pos when quantity of a drug is more than the inventory show a warrn for that and make the quantity input match the inventory stock
- in pos when adding items to the cart show the stock of the drug
- in the alerts tab split the expier and near expire from the low stock so 
- in staff tab : remove the email info and input add a username insted and pass 
- in staff tab to add more staff using a button and a modal conatins the form not the form below the staff list
- when deleting a staff show a confirm modal first
- in the pos tab add tow inputs for discount one in percent and the other fixed amount to apply to the whole cart 
- add key shortcuts for interacting with the system : f1 to open modal for search to find if a drug avilable , f10 for complete sale
- when searching for drug in the modal if it is not avilable it show in red






- when searching for drug in the modal if quantity is = 0 show in red
- in pos when quantity of a drug in cart is more than the inventory SHOW A WARN 
- in pos after adding items to the cart if drug have different expiration dates show them in dropdown so that the user can choose which date to sale fisrt
- in pos move the total amount and the tow discount inouts to the top next to the cart but make it to the right
- add labels for the discount buttons for the fixed add(fixed) for the percent add(%)
-  add more dummy data for drugs 10 more and make some quantity = 0 
- remove the alerts tab and its contents
- in the adding staff form make the role select dropdown not input
- in rturns tab add the ability to search using the drug id so that it shows all the sales contains this drug






- ",,codestral-2405,claude-3-5-sonnet-20240620,0.0," in the returns tab add the ability to search using the drug id so that it shows all the sales contains this drug
-  in the sales tab add the ability to search using the drug id so that it shows all the sales contains this drug
- in the sales tab add the ability to search using the cashier name so that it shows all the sales for this cashier
- in the returns tab add the ability to search using the cashier name so that it shows all the sales for this cashier
- in the sales tab add the ability to search using the sale id so that it shows the sale with this id
- in the returns tab add the ability to search using the sale id so that it shows the sale with this id
- in the sales tab add the ability to search using the drug name so that it shows all the sales contains this drug
- in the returns tab add the ability to search using the drug name so that it shows all the sales contains this drug
- in the sales tab add the ability to search using the drug id so that it shows all the sales contains this drug
- in the returns tab add the ability to search using the drug id so that it shows all the sales contains this drug
- in the sales tab add the ability to search using the drug name so that it shows all the sales contains this drug
- in the returns tab add the ability to search using the drug name so that it shows all the sales contains this drug
- in the sales tab add the ability to search using the cashier name so that it shows all the sales for this cashier
- in the returns tab add the ability to search using the cashier name so that it shows all the sales for this cashier
- in the sales tab add the ability to search using the sale id so that it shows the sale with this id
- in the returns tab add the ability to search using the sale id so that it shows the sale with this id
- in the sales tab add the ability to search using the drug id so that it shows all the sales contains this drug
- in the returns tab add the ability to search using the drug id so that it shows all the sales contains this drug
- in the sales tab add the ability to search using the drug name so that it shows all the sales contains this drug
- in the returns tab add the ability to search using the drug name","when searching for drug in the modal if quantity is = 0 show in red
- in pos when quantity of a drug in cart is more than the inventory SHOW A WARN 
- in pos after adding items to the cart if drug have different expiration dates show them in dropdown so that the user can choose which date to sale fisrt
- in pos move the total amount and the tow discount inouts to the top next to the cart but make it to the right
- add labels for the discount buttons for the fixed add(fixed) for the percent add(%)
-  add more dummy data for drugs 10 more and make some quantity = 0 
- remove the alerts tab and its contents
- in the adding staff form make the role select dropdown not input
- in rturns tab add the ability to search using the drug id so that it shows all the sales contains this drug"
"// kernel in rust

#[kmain]
fn main(_boot_info: &'static BootInfo) -> ! {
    // Initialize the kernel
    init_kernel();

    // Initialize the VGA text mode
    init_vga();

    // Print a message to the screen
    println!(""Hello, world!"");

    // Loop indefinitely
    loop {}
}

// Initialize the kernel
fn init_kernel() {
    // Initialize the heap
    init_heap();",,llama-3.1-405b-instruct,gpt-4o-mini-2024-07-18,0.0,"    // Initialize the kernel
    fn init_kernel() {
        // Initialize the heap
        init_heap();
    }

    // Initialize the heap
    fn init_heap() {
        // Initialize the heap
        // ...
    }

    // Initialize the VGA text mode
    fn init_vga() {
        // Initialize the VGA text mode
        // ...
    }

    // Print a message to the screen
    fn println(message: &str) {","    // Initialize the interrupt descriptor table
    init_idt();
}"
"$nums = [1,2,3];

foreach ($num as $key => $value) {
    $value = ","

    echo $value;
}

",gpt-4o-mini-2024-07-18,deepseek-coder-fim,0.0,$num * 2;,$value * 2;
